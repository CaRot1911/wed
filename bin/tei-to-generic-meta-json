#!/usr/bin/env node
/* eslint strict: "off" */
"use strict";

/* eslint-disable no-console */

//
// Safety harness...
//


function Fatal(msg) {
  this.name = "Fatal";
  this.message = msg;
}
Fatal.prototype = new Error();
Fatal.prototype.constructor = Fatal;

process.on("uncaughtException", (ex) => {
  if (ex instanceof Fatal) {
    process.stderr.write(`${ex.message}\n`);
    process.exit(1);
  }
  else {
    throw ex;
  }
});

//
// Actual logic
//

const ArgumentParser = require("argparse").ArgumentParser;
const path = require("path");
const fs = require("fs");

function fileAsString(p) {
  return fs.readFileSync(path.resolve(p), "utf8").toString();
}

const parser = new ArgumentParser({
  addHelp: true,
  description: "Generates a JSON file suitable for using as the " +
    "``metadata`` option for a generic Meta object. The input file must " +
    "be a JSON file in the format produced by TEI's odd2json.xsl " +
    "transformation.",
});

parser.addArgument(["input"],
                   { help: "Input file." });
parser.addArgument(["output"], {
  help: "Output file. If absent, outputs to stdout.",
  nargs: "?",
});
parser.addArgument(["-p", "--pretty"], {
  help: "Pretty print the final JSON.",
  action: "storeTrue",
});
parser.addArgument(["--dochtml"], {
  help: "A path to where the HTML documentation will be installed on " +
    "the server where wed will execute.",
});

parser.addArgument(["--ns", "--namespace"], {
  help: "Defines a namespace. The format is 'prefix=uri'. This option may be " +
    "repeated to define multiple namespaces.",
  action: "append",
  defaultValue: [],
  metavar: "NAMESPACE",
  dest: "namespaces",
});

const args = parser.parseArgs();

const inputData = fileAsString(args.input);
const parsed = JSON.parse(inputData);

const output = {};

output.generator = "tei_json_to_generic_meta_json";
output.date = new Date().toISOString();
output.version = "1";
output.namespaces = {
  "": "http://www.tei-c.org/ns/1.0",
};
output.dochtml = args.dochtml;

for (const spec of args.namespaces) {
  const sep = spec.indexOf("=");
  if (sep === -1) {
    throw new Fatal(`incorrect format for namespace: ${spec}`);
  }

  const prefix = spec.slice(0, sep);
  const uri = spec.slice(sep + 1);

  if (prefix === "xml") {
    throw new Fatal("can't define the xml prefix");
  }

  if (prefix === "") {
    throw new Fatal("can't define the default prefix");
  }

  if (prefix in output.namespaces) {
    throw new Fatal(`prefix already defined: ${prefix}`);
  }

  output.namespaces[prefix] = uri;
}

const members = parsed.members;
let i;
for (i = members.length - 1; i >= 0; i--) {
  // Delete class specs
  if (members[i].type !== "elementSpec") {
    members.splice(i, 1);
  }
}

for (const member of members) {
  delete member.type;
  delete member.module;
  delete member.classes;
  delete member.model;
  delete member.attributes;
  delete member.classattributes;
  member.name = member.ident;
  member.desc = member.desc;
  delete member.ident;
}

output.elements = members;

const stringified = JSON.stringify(output, undefined,
                                   args.pretty ? 2 : undefined);
if (args.output) {
  fs.writeFileSync(args.output, stringified);
}
else {
  console.log(stringified);
}
