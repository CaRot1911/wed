<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: domutil.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/mangalam.css">
</head>

<body>


<div id="main">

    <h1 class="page-title">Source: domutil.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @module domutil
 * @desc Utilities that manipulate or query the DOM tree.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages
 */
define(/** @lends module:domutil */ function (require, exports, module) {
"use strict";

var $ = require("jquery");
var rangy = require("rangy");
var util = require("./util");

var _indexOf = Array.prototype.indexOf;


/**
 * Gets the first range in the selection.
 * @param {Window} win The window for which we want the selection.
 * @returns {Range|undefined} The first range in the
 * selection. Undefined if there is no selection or no range.
 */
function getSelectionRange(win) {
    var sel = rangy.getSelection(win);

    if (sel === undefined || sel.rangeCount &lt; 1)
        return undefined;

    return sel.getRangeAt(0);
}

/**
 * Creates a range from two points in a document.
 *
 * @param {Node} startContainer
 * @param {integer} startOffset
 * @param {Node} endContainer
 * @param {integer} endOffset
 * @returns {{range: Range, reversed: boolean}} The &lt;code>range&lt;/code>
 * field is a rangy range. The &lt;code>reversed&lt;/code> field is
 * &lt;code>true&lt;/code> if the range is reversed, that is, if the end
 * comes before the start.
 */
function rangeFromPoints(startContainer, startOffset,
                         endContainer, endOffset) {
    var range = rangy.createRange(startContainer.ownerDocument);
    var reversed = false;
    if (rangy.dom.comparePoints(startContainer, startOffset,
                                endContainer, endOffset) &lt;= 0) {
        range.setStart(startContainer, startOffset);
        range.setEnd(endContainer, endOffset);
    }
    else {
        range.setStart(endContainer, endOffset);
        range.setEnd(startContainer, startOffset);
        reversed = true;
    }

    return {range: range, reversed: reversed};
}

/**
 * Focuses the node itself or if the node is a text node, focuses the
 * parent.
 *
 * @param {Node} node Node to focus.
 * @throws {Error} If the node is neither a text node nor an
 * element. Trying to focus something other than these is almost
 * certainly an algorithmic bug.
 */
function focusNode(node) {
    var node_type = node && node.nodeType;
    switch(node_type) {
    case Node.TEXT_NODE:
        node.parentNode.focus();
        break;
    case Node.ELEMENT_NODE:
        node.focus();
        break;
    default:
        throw new Error("tried to focus something other than a text node or " +
                        "an element.");
    }
}

/**
 *
 * &lt;p>This function determines the caret position if the caret was
 * moved forward.&lt;/p>
 *
 * &lt;p>This function does not fully emulate how a browser moves the
 * caret. The sole emulation it performs is to check whether
 * whitespace matters or not. It skips whitespace that does not
 * matter.&lt;/p>
 *
 * @param {Array} caret A caret position where the search starts. This
 * should be an array of length two that has in first position the
 * node where the caret is and in second position the offset in that
 * node. This pair is to be interpreted in the same way node, offset
 * pairs are interpreted in selection or range objects.
 *
 * @param {Node} container A DOM node which indicates the container
 * within which caret movements must be contained.
 *
 * @param {boolean} no_text If true, and a text node would be
 * returned, the function will instead return the parent of the text
 * node.
 *
 * @returns {Array|null} Returns the next caret position, or null if such
 * position does not exist. The &lt;code>container&lt;/code> parameter
 * constrains movements to positions inside it.
 */
function nextCaretPosition(caret, container, no_text) {
    var node = caret[0];
    var offset = caret[1];
    if (no_text === undefined)
        no_text = true;

    var found = false;
    search_loop:
    while(!found) {
        var parent = node.parentNode;
        switch(node.nodeType) {
        case Node.TEXT_NODE:
            if (offset >= node.length ||
                // If the parent node is set to normal whitespace
                // handling, then moving the caret forward by one
                // position will skip this whitespace.
                (parent.lastChild === node &&
                 $(parent).css("white-space") === "normal" &&
                 /^\s+$/.test(node.data.slice(offset)))) {

                // We would move outside the container
                if (container !== undefined && node === container)
                    break search_loop;

                offset = _indexOf.call(parent.childNodes, node) + 1;
                node = parent;
            }
            else {
                offset++;
                found = true;
            }
            break;
        case Node.ELEMENT_NODE:
            if (offset >= node.childNodes.length) {
                // If we've hit the end of what we can search, stop.
                if (parent === null ||
                    parent === node.ownerDocument ||
                    // We would move outside the container
                    (container !== undefined && node === container))
                    break search_loop;

                offset = _indexOf.call(parent.childNodes, node) + 1;
                node = parent;
                found = true;
            }
            else {
                node = node.childNodes[offset];
                offset = 0;
                if (!(node.childNodes.length > 0 &&
                      node.childNodes[offset].nodeType ===
                      Node.TEXT_NODE))
                    found = true;
            }
            break;
        }
    }

    if (!found)
        return null;

    return (no_text && node.nodeType === Node.TEXT_NODE) ?
        [node.parentNode,
         _indexOf.call(node.parentNode.childNodes, node)] : [node, offset];
}

/**
 *
 * &lt;p>This function determines the caret position if the caret was
 * moved backwards.&lt;/p>
 *
 * &lt;p>This function does not fully emulate how a browser moves the
 * caret. The sole emulation it performs is to check whether
 * whitespace matters or not. It skips whitespace that does not
 * matter.&lt;/p>
 *
 * @param {Array} caret A caret position where the search starts. This
 * should be an array of length two that has in first position the
 * node where the caret is and in second position the offset in that
 * node. This pair is to be interpreted in the same way node, offset
 * pairs are interpreted in selection or range objects.
 *
 * @param {Node} container A DOM node which indicates the container
 * within which caret movements must be contained.
 *
 * @param {boolean} no_text If true, and a text node would be
 * returned, the function will instead return the parent of the text
 * node.
 *
 * @returns {Array} Returns the previous caret position, or null if
 * such position does not exist.
 */
function prevCaretPosition(caret, container, no_text) {
    var node = caret[0];
    var offset = caret[1];
    if (no_text === undefined)
        no_text = true;

    var found = false;
    search_loop:
    while(!found) {
        offset--;
        var parent = node.parentNode;
        switch(node.nodeType) {
        case Node.TEXT_NODE:
            if (offset &lt; 0 ||
                // If the parent node is set to normal whitespace
                // handling, then moving the caret back by one
                // position will skip this whitespace.
                ($(node.parentNode).css("white-space") === "normal" &&
                 parent.firstChild === node &&
                 /^\s+$/.test(node.data.slice(0, offset)))) {

                // We would move outside the container
                if (container !== undefined && node === container)
                    break search_loop;

                offset = _indexOf.call(parent.childNodes, node);
                node = parent;
            }
            else
                found = true;
            break;
        case Node.ELEMENT_NODE:
            if (offset &lt; 0 || node.childNodes.length === 0) {
                // If we've hit the end of what we can search, stop.
                if (parent === null ||
                    parent === node.ownerDocument ||
                    // We would move outside the container
                    (container !== undefined && node === container))
                    break search_loop;

                offset = _indexOf.call(parent.childNodes, node);
                node = parent;
                found = true;
            }
            // If node.childNodes.length === 0, the first branch would
            // have been taken. No need to test that offset indexes to
            // something that exists.
            else {
                node = node.childNodes[offset];
                if (node.nodeType === Node.ELEMENT_NODE) {
                    offset = node.childNodes.length;
                    if (!(node.childNodes.length > 0 &&
                          node.childNodes[offset - 1].nodeType ===
                          Node.TEXT_NODE))
                        found = true;
                }
                else
                    offset = node.length + 1;
            }
            break;
        }
    }

    if (!found)
        return null;

    return (no_text && node.nodeType === Node.TEXT_NODE) ?
        [node.parentNode,
         _indexOf.call(node.parentNode.childNodes, node)] : [node, offset];
}

/**
 * Given two trees A and B of DOM nodes, this function finds the node
 * in tree B which corresponds to a node in tree A. The two trees must
 * be structurally identical. If tree B is cloned from tree A, it will
 * satisfy this requirement. This function does not work with
 * attribute nodes.
 *
 * @param {Node} tree_a The root of the first tree.
 * @param {Node} tree_b The root of the second tree.
 * @param {Node} node_in_a A node in the first tree.
 * @returns {Node} The node which corresponds to ``node_in_a`` in
 * ``tree_b``.
 * @throws {Error} If ``node_in_a`` is not ``tree_a`` or a child of ``tree_a``.
 */
function correspondingNode(tree_a, tree_b, node_in_a) {
    var path = [];
    var current = node_in_a;
    while(current !== tree_a) {
        var parent = current.parentNode;
        if (!parent)
            throw new Error("node_in_a is not tree_a or a child of tree_a");
        path.unshift(_indexOf.call(parent.childNodes, current));
        current = parent;
    }

    var ret = tree_b;
    while(path.length)
        ret = ret.childNodes[path.shift()];

    return ret;
}

/**
 * Makes a placeholder element
 *
 * @param {string} text The text to put in the placeholder.
 * @returns {jQuery} A jQuery object.
 */
function makePlaceholder(text) {
    return $("&lt;span class='_placeholder' contenteditable='true'>" +
             (text ? text: " ") + "&lt;/span>");
}

/**
 * Splits a text node into two nodes. This function takes care to
 * modify the DOM tree only once.
 *
 * @param {Node} text_node The text node to split into two text nodes.
 * @param {integer} index The offset into the text node where to split.
 * @returns {Array.&lt;Node>} The first element of the array is the text
 * node which contains the text before index and the second element
 * of the array is the text node which contains the text after the
 * index.
 */
function splitTextNode(text_node, index) {
    var carets = _insertIntoText(text_node, index, undefined, false);
    return [carets[0][0], carets[1][0]];
}


/**
 * &lt;p>Inserts an element into text, effectively splitting the text node in
 * two. This function takes care to modify the DOM tree only once.&lt;/p>
 *
 * &lt;p>This function must have &lt;code>this&lt;/code> set to an object that
 * has the &lt;code>insertNodeAt&lt;/code> and &lt;code>deleteNode&lt;/code> set
 * to functions with the signatures of {@link
 * module:domutil~insertNodeAt insertNodeAt} and {@link
 * module:domutil~mergeTextNodes mergeTextNodes}. It optionally can
 * have a &lt;code>insertFragAt&lt;/code> function with the same signature
 * as &lt;code>insertNodeAt&lt;/code>.&lt;/p>
 *
 * @param {Node} text_node The text node that will be cut in two by the new
 * element.
 * @param {integer} index The offset into the text node where
 * the new element is to be inserted.
 * @param {Node} node The node to insert.
 * @returns {Array} The first element of the array is a caret position
 * (i.e. a pair of container and offset) marking the boundary between
 * what comes before the material inserted and the material
 * inserted. The second element of the array is a caret position
 * marking the boundary between the material inserted and what comes
 * after. If I insert "foo" at position 2 in "abcd", then the final
 * result would be "abfoocd" and the first caret would mark the
 * boundary between "ab" and "foo" and the second caret the boundary
 * between "foo" and "cd".
 * @throws {Error} If the node to insert is undefined or null.
 */
function genericInsertIntoText(text_node, index, node) {
    // This function is meant to be called with this set to a proper
    // value.
    /* jshint validthis:true */
    if (!node)
        throw new Error("must pass an actual node to insert");
    return _genericInsertIntoText.apply(this, arguments);
}

/**
 * Inserts an element into text, effectively splitting the text node in
 * two. This function takes care to modify the DOM tree only once.
 *
 * &lt;p>This function must have &lt;code>this&lt;/code> set to an object that
 * has the &lt;code>insertNodeAt&lt;/code> and &lt;code>deleteNode&lt;/code> set
 * to functions with the signatures of {@link
 * module:domutil~insertNodeAt insertNodeAt} and {@link
 * module:domutil~mergeTextNodes mergeTextNodes}. It optionally can
 * have an &lt;code>insertFragAt&lt;/code> function with the same signature
 * as &lt;code>insertNodeAt&lt;/code>.&lt;/p>
 *
 * @private
 * @param {Node} text_node The text node that will be cut in two by the new
 * element.
 * @param {integer} index The offset into the text node where
 * the new element is to be inserted.
 * @param {Node} node The node to insert. If this parameter evaluates
 * to &lt;code>false&lt;/code>, then this function effectively splits the
 * text node into two parts.
 * @param {boolean} [clean=true] The operation must clean contiguous
 * text nodes so as to merge them and must not create empty
 * nodes. &lt;strong>This code assumes that the text node into which data
 * is added is not preceded or followed by another text node and that
 * it is not empty.&lt;/strong> In other words, if the DOM tree on which
 * this code is used does not have consecutive text nodes and no empty
 * nodes, then after the call, it still won't.
 * @returns {Array} The first element of the array is a caret position
 * (i.e. a pair of container and offset) marking the boundary between
 * what comes before the material inserted and the material
 * inserted. The second element of the array is a caret position
 * marking the boundary between the material inserted and what comes
 * after. If I insert "foo" at position 2 in "abcd", then the final
 * result would be "abfoocd" and the first caret would mark the
 * boundary between "ab" and "foo" and the second caret the boundary
 * between "foo" and "cd".
 * @throws {Error} If &lt;code>text_node&lt;/code> is not a text node.
 */
function _genericInsertIntoText(text_node, index, node, clean) {
    // This function is meant to be called with this set to a proper
    // value.
    /* jshint validthis:true */
    if (text_node.nodeType !== Node.TEXT_NODE)
        throw new Error("insertIntoText called on non-text");

    var start_caret;
    var end_caret;

    if (clean === undefined)
        clean = true;

    // Normalize
    if (index &lt; 0)
        index = 0;
    else if (index > text_node.length)
        index = text_node.length;

    var search_node, prev, next;
    var is_fragment = node && (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);

    var parent = text_node.parentNode;
    var text_node_at = _indexOf.call(parent.childNodes, text_node);
    if (clean && (!node || (is_fragment && node.childNodes.length === 0)))
    {
        start_caret = end_caret = [text_node, index];
    }
    else {
        var frag = document.createDocumentFragment();
        prev = document.createTextNode(text_node.data.slice(0, index));
        frag.appendChild(prev);
        if (node)
            frag.appendChild(node);
        next = document.createTextNode(text_node.data.slice(index));
        var next_len = next.length;
        frag.appendChild(next);

        if (clean)
            frag.normalize();

        if (clean && index === 0)
            start_caret = [parent, text_node_at];
        else
            start_caret = [frag.firstChild, index];

        if (clean && index === text_node.length)
            end_caret = [parent, text_node_at + frag.childNodes.length];
        else
            end_caret = [frag.lastChild, frag.lastChild.length -  next_len];

        this.deleteNode(text_node);
        if (this.insertFragAt)
            this.insertFragAt(parent, text_node_at, frag);
        else
            while (frag.firstChild)
                this.insertNodeAt(parent, text_node_at++, frag.firstChild);
    }
    return [start_caret, end_caret];
}

var plain_dom_mockup =     {
    insertNodeAt: insertNodeAt,
    insertFragAt: insertNodeAt,
    deleteNode: deleteNode
};

/**
 * See {@link module:domutil~_genericInsertIntoText _genericInsertIntoText}.
 *
 * @function
 * @private
 */
var _insertIntoText = _genericInsertIntoText.bind(plain_dom_mockup);

/**
 * Inserts an element into text, effectively splitting the text node in
 * two. This function takes care to modify the DOM tree only once.
 * @function
 * @param {Node} text_node The text node that will be cut in two by the new
 * element.
 * @param {integer} index The offset into the text node where
 * the new element is to be inserted.
 * @param {Node} node The node to insert.
 * @returns {Array} The first element of the array is a caret position
 * (i.e. a pair of container and offset) marking the boundary between
 * what comes before the material inserted and the material
 * inserted. The second element of the array is a caret position
 * marking the boundary between the material inserted and what comes
 * after. If I insert "foo" at position 2 in "abcd", then the final
 * result would be "abfoocd" and the first caret would mark the
 * boundary between "ab" and "foo" and the second caret the boundary
 * between "foo" and "cd".
 */
var insertIntoText = genericInsertIntoText.bind(plain_dom_mockup);

/**
 * Inserts text into a node. This function will use already existing
 * text nodes whenever possible rather than create a new text node.
 *
 * @param {Node} node The node where the text is to be inserted.
 * @param {integer} index The location in the node where the text is
 * to be inserted.
 * @param {string} text The text to insert.
 * @returns {Array.&lt;Node>} The first element of the array is the node
 * that was modified to insert the text. It will be
 * &lt;code>undefined&lt;/code> if no node was modified. The second element
 * is the text node which contains the new text. The two elements are
 * defined and equal if a text node was modified to contain the newly
 * inserted text. They are unequal if a new text node had to be
 * created to contain the new text. A return value of
 * &lt;code>[undefined, undefined]&lt;/code> means that no modification
 * occurred (because the text passed was "").
 * @throws {Error} If &lt;code>node&lt;/code> is not an element or text Node type.
 */
function genericInsertText(node, index, text) {
    // This function is meant to be called with this set to a proper
    // value.
    /* jshint validthis:true */
    if (text === "")
        return [undefined, undefined];

    var text_node;
    work:
    while (true) {
        switch(node.nodeType) {
        case Node.ELEMENT_NODE:
            var child = node.childNodes[index];
            if (child && child.nodeType === Node.TEXT_NODE) {
                // Prepend to already existing text node.
                node = child;
                index = 0;
                continue work;
            }

            var prev = node.childNodes[index - 1];
            if (prev && prev.nodeType === Node.TEXT_NODE) {
                // Append to already existing text node.
                node = prev;
                index = node.length;
                continue work;
            }

            // We have to create a text node
            text_node = document.createTextNode(text);
            this.insertNodeAt(node, index, text_node);
            node = undefined;
            break work;
        case Node.TEXT_NODE:
            var pre = node.data.slice(0, index);
            var post = node.data.slice(index);
            this.setTextNodeValue(node, pre + text + post);
            text_node = node;
            break work;
        default:
            throw new Error("unexpected node type: " + node.nodeType);
        }
    }
    return [node, text_node];
}

/**
 * Inserts text into a node. This function will use already existing
 * text nodes whenever possible rather than create a new text node.
 * @function
 * @param {Node} node The node where the text is to be inserted.
 * @param {integer} index The location in the node where the text is
 * to be inserted.
 * @param {string} text The text to insert.
 * @returns {Array.&lt;Node>} The first element of the array is the node
 * that was modified to insert the text. It will be
 * &lt;code>undefined&lt;/code> if no node was modified. The second element
 * is the text node which contains the new text. The two elements are
 * defined and equal if a text node was modified to contain the newly
 * inserted text. They are unequal if a new text node had to be
 * created to contain the new text. A return value of
 * &lt;code>[undefined, undefined]&lt;/code> means that no modification
 * occurred (because the text passed was "").
 * @throws {Error} If &lt;code>node&lt;/code> is not an element or text Node type.
 */
var insertText = genericInsertText.bind({
    insertNodeAt: insertNodeAt,
    setTextNodeValue: function (node, value) {
        node.data = value;
    }
});

/**
 * Deletes text from a text node. If the text node becomes empty, it
 * is deleted.
 *
 * @param {Node} node The text node from which to delete text.
 * @param {integer} index The index at which to delete text.
 * @param {integer} length The length of text to delete.
 * @throws {Error} If &lt;code>node&lt;/code> is not a text Node type.
 */
function deleteText(node, index, length) {
    if (node.nodeType === Node.TEXT_NODE) {
        node.deleteData(index, length);
        if (!node.length)
            node.parentNode.removeChild(node);
    }
    else
        throw new Error("deleteText called on non-text");
}

/**
 * This function recursively links two DOM trees through the jQuery
 * &lt;code>.data()&lt;/code> method. For an element in the first tree the data
 * item named "wed_mirror_node" points to the corresponding element
 * in the second tree, and vice-versa. It is presumed that the two
 * DOM trees are perfect mirrors of each other, although no test is
 * performed to confirm this.
 *
 * @param {Node} root_a A DOM node.
 * @param {Node} root_b A second DOM node.
 *
 */
function linkTrees(root_a, root_b) {
    $(root_a).data("wed_mirror_node", root_b);
    $(root_b).data("wed_mirror_node", root_a);
    if (root_a.nodeType === Node.ELEMENT_NODE) {
        for(var i = 0; i &lt; root_a.childNodes.length; ++i) {
            var child_a = root_a.childNodes[i];
            var child_b = root_b.childNodes[i];
            linkTrees(child_a, child_b);
        }
    }
}

/**
 * This function recursively unlinks a DOM tree though the jQuery
 * &lt;code>.data()&lt;/code> method.
 *
 * @param {Node} root A DOM node.
 *
 */
function unlinkTree(root) {
    $(root).removeData("wed_mirror_node");
    if (root.nodeType === Node.ELEMENT_NODE)
        for(var i = 0; i &lt; root.childNodes.length; ++i)
            unlinkTree(root.childNodes[i]);
}


/**
 * &lt;p>Returns the first descendant or the node passed to the function
 * if the node happens to not have a descendant. The descendant returned
 * is the deepest one which is first in its parent.&lt;/p>
 *
 * &lt;p>When passed
 * &lt;code>&lt;p>&lt;b>A&lt;/b>&lt;b>&lt;q>B&lt;/q>&lt;/b>&lt;/p>&lt;/code>
 * this code would return the text node "A" because it has no children
 * and is first.&lt;/p>
 *
 * @param {Node} node The node to search.
 * @returns {Node} The first node which is both first in its parent
 * and has no children.
 */
function firstDescendantOrSelf(node) {
    while (node && node.childNodes && node.childNodes.length)
        node = node.firstChild;
    return node;
}

/**
 * Removes the node. Mainly for use with the generic functions defined here.
 *
 * @param {Node} node The node to remove.
 */
function deleteNode(node) {
    node.parentNode.removeChild(node);
}

/**
 * Inserts a node at the position specified. Mainly for use with the
 * generic functions defined here.
 *
 * @param {Node} parent The node which will become the parent of the
 * inserted node.
 * @param {integer} index The position at which to insert the node
 * into the parent.
 * @param {Node} node The node to insert.
 */
function insertNodeAt(parent, index, node) {
    parent.insertBefore(node, parent.childNodes[index] || null);
}

/**
 * Merges a text node with the next text node, if present. When called
 * on something which is not a text node or if the next node is not
 * text, does nothing. Mainly for use with the generic functions defined here.
 *
 * @param {Node} node The node to merge with the next node.
 * @returns {Array} A two-element array. It is a caret position
 * between the two parts that were merged, or between the two nodes
 * that were not merged (because they were not both text).
*/
function mergeTextNodes(node) {
    var next = node.nextSibling;
    if (node.nodeType === Node.TEXT_NODE &&
        next && next.nodeType === Node.TEXT_NODE) {
        var offset = node.length;
        node.appendData(next.data);
        next.parentNode.removeChild(next);
        return [node, offset];
    }

    var parent = node.parentNode;
    return [parent, _indexOf.call(parent.childNodes, node) + 1];
}

/**
 * &lt;p>Removes the contents between the start and end carets from the DOM
 * tree. If two text nodes become adjacent, they are merged.&lt;/p>
 *
 * &lt;p>This function must have &lt;code>this&lt;/code> set to an object that
 * has the &lt;code>deleteText&lt;/code>, &lt;code>deleteNode&lt;/code> and
 * &lt;code>mergeTextNodes&lt;/code> symbols set to functions with the
 * signatures of {@link module:domutil~deleteText deleteText}, {@link
 * module:domutil~deleteNode deleteNode} and {@link
 * module:domutil~mergeTextNodes mergeTextNodes}.
 *
 * @param {Array} start_caret Start caret position.
 * @param {Array} end_caret Ending caret position.
 * @returns {Array} A pair of items. The first item is the caret
 * position indicating where the cut happened. The second item is a
 * list of nodes, the cut contents.
 * @throws {Error} If Nodes in the range are not in the same element.
 */
function genericCutFunction (start_caret, end_caret) {
    if (!isWellFormedRange({startContainer: start_caret[0],
                            startOffset: start_caret[1],
                            endContainer: end_caret[0],
                            endOffset: end_caret[1]}))
        throw new Error("range is not well-formed");

    // This function is meant to be called with this set to a proper
    // value.
    /* jshint validthis:true */
    var start_container = start_caret[0];
    var start_offset = start_caret[1];
    var end_container = end_caret[0];
    var end_offset = end_caret[1];

    var parent = start_container.parentNode;
    var final_caret;
    var start_text;

    if (start_container.nodeType === Node.TEXT_NODE &&
        start_offset === 0) {
        // We are at the start of a text node, move up to the parent.
        start_offset = _indexOf.call(parent.childNodes, start_container);
        start_container = parent;
        parent = start_container.parent;
    }

    if (start_container.nodeType === Node.TEXT_NODE) {
        var same_container = start_container === end_container;

        var start_container_offset = _indexOf.call(
            parent.childNodes, start_container);

        var end_text_offset = same_container ? end_offset :
                start_container.length;

        start_text = parent.ownerDocument.createTextNode(
            start_container.data.slice(start_offset, end_text_offset));
        this.deleteText(start_container, start_offset, start_text.length);

        final_caret = (start_container.parentNode) ?
            [start_container, start_offset] :
            // Selection was such that the text node was emptied.
            [parent, start_container_offset];

        if (same_container)
            // Both the start and end were in the same node, so the
            // deleteText operation above did everything needed.
            return [final_caret, [start_text]];

        // Alter our start to take care of the rest
        start_offset = (start_container.parentNode) ?
            // Look after the text node we just modified.
            start_container_offset + 1 :
            // Selection was such that the text node was emptied, and
            // thus removed. So stay at the same place.
            start_container_offset;
        start_container = parent;
    }
    else
        final_caret = [start_container, start_offset];

    var end_text;
    if (end_container.nodeType === Node.TEXT_NODE) {
        parent = end_container.parentNode;
        var end_container_offset = _indexOf.call(
            parent.childNodes, end_container);

        end_text = parent.ownerDocument.createTextNode(
            end_container.data.slice(0, end_offset));
        this.deleteText(end_container, 0, end_offset);

        // Alter our end to take care of the rest
        end_offset = end_container_offset;
        end_container = parent;
    }

    // At this point, the following checks must hold
    if (start_container !== end_container)
            throw new Error("internal error in cut: containers unequal");
    if (start_container.nodeType !== Node.ELEMENT_NODE)
        throw new Error("internal error in cut: not an element");

    var return_nodes = [];
    end_offset--;
    // Doing it in reverse allows us to not worry about offsets
    // getting out of whack.
    while (end_offset >= start_offset) {
        return_nodes.unshift(end_container.childNodes[end_offset]);
        this.deleteNode(end_container.childNodes[end_offset]);
        end_offset--;
    }
    if (start_text)
        return_nodes.unshift(start_text);
    if (end_text)
        return_nodes.push(end_text);

    // At this point, end_offset points to the node that is before the
    // list of nodes removed.
    if (end_container.childNodes[end_offset])
        this.mergeTextNodes(end_container.childNodes[end_offset]);
    return [final_caret, return_nodes];
}

/**
 * Returns the &lt;strong>element&lt;/strong> nodes that contain the start
 * and the end of the range. If an end of the range happens to be in a
 * text node, the element node will be that node's parent.
 *
 * @private
 * @param {Object} range An object which has the
 * &lt;code>startContainer&lt;/code>, &lt;code>startOffset&lt;/code>,
 * &lt;code>endContainer&lt;/code>, &lt;code>endOffset&lt;/code> attributes
 * set. The interpretation of these values is the same as for DOM
 * &lt;code>Range&lt;/code> objects. Therefore, the object passed can be a
 * DOM range.
 * @returns {Array} A pair of nodes.
 * @throws {Error} If a node in &lt;code>range&lt;/code> is not of element
 * or text Node types.
 */
function nodePairFromRange(range) {
    var start_node;
    switch(range.startContainer.nodeType) {
    case Node.TEXT_NODE:
        start_node = range.startContainer.parentNode;
        break;
    case Node.ELEMENT_NODE:
        start_node = range.startContainer;
        break;
    default:
        throw new Error("unexpected node type: " +
                        range.startContainer.nodeType);

    }

    var end_node;
    switch(range.endContainer.nodeType) {
    case Node.TEXT_NODE:
        end_node = range.endContainer.parentNode;
        break;
    case Node.ELEMENT_NODE:
        end_node = range.endContainer;
        break;
    default:
        throw new Error("unexpected node type: " + range.endContainer.nodeType);
    }
    return [start_node, end_node];
}

/**
 * Determines whether a range is well-formed. A well-formed range is
 * one which starts and ends in the same element.
 *
 * @param {Object} range An object which has the
 * &lt;code>startContainer&lt;/code>, &lt;code>startOffset&lt;/code>,
 * &lt;code>endContainer&lt;/code>, &lt;code>endOffset&lt;/code> attributes
 * set. The interpretation of these values is the same as for DOM
 * &lt;code>Range&lt;/code> objects. Therefore, the object passed can be a
 * DOM range.
 * @returns {boolean} &lt;code>true&lt;/code> if the range is well-formed.
 * &lt;code>false&lt;/code> if not.
 */
function isWellFormedRange(range) {
    var pair = nodePairFromRange(range);
    return pair[0] === pair[1];
}

/**
 * Dumps the current selection to the console.
 *
 * @param {string} msg A message to output in front of the range
 * information.
 * @param {Window} win The window for which to dump selection
 * information.
 */
function dumpCurrentSelection(msg, win) {
    dumpRange(msg, getSelectionRange(win));
}


/**
 * Dumps a range to the console.
 *
 * @param {string} msg A message to output in front of the range
 * information.
 * @param {Window} range The range.
 */
function dumpRange(msg, range) {
    if (!range)
        console.log(msg, "no range");
    else
        console.log(msg,
                    range.startContainer,
                    range.startOffset,
                    range.endContainer,
                    range.endOffset);
}


/**
 * Dumps a range to a string.
 *
 * @param {string} msg A message to output in front of the range
 * information.
 * @param {Window} range The range.
 */
function dumpRangeToString(msg, range) {
    var ret;
    if (!range)
        ret = [msg, "no range"];
    else
        ret = [msg,
               range.startContainer.outerHTML,
               range.startOffset,
               range.endContainer.outerHTML,
               range.endOffset];
    return ret.join(", ");
}


/**
 * Checks whether a point is in the element's contents. This means
 * inside the element and &lt;strong>not&lt;/strong> inside one of the
 * scrollbars that the element may have. The coordinates passed must
 * be &lt;strong>relative to the document.&lt;/strong> If the coordinates
 * are taken from an event, this means passing &lt;code>pageX&lt;/code> and
 * &lt;code>pageY&lt;/code>.
 *
 * @param {Node} element The element to check.
 * @param {number} x The x coordinate &lt;strong>relative to the
 * document.&lt;/strong>
 * @param {number} y The y coordinate &lt;strong>relative to the
 * document.&lt;/strong>
 * @returns {boolean} &lt;code>true&lt;/code> if inside, &lt;code>false&lt;/code>
 * if not.
 */
function pointInContents(element, x, y) {
    // Convert the coordinates relative to the document to coordinates
    // relative to the element.
    var offset = $(element).offset();
    x -= offset.left;
    y -= offset.top;

    return ((x >= 0) && (y >= 0) &&
            (x &lt; element.clientWidth) && (y &lt; element.clientHeight));
}


exports.getSelectionRange = getSelectionRange;
exports.nextCaretPosition = nextCaretPosition;
exports.prevCaretPosition = prevCaretPosition;
exports.makePlaceholder = makePlaceholder;
exports.splitTextNode = splitTextNode;
exports.insertIntoText = insertIntoText;
exports.insertText = insertText;
exports.deleteText = deleteText;
exports.linkTrees = linkTrees;
exports.unlinkTree = unlinkTree;
exports.firstDescendantOrSelf = firstDescendantOrSelf;
exports.isWellFormedRange = isWellFormedRange;
exports.genericCutFunction = genericCutFunction;
exports.genericInsertIntoText = genericInsertIntoText;
exports.genericInsertText = genericInsertText;
exports.deleteNode = deleteNode;
exports.mergeTextNodes = mergeTextNodes;
exports.rangeFromPoints = rangeFromPoints;
exports.focusNode = focusNode;
exports.dumpCurrentSelection = dumpCurrentSelection;
exports.dumpRange = dumpRange;
exports.dumpRangeToString = dumpRangeToString;
exports.pointInContents = pointInContents;
exports.correspondingNode = correspondingNode;

});

//  LocalWords:  genericInsertIntoText endOffset endContainer mockup
//  LocalWords:  startOffset startContainer unlinks DOM gui Mangalam
//  LocalWords:  MPL Dubeau nextSibling versa insertFragAt validthis
//  LocalWords:  insertNodeAt jshint mergeTextNodes deleteNode dom lt
//  LocalWords:  lastChild prev getSelectionRange jQuery deleteText
//  LocalWords:  Prepend insertIntoText cd abfoocd abcd nodeToPath
//  LocalWords:  contenteditable pathToNode whitespace util jquery
//  LocalWords:  domutil
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-action.html">action</a></li><li><a href="module-browsers.html">browsers</a></li><li><a href="module-decorator.html">decorator</a></li><li><a href="module-dloc.html">dloc</a></li><li><a href="module-domlistener.html">domlistener</a></li><li><a href="module-domutil.html">domutil</a></li><li><a href="module-exceptions.html">exceptions</a></li><li><a href="context_menu.html">gui/context_menu</a></li><li><a href="modal.html">gui/modal</a></li><li><a href="tooltip.html">gui/tooltip</a></li><li><a href="module-gui_updater.html">gui_updater</a></li><li><a href="module-guiroot.html">guiroot</a></li><li><a href="module-input_trigger.html">input_trigger</a></li><li><a href="module-input_trigger_factory.html">input_trigger_factory</a></li><li><a href="module-jqutil.html">jqutil</a></li><li><a href="module-key.html">key</a></li><li><a href="module-key_constants.html">key_constants</a></li><li><a href="conditioned.html">lib/conditioned</a></li><li><a href="pubsub.html">lib/pubsub</a></li><li><a href="simple_event_emitter.html">lib/simple_event_emitter</a></li><li><a href="module-log.html">log</a></li><li><a href="module-mode.html">mode</a></li><li><a href="generic.html">modes/generic/generic</a></li><li><a href="generic_decorator.html">modes/generic/generic_decorator</a></li><li><a href="generic_meta.html">modes/generic/generic_meta</a></li><li><a href="generic_tr.html">modes/generic/generic_tr</a></li><li><a href="tei_meta.html">modes/generic/metas/tei_meta</a></li><li><a href="test_decorator.html">modes/test/test_decorator</a></li><li><a href="test_mode.html">modes/test/test_mode</a></li><li><a href="module-mutation_domlistener.html">mutation_domlistener</a></li><li><a href="module-object_check.html">object_check</a></li><li><a href="module-onbeforeunload.html">onbeforeunload</a></li><li><a href="module-onerror.html">onerror</a></li><li><a href="module-oop.html">oop</a></li><li><a href="module-preferences.html">preferences</a></li><li><a href="module-refman.html">refman</a></li><li><a href="module-saver.html">saver</a></li><li><a href="module-transformation.html">transformation</a></li><li><a href="module-tree_updater.html">tree_updater</a></li><li><a href="module-undo.html">undo</a></li><li><a href="module-undo_recorder.html">undo_recorder</a></li><li><a href="module-updater_domlistener.html">updater_domlistener</a></li><li><a href="module-util.html">util</a></li><li><a href="module-validator.html">validator</a></li><li><a href="module-wed.html">wed</a></li><li><a href="module-wundo.html">wundo</a></li></ul><h3>Externals</h3><ul><li><a href="external-jQuery.html">jQuery</a></li></ul><h3>Classes</h3><ul><li><a href="module-action-Action.html">action~Action</a></li><li><a href="module-decorator-Decorator.html">decorator~Decorator</a></li><li><a href="module-dloc-DLoc.html">dloc~DLoc</a></li><li><a href="module-domlistener-Listener.html">domlistener~Listener</a></li><li><a href="module-exceptions-AbortTransformationException.html">exceptions~AbortTransformationException</a></li><li><a href="context_menu-ContextMenu.html">gui/context_menu~ContextMenu</a></li><li><a href="modal-Modal.html">gui/modal~Modal</a></li><li><a href="module-gui_updater-GUIUpdater.html">gui_updater~GUIUpdater</a></li><li><a href="module-input_trigger-InputTrigger.html">input_trigger~InputTrigger</a></li><li><a href="module-key-Key.html">key~Key</a></li><li><a href="conditioned-Conditioned.html">lib/conditioned~Conditioned</a></li><li><a href="simple_event_emitter-SimpleEventEmitter.html">lib/simple_event_emitter~SimpleEventEmitter</a></li><li><a href="module-log-Handled.html">log~Handled</a></li><li><a href="generic_decorator-GenericDecorator.html">modes/generic/generic_decorator~GenericDecorator</a></li><li><a href="generic_meta-Meta.html">modes/generic/generic_meta~Meta</a></li><li><a href="generic_tr-Registry.html">modes/generic/generic_tr~Registry</a></li><li><a href="generic-Mode.html">modes/generic/generic~Mode</a></li><li><a href="tei_meta-TeiMeta.html">modes/generic/metas/tei_meta~TeiMeta</a></li><li><a href="test_decorator-TestDecorator.html">modes/test/test_decorator~TestDecorator</a></li><li><a href="test_mode-TestMode.html">modes/test/test_mode~TestMode</a></li><li><a href="module-mode-Mode.html">mode~Mode</a></li><li><a href="module-mutation_domlistener-Listener.html">mutation_domlistener~Listener</a></li><li><a href="module-refman-ReferenceManager.html">refman~ReferenceManager</a></li><li><a href="module-refman-SenseReferenceManager.html">refman~SenseReferenceManager</a></li><li><a href="module-saver-Saver.html">saver~Saver</a></li><li><a href="module-transformation-Transformation.html">transformation~Transformation</a></li><li><a href="module-transformation-TransformationRegistry.html">transformation~TransformationRegistry</a></li><li><a href="module-tree_updater-TreeUpdater.html">tree_updater~TreeUpdater</a></li><li><a href="module-undo_recorder-UndoRecorder.html">undo_recorder~UndoRecorder</a></li><li><a href="module-undo-Undo.html">undo~Undo</a></li><li><a href="module-undo-UndoGroup.html">undo~UndoGroup</a></li><li><a href="module-undo-UndoList.html">undo~UndoList</a></li><li><a href="module-updater_domlistener-Listener.html">updater_domlistener~Listener</a></li><li><a href="module-validator-EventIndexException.html">validator~EventIndexException</a></li><li><a href="module-validator-Validator.html">validator~Validator</a></li><li><a href="module-wed-Editor.html">wed~Editor</a></li><li><a href="module-wundo-MarkerUndo.html">wundo~MarkerUndo</a></li><li><a href="module-wundo-TextUndoGroup.html">wundo~TextUndoGroup</a></li><li><a href="module-wundo-UndoGroup.html">wundo~UndoGroup</a></li></ul><h3>Events</h3><ul><li><a href="module-action-Action.html#event:disabled">action~Action#disabled</a></li><li><a href="module-action-Action.html#event:enabled">action~Action#enabled</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:change">gui_updater~GUIUpdater#change</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:deleteNode">gui_updater~GUIUpdater#deleteNode</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:insertNodeAt">gui_updater~GUIUpdater#insertNodeAt</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:setAttributeNS">gui_updater~GUIUpdater#setAttributeNS</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:setTextNodeValue">gui_updater~GUIUpdater#setTextNodeValue</a></li><li><a href="pubsub.html#event:WED">lib/pubsub#WED</a></li><li><a href="pubsub.html#event:WED_MODE">lib/pubsub#WED_MODE</a></li><li><a href="pubsub.html#event:WED_MODE_READY">lib/pubsub#WED_MODE_READY</a></li><li><a href="pubsub.html#event:WED_MODES_GENERIC_META_READY">lib/pubsub#WED_MODES_GENERIC_META_READY</a></li><li><a href="module-transformation-Transformation.html#event:disabled">transformation~Transformation#disabled</a></li><li><a href="module-transformation-Transformation.html#event:enabled">transformation~Transformation#enabled</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:change">tree_updater~TreeUpdater#change</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:deleteNode">tree_updater~TreeUpdater#deleteNode</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:insertNodeAt">tree_updater~TreeUpdater#insertNodeAt</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:setAttributeNS">tree_updater~TreeUpdater#setAttributeNS</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:setTextNodeValue">tree_updater~TreeUpdater#setTextNodeValue</a></li><li><a href="module-validator-Validator.html#event:error">validator~Validator#error</a></li><li><a href="module-validator-Validator.html#event:reset-errors">validator~Validator#reset-errors</a></li><li><a href="module-validator-Validator.html#event:state-update">validator~Validator#state-update</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Thu Sep 04 2014 14:04:36 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
