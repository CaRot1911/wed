<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: tree_updater.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/wed.css">
</head>

<body>


<div id="main">

    <h1 class="page-title">Source: tree_updater.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @module tree_updater
 * @desc Facility for updating a DOM tree and issue synchronous events
 * on changes.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright 2013 Mangalam Research Center for Buddhist Languages
 */

define(/** @lends module:tree_updater */ function (require, exports, module) {
'use strict';

var $ = require("jquery");
var domutil = require("./domutil");
var oop = require("./oop");
var SimpleEventEmitter =
        require("./lib/simple_event_emitter").SimpleEventEmitter;
var dloc = require("./dloc");
var DLoc = dloc.DLoc;
var makeDLoc = dloc.makeDLoc;

/**
 * @classdesc &lt;p>A TreeUpdater is meant to serve as the sole point of
 * modification for a DOM tree. As methods are invoked on the
 * TreeUpdater to modify the tree, events are issued synchronously,
 * which allows a listener to know what is happening on the tree.&lt;/p>
 *
 * &lt;p>Methods are divided into primitive and complex
 * methods. Primitive methods perform one and only one modification
 * and issue an event of the same name as their own name. Complex
 * methods use primitive methods to perform a series of modifications
 * on the tree. Or they delegate the actual modification work to the
 * primitive methods. They may emit one or more events of a name
 * different from their own name.&lt;/p>
 *
 * &lt;p>For primitive methods, the list of events which they are
 * documented to be firing is exhaustive. For complex methods, the
 * list is not exhaustive.&lt;/p>
 *
 * &lt;p>Many events have a name identical to a corresponding
 * method. Such events are accompanied by event objects which have the
 * same properties as the parameters of the corresponding method, with
 * the same meaning. Therefore, their parameters are not further
 * documented.&lt;/p>
 *
 * &lt;p>Events signaling the removal of data from the DOM tree are
 * issued &lt;strong>before&lt;/strong> their corresponding operation is
 * performed on the tree. Events signaling the addition of data to the
 * DOM tree are issued &lt;strong>after&lt;/strong> their corresponding
 * operation is performed on the tree.&lt;/p>
 * @mixes module:simple_event_emitter~SimpleEventEmitter
 *
 * @constructor
 * @param {Node} tree The node which contains the tree to update.
 *
 */
function TreeUpdater (tree) {
    // Call the constructor for our mixin
    SimpleEventEmitter.call(this);
    this._tree = tree;
}

oop.implement(TreeUpdater, SimpleEventEmitter);

/**
 * A complex method. This is a convenience method that will call
 * primitive methods to insert the specified item at the specified
 * location. Note that this method returns nothing even if the
 * primitives it uses return some information.
 *
 * @param {module:dloc~DLoc} loc The location where to insert.
 * @param what The data to insert. This can be a string, a DOM Node of
 * TEXT_NODE or ELEMENT_NODE type, or an array of these.
 * @throws {Error} If ``loc`` is not in an element or text node or if
 * ``what`` is not an element or text node.
 *
 * @also
 *
 * @param {Node} node The node where to insert.
 * @param {Integer} offset The offset at which to insert in
 * the node passed in the first parameter.
 * @param what The data to insert. This can be a string, a DOM Node of
 * TEXT_NODE or ELEMENT_NODE type, or an array of these.
 * @throws {Error} If ``node`` is not in an element or text node or if
 * ``what`` is not an element or text node.
 */
TreeUpdater.prototype.insertAt = function (loc, offset, what) {
    var parent, index;
    if (loc instanceof DLoc) {
        parent = loc.node;
        index = loc.offset;
        what = offset;
    }
    else {
        parent = loc;
        index = offset;
    }

    if (what instanceof Array || what instanceof NodeList) {
        for (var i = 0; i &lt; what.length; ++i, ++index)
            this.insertAt(parent, index, what[i]);
    }
    else if (typeof what === "string")
        this.insertText(parent, index, what);
    else if (what.nodeType === Node.TEXT_NODE) {
        switch(parent.nodeType) {
        case Node.TEXT_NODE:
            this.insertText(parent, index, what.nodeValue);
            break;
        case Node.ELEMENT_NODE:
            this.insertNodeAt(parent, index, what);
            break;
        default:
            throw new Error("unexpected node type: " + parent.nodeType);

        }
    }
    else if (what.nodeType === Node.ELEMENT_NODE) {
        switch(parent.nodeType) {
        case Node.TEXT_NODE:
            this.insertIntoText(parent, index, what);
            break;
        case Node.ELEMENT_NODE:
            this.insertNodeAt(parent, index, what);
            break;
        default:
            throw new Error("unexpected node type: " + parent.nodeType);

        }
    }
    else
        throw new Error("unexpected value for what: " + what);
};

/**
 * A complex method. Splits a DOM tree into two halves.
 *
 * @param {Node} top The node at which the splitting operation should
 * end. This node will be split but the function won't split anything
 * above this node.
 * @param {module:dloc~DLoc} loc The location where to start the
 * split.
 * @returns {Array.&lt;Node>} An array containing in order the first and
 * second half of the split.
 * @throws {Error} If the split location is not inside the top node or
 * if the call would merely split a text node in two.
 *
 * @also
 *
 * @param {Node} top The node at which the splitting operation should
 * end. This node will be split but the function won't split anything
 * above this node.
 * @param {Node} node The node at which to start the split.
 * @param {Number} index The index at which to start in the node.
 * @returns {Array.&lt;Node>} An array containing in order the first and
 * second half of the split.
 * @throws {Error} If the split location is not inside the top node or
 * if the call would merely split a text node in two.
 */
TreeUpdater.prototype.splitAt = function (top, loc, index) {
    var node;
    if (loc instanceof DLoc) {
        node = loc.node;
        index = loc.offset;
    }
    else
        node = loc;

    if (node === top && node.nodeType === Node.TEXT_NODE)
        throw new Error("splitAt called in a way that would result in " +
                        "two adjacent text nodes");

    if ($(node).closest(top).length === 0)
        throw new Error("split location is not inside top");

    var cloned_top = $(top).clone().get(0);
    var cloned_node = domutil.pathToNode(cloned_top,
                                         domutil.nodeToPath(top, node));
    var pair = this._splitAt(cloned_top, cloned_node, index);

    var parent = top.parentNode;
    var at = Array.prototype.indexOf.call(parent.childNodes, top);
    this.deleteNode(top);
    this.insertNodeAt(parent, at, pair[0]);
    this.insertNodeAt(parent, at + 1, pair[1]);
    return pair;
};

/**
 * Splits a DOM tree into two halves.
 * @private
 *
 * @param {Node} top The node at which the splitting operation should
 * end. This node will be split but the function won't split anything
 * above this node.
 * @param {Node} node The node at which to start.
 * @param {number} index The index at which to start in the node.
 * @returns {Array.&lt;Node>} An array containing in order the first and
 * second half of the split.
 */
TreeUpdater.prototype._splitAt = function (top, node, index) {
    // We need to check this now because some operations below may
    // remove node from the DOM tree.
    var stop = (node === top);

    var parent = node.parentNode;
    var ret;
    switch(node.nodeType) {
    case Node.TEXT_NODE:
        if (index === 0)
            ret = [null, node];
        else if (index === node.nodeValue.length)
            ret = [node, null];
        else {
            var text_after = node.nodeValue.slice(index);
            node.nodeValue = node.nodeValue.slice(0, index);
            if (parent)
                parent.insertBefore(parent.ownerDocument.createTextNode(
                    text_after),
                    node.nextSibling);
            ret = [node, node.nextSibling];
        }
        break;
    case Node.ELEMENT_NODE:
        if (index &lt; 0)
            index = 0;
        else if (index > node.childNodes.length)
            index = node.childNodes.length;

        var $node = $(node);
        var $clone = $node.clone();
        var clone = $clone.get(0);
        // Remove all nodes at index and after.
        while (node.childNodes[index])
            node.removeChild(node.childNodes[index]);

        // Remove all nodes before index
        while (index--)
            clone.removeChild(clone.childNodes[0]);

        if (parent)
            parent.insertBefore(clone, node.nextSibling);

        ret = [node, clone];
        break;
    default:
        throw new Error("unexpected node type: " + node.nodeType);
    }

    if (stop) // We've just split the top, so end here...
        return ret;

    return this._splitAt(
        top, parent, Array.prototype.indexOf.call(parent.childNodes, node) + 1);
};

/**
 * A complex method. Inserts the specified item before another
 * one. Note that the order of operands is the same as for the
 * &lt;code>insertBefore&lt;/code> DOM method.
 *
 * @param {Node} parent The node that contains the two other
 * parameters.
 * @param {Node} to_insert The node to insert.
 * @param {Node} before_this The node in front of which to insert. A
 * value of &lt;code>null&lt;/code> results in appending to the parent node.
 *
 * @throws {Error} If &lt;code>before_this&lt;/code> is not a child of &lt;code>
 * parent&lt;/code>.
 */
TreeUpdater.prototype.insertBefore = function (parent, to_insert,
                                               before_this) {
    // Convert it to an insertAt operation.
    var index = !before_this ? parent.childNodes.length :
            Array.prototype.indexOf.call(parent.childNodes, before_this);
    if (index === -1)
        throw new Error("insertBefore called with a before_this value "+
                        "which is not a child of parent");
    this.insertAt(parent, index, to_insert);
};

/**
 * A complex method. Inserts text into a node. This function will use
 * already existing text nodes whenever possible rather than create a
 * new text node.
 *
 * @method
 *
 * @param {module:dloc~DLoc} loc The location at which to insert the text.
 * @param {String} text The text to insert.
 * @returns {Array.&lt;Node>} The first element of the array is the node
 * that was modified to insert the text. It will be
 * &lt;code>undefined&lt;/code> if no node was modified. The second element
 * is the text node which contains the new text. The two elements are
 * defined and equal if a text node was modified to contain the newly
 * inserted text. They are unequal if a new text node had to be
 * created to contain the new text. A return value of
 * &lt;code>[undefined, undefined]&lt;/code> means that no modification
 * occurred (because the text passed was "").
 * @throws {Error} If &lt;code>node&lt;/code> is not an element or text Node type.
 *
 * @also
 *
 * @param {Node} node The node at which to insert the text.
 * @param {integer} index The location in the node at which to insert the text.
 * @param {string} text The text to insert.
 * @returns {Array.&lt;Node>} The first element of the array is the node
 * that was modified to insert the text. It will be
 * &lt;code>undefined&lt;/code> if no node was modified. The second element
 * is the text node which contains the new text. The two elements are
 * defined and equal if a text node was modified to contain the newly
 * inserted text. They are unequal if a new text node had to be
 * created to contain the new text. A return value of
 * &lt;code>[undefined, undefined]&lt;/code> means that no modification
 * occurred (because the text passed was "").
 * @throws {Error} If &lt;code>node&lt;/code> is not an element or text Node type.
 */
TreeUpdater.prototype.insertText = function (loc, index, text) {
    var node;
    if (loc instanceof DLoc) {
        text = index;
        node = loc.node;
        index = loc.offset;
    }
    else
        node = loc;

    return domutil.genericInsertText.call(this, node, index, text);
};

/**
 * A complex method. Deletes text from a text node. If the text node
 * becomes empty, it is deleted.
 *
 * @param {module:dloc~DLoc} loc Where to delete.
 * @param {Integer} length The length of text to delete.
 *
 * @throws {Error} If &lt;code>node&lt;/code> is not a text Node type.
 *
 * @also
 *
 * @param {Node} node The text node from which to delete text.
 * @param {integer} index The index at which to delete text.
 * @param {integer} length The length of text to delete.
 *
 * @throws {Error} If &lt;code>node&lt;/code> is not a text Node type.
 */
TreeUpdater.prototype.deleteText = function(loc, index, length) {
    var node;
    if (loc instanceof DLoc) {
        length = index;
        node = loc.node;
        index = loc.offset;
    }
    else
        node = loc;

    if (node.nodeType !== Node.TEXT_NODE)
        throw new Error("deleteText called on non-text");

    this.setTextNode(node, node.nodeValue.slice(0, index) +
                     node.nodeValue.slice(index + length));
};

/**
 * A complex method. Inserts an element into text, effectively
 * splitting the text node in two. This function takes care to modify
 * the DOM tree only once.
 *
 * @method
 *
 * @param {module:dloc~DLoc} loc The location at which to cut.
 * @param {Node} node The node to insert.
 * @returns {Array.&lt;module:dloc~DLoc>} The first element of the array
 * is a ``DLoc`` at the boundary between what comes before the
 * material inserted and the material inserted. The second element of
 * the array is a ``DLoc`` at the boundary between the material
 * inserted and what comes after. If I insert "foo" at position 2 in
 * "abcd", then the final result would be "abfoocd" and the first
 * location would be the boundary between "ab" and "foo" and the second
 * location the boundary between "foo" and "cd".
 * @throws {Error} If the node to insert is undefined or null.
 *
 * @also
 *
 * @param {Node} parent The text node that will be cut in two by the new
 * element.
 * @param {integer} index The offset into the text node where
 * the new element is to be inserted.
 * @param {Node} node The node to insert.
 * @returns {Array} See the previous signature for this method.
 * @throws {Error} If the node to insert is undefined or null.
 */
TreeUpdater.prototype.insertIntoText = function (loc, index, node) {
    var parent;
    if (loc instanceof DLoc) {
        node = index;
        index = loc.offset;
        parent = loc.node;
    }
    else
        parent = loc;
    var ret = domutil.genericInsertIntoText.call(this, parent, index, node);
    return [makeDLoc(this._tree, ret[0]), makeDLoc(this._tree, ret[1])];
};

/**
 * A primitive method. Inserts a node at the specified position.
 *
 * @param {module:dloc~DLoc} loc The location at which to insert.
 * @param {Node} node The node to insert.
 *
 * @emits module:tree_updater~TreeUpdater#insertNodeAt
 * @throws {Error} If &lt;code>node&lt;/code> is a document fragment Node type.
 *
 * @also
 *
 * @param {Node} parent The node which will become the parent of the
 * inserted node.
 * @param {integer} index The position at which to insert the node
 * into the parent.
 * @param {Node} node The node to insert.
 *
 * @emits module:tree_updater~TreeUpdater#insertNodeAt
 * @throws {Error} If &lt;code>node&lt;/code> is a document fragment Node type.
 */
TreeUpdater.prototype.insertNodeAt = function (loc, index, node) {
    var parent;
    if (loc instanceof DLoc) {
        node = index;
        index = loc.offset;
        parent = loc.node;
    }
    else
        parent = loc;

    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
        throw new Error("document fragments cannot be passed to insertNodeAt");

    parent.insertBefore(node, parent.childNodes[index]);
    /**
     * @event module:tree_updater~TreeUpdater#insertNodeAt
     * @type {Object}
     * @property {Node} parent
     * @property {integer} index
     * @property {Node} node
     */
    this._emit("insertNodeAt", {parent: parent, index: index,
                                node: node});
};

/**
 * A complex method. Sets a text node to a specified value.
 *
 * @param {Node} node The node to modify. Must be a text node.
 * @param {string} value The new value of the node.
 *
 * @throws {Error} If called on a non-text Node type.
 */
TreeUpdater.prototype.setTextNode = function (node, value) {
    if (node.nodeType !== Node.TEXT_NODE)
        throw new Error("setTextNode called on non-text");

    if (value !== "")
        this.setTextNodeValue(node, value);
    else
        this.deleteNode(node);
};

/**
 * A primitive method. Sets a text node to a specified value. This
 * method must not be called directly by code that perform changes of
 * the DOM tree at a high level, because it does not prevent a text
 * node from becoming empty. Call {@link
 * module:tree_updater~TreeUpdater#removeNode setTextNode}
 * instead. This method is meant to be used by other complex methods
 * of TreeUpdater and by some low-level facilities of wed.
 *
 * @param {Node} node The node to modify. Must be a text node.
 * @param {string} value The new value of the node.
 *
 * @emits module:tree_updater~TreeUpdater#setTextNodeValue
 * @throws {Error} If called on a non-text Node type.
 */
TreeUpdater.prototype.setTextNodeValue = function (node, value) {
    if (node.nodeType !== Node.TEXT_NODE)
        throw new Error("setTextNodeValue called on non-text");

    var old_value = node.nodeValue;
    node.nodeValue = value;
    /**
     * @event module:tree_updater~TreeUpdater#setTextNodeValue
     * @type {Object}
     * @property {Node} node
     * @property {string} value
     * @property {string} old_value The value before the change.
     */
    this._emit("setTextNodeValue", {
        node: node, value: value, old_value: old_value});
};


/**
 * A complex method. Removes a node from the DOM tree. If two text
 * nodes become adjacent, they are merged.
 *
 * @param {Node} node The node to remove
 * @returns {module:dloc~DLoc} A location between the two parts that
 * were merged, or between the two nodes that were not merged (because
 * they were not both text).
 */
TreeUpdater.prototype.removeNode = function (node) {
    var prev = node.previousSibling;
    var next = node.nextSibling;
    var parent = node.parentNode;
    var ix = Array.prototype.indexOf.call(parent.childNodes, node);
    this.deleteNode(node);
    if (!prev)
        return makeDLoc(this._tree, parent, ix);
    return this.mergeTextNodes(prev);
};

/**
 * A complex method. Removes a list of nodes from the DOM tree. If two
 * text nodes become adjacent, they are merged.
 *
 * @param {Array.&lt;Node>} nodes An array of nodes. These nodes must be
 * immediately contiguous siblings in document order.
 *
 * @returns {module:dloc~DLoc} The location between the two parts that
 * were merged, or between the two nodes that were not merged (because
 * they were not both text). Undefined if the list of nodes is empty.
 * @throws {Error} If nodes are not contiguous siblings.
 */
TreeUpdater.prototype.removeNodes = function (nodes) {
    if (!nodes.length)
        return undefined;
    var prev = nodes[0].previousSibling;
    var next = nodes[nodes.length - 1].nextSibling;
    var parent = nodes[0].parentNode;
    var ix = Array.prototype.indexOf.call(parent.childNodes, nodes[0]);
    for(var i = 0; i &lt; nodes.length; ++i) {
        if (i &lt; nodes.length - 1 && nodes[i].nextSibling !== nodes[i + 1])
            throw new Error("nodes are not immediately contiguous in " +
                            "document order");
        this.deleteNode(nodes[i]);
    }

    if (!prev)
        return makeDLoc(this._tree, parent, ix);
    return this.mergeTextNodes(prev);
};

/**
 * A complex method. Removes the contents between the start and end
 * carets from the DOM tree. If two text nodes become adjacent, they
 * are merged.
 * @function
 *
 * @param {module:dloc~DLoc} start Start position.
 * @param {module:dloc~DLoc} end Ending position.
 * @returns {Array} A pair of items. The first item is a ``DLoc``
 * object indicating the position where the cut happened. The second
 * item is a list of nodes, the cut contents.
 * @throws {Error} If Nodes in the range are not in the same element.
 */
TreeUpdater.prototype.cut = function (start, end) {
    var ret = domutil.genericCutFunction.call(this,
                                              start.toArray(), end.toArray());
    ret[0] = makeDLoc(this._tree, ret[0]);
    return ret;
};


/**
 * A complex method. If the node is a text node and followed by a text
 * node, this method will combine them.
 *
 * @param {Node} node The node to check.
 * @returns {module:dloc~DLoc} A position between the two parts
 * that were merged, or between the two nodes that were not merged
 * (because they were not both text).
 */
TreeUpdater.prototype.mergeTextNodes = function (node) {
    var next = node.nextSibling;
    if (node.nodeType === Node.TEXT_NODE &&
        next && next.nodeType === Node.TEXT_NODE) {
        var offset = node.nodeValue.length;
        this.setTextNodeValue(node, node.nodeValue + next.nodeValue);
        this.deleteNode(next);
        return makeDLoc(this._tree, node, offset);
    }

    var parent = node.parentNode;
    return makeDLoc(this._tree, parent,
                    Array.prototype.indexOf.call(parent.childNodes, node) + 1);
};

/**
 * A primitive method. Removes a node from the DOM tree. This method
 * must not be called directly by code that perform changes of the DOM
 * tree at a high level, because it does not prevent two text nodes
 * from being contiguous after deletion of the node. Call {@link
 * module:tree_updater~TreeUpdater#removeNode removeNode}
 * instead. This method is meant to be used by other complex methods
 * of TreeUpdater and by some low-level facilities of wed.
 *
 * @param {Node} node The node to remove
 *
 * @emits module:tree_updater~TreeUpdater#deleteNode
 */
TreeUpdater.prototype.deleteNode = function (node) {
    /**
     * @event module:tree_updater~TreeUpdater#deleteNode
     * @type {Object}
     * @property {Node} node
     */
    this._emit("deleteNode", {node: node});
    $(node).detach();
};

/**
 * Converts a node to a path.
 *
 * @param {Node} node The node for which to return a path.
 * @returns {string} The path of the node relative to the root of the
 * tree we are updating.
 */
TreeUpdater.prototype.nodeToPath = function (node) {
    return domutil.nodeToPath(this._tree, node);
};

/**
 * Converts a path to a node.
 *
 * @param {string} path The path to convert.
 * @returns {Node} The node corresponding to the path passed.
 */
TreeUpdater.prototype.pathToNode = function (path) {
    return domutil.pathToNode(this._tree, path);
};



exports.TreeUpdater = TreeUpdater;

});

//  LocalWords:  DOM Mangalam MPL Dubeau previousSibling nextSibling
//  LocalWords:  mergeTextNodes prev insertIntoText nodeToPath jQuery
//  LocalWords:  pathToNode SimpleEventEmitter deleteNode setTextNode
//  LocalWords:  cd abfoocd abcd insertNodeAt TreeUpdater param mixin
//  LocalWords:  setTextNodeValue removeNode deleteText insertBefore
//  LocalWords:  insertText insertAt splitAt oop domutil jquery
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-action.html">action</a></li><li><a href="module-decorator.html">decorator</a></li><li><a href="module-dloc.html">dloc</a></li><li><a href="module-domlistener.html">domlistener</a></li><li><a href="module-domutil.html">domutil</a></li><li><a href="module-exceptions.html">exceptions</a></li><li><a href="module-gui_updater.html">gui_updater</a></li><li><a href="module-input_trigger.html">input_trigger</a></li><li><a href="module-input_trigger_factory.html">input_trigger_factory</a></li><li><a href="module-jqutil.html">jqutil</a></li><li><a href="module-key.html">key</a></li><li><a href="module-key_constants.html">key_constants</a></li><li><a href="module-log.html">log</a></li><li><a href="module-mode.html">mode</a></li><li><a href="module-mutation_domlistener.html">mutation_domlistener</a></li><li><a href="module-object_check.html">object_check</a></li><li><a href="module-onbeforeunload.html">onbeforeunload</a></li><li><a href="module-onerror.html">onerror</a></li><li><a href="module-oop.html">oop</a></li><li><a href="module-refman.html">refman</a></li><li><a href="module-saver.html">saver</a></li><li><a href="module-transformation.html">transformation</a></li><li><a href="module-tree_updater.html">tree_updater</a></li><li><a href="module-undo.html">undo</a></li><li><a href="module-undo_recorder.html">undo_recorder</a></li><li><a href="module-updater_domlistener.html">updater_domlistener</a></li><li><a href="module-util.html">util</a></li><li><a href="module-validator.html">validator</a></li><li><a href="module-wed.html">wed</a></li><li><a href="module-wundo.html">wundo</a></li><li><a href="context_menu.html">gui/context_menu</a></li><li><a href="modal.html">gui/modal</a></li><li><a href="conditioned.html">lib/conditioned</a></li><li><a href="simple_event_emitter.html">lib/simple_event_emitter</a></li><li><a href="generic.html">modes/generic/generic</a></li><li><a href="generic_decorator.html">modes/generic/generic_decorator</a></li><li><a href="generic_meta.html">modes/generic/generic_meta</a></li><li><a href="generic_tr.html">modes/generic/generic_tr</a></li><li><a href="tei_meta.html">modes/generic/metas/tei_meta</a></li><li><a href="test_decorator.html">modes/test/test_decorator</a></li><li><a href="test_mode.html">modes/test/test_mode</a></li></ul><h3>Externals</h3><ul><li><a href="external-jQuery.html">jQuery</a></li></ul><h3>Classes</h3><ul><li><a href="module-action-Action.html">action~Action</a></li><li><a href="module-decorator-Decorator.html">decorator~Decorator</a></li><li><a href="module-dloc-DLoc.html">dloc~DLoc</a></li><li><a href="module-domlistener-Listener.html">domlistener~Listener</a></li><li><a href="module-exceptions-AbortTransformationException.html">exceptions~AbortTransformationException</a></li><li><a href="module-gui_updater-GUIUpdater.html">gui_updater~GUIUpdater</a></li><li><a href="module-input_trigger-InputTrigger.html">input_trigger~InputTrigger</a></li><li><a href="module-key-Key.html">key~Key</a></li><li><a href="module-log-Handled.html">log~Handled</a></li><li><a href="module-mode-Mode.html">mode~Mode</a></li><li><a href="module-mutation_domlistener-Listener.html">mutation_domlistener~Listener</a></li><li><a href="module-refman-ReferenceManager.html">refman~ReferenceManager</a></li><li><a href="module-refman-SenseReferenceManager.html">refman~SenseReferenceManager</a></li><li><a href="module-saver-Saver.html">saver~Saver</a></li><li><a href="module-transformation-Transformation.html">transformation~Transformation</a></li><li><a href="module-transformation-TransformationRegistry.html">transformation~TransformationRegistry</a></li><li><a href="module-tree_updater-TreeUpdater.html">tree_updater~TreeUpdater</a></li><li><a href="module-undo_recorder-UndoRecorder.html">undo_recorder~UndoRecorder</a></li><li><a href="module-undo-Undo.html">undo~Undo</a></li><li><a href="module-undo-UndoGroup.html">undo~UndoGroup</a></li><li><a href="module-undo-UndoList.html">undo~UndoList</a></li><li><a href="module-updater_domlistener-Listener.html">updater_domlistener~Listener</a></li><li><a href="module-validator-EventIndexException.html">validator~EventIndexException</a></li><li><a href="module-validator-Validator.html">validator~Validator</a></li><li><a href="module-wed-Editor.html">wed~Editor</a></li><li><a href="module-wundo-MarkerUndo.html">wundo~MarkerUndo</a></li><li><a href="module-wundo-TextUndoGroup.html">wundo~TextUndoGroup</a></li><li><a href="module-wundo-UndoGroup.html">wundo~UndoGroup</a></li><li><a href="context_menu-ContextMenu.html">gui/context_menu~ContextMenu</a></li><li><a href="modal-Modal.html">gui/modal~Modal</a></li><li><a href="conditioned-Conditioned.html">lib/conditioned~Conditioned</a></li><li><a href="simple_event_emitter-SimpleEventEmitter.html">lib/simple_event_emitter~SimpleEventEmitter</a></li><li><a href="generic_decorator-GenericDecorator.html">modes/generic/generic_decorator~GenericDecorator</a></li><li><a href="generic_meta-Meta.html">modes/generic/generic_meta~Meta</a></li><li><a href="generic_tr-Registry.html">modes/generic/generic_tr~Registry</a></li><li><a href="generic-Mode.html">modes/generic/generic~Mode</a></li><li><a href="tei_meta-TeiMeta.html">modes/generic/metas/tei_meta~TeiMeta</a></li><li><a href="test_decorator-TestDecorator.html">modes/test/test_decorator~TestDecorator</a></li><li><a href="test_mode-TestMode.html">modes/test/test_mode~TestMode</a></li></ul><h3>Events</h3><ul><li><a href="module-action-Action.html#event:disabled">action~Action#disabled</a></li><li><a href="module-action-Action.html#event:enabled">action~Action#enabled</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:deleteNode">gui_updater~GUIUpdater#deleteNode</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:insertNodeAt">gui_updater~GUIUpdater#insertNodeAt</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:setTextNodeValue">gui_updater~GUIUpdater#setTextNodeValue</a></li><li><a href="module-transformation-Transformation.html#event:disabled">transformation~Transformation#disabled</a></li><li><a href="module-transformation-Transformation.html#event:enabled">transformation~Transformation#enabled</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:deleteNode">tree_updater~TreeUpdater#deleteNode</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:insertNodeAt">tree_updater~TreeUpdater#insertNodeAt</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:setTextNodeValue">tree_updater~TreeUpdater#setTextNodeValue</a></li><li><a href="module-validator-Validator.html#event:error">validator~Validator#error</a></li><li><a href="module-validator-Validator.html#event:reset-errors">validator~Validator#reset-errors</a></li><li><a href="module-validator-Validator.html#event:state-update">validator~Validator#state-update</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Sat Nov 23 2013 16:19:56 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
