<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: transformation.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/mangalam.css">
</head>

<body>


<div id="main">

    <h1 class="page-title">Source: transformation.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module transformation
 * @desc Transformation framework.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages
 */

define(/** @lends module:transformation */function (require, exports, module) {
"use strict";

var util = require("./util");
var domutil = require("./domutil");
var Action = require("./action").Action;
var oop = require("./oop");
var icon = require("./gui/icon");
var _ = require("lodash");

var _indexOf = Array.prototype.indexOf;

var TYPE_TO_KIND = _.extend(Object.create(null), {
    // These are not actually type names. It is possible to use a kind
    // name as a type name if the transformation is not more
    // specific. In this case the kind === type.
    add: "add",
    "delete": "delete",
    transform: "transform",

    insert: "add",
    "delete-element": "delete",
    "delete-parent": "delete",
    wrap: "wrap",
    "merge-with-next": "transform",
    "merge-with-previous": "transform",
    "swap-with-next": "transform",
    "swap-with-previous": "transform",
    "split": "transform",
    append: "add",
    prepend: "add",
    unwrap: "unwrap",
    "add-attribute": "add",
    "delete-attribute": "delete"
});

var TYPE_TO_NODE_TYPE = _.extend(Object.create(null), {
    // These are not actually type names. These are here to handle the
    // case where the type is actually a kind name. Since they are not
    // more specific, the node type is set to "other". Note that
    // "wrap" and "unwrap" are always about elements so there is no
    // way to have a "wrap/unwrap" which has "other" for the node
    // type.
    add: "other",
    "delete": "other",
    transform: "other",

    insert: "element",
    "delete-element": "element",
    "delete-parent": "element",
    wrap: "element",
    "merge-with-next": "element",
    "merge-with-previous": "element",
    "swap-with-next": "element",
    "swap-with-previous": "element",
    "split": "element",
    append: "element",
    prepend: "element",
    unwrap: "element",
    "add-attribute": "attribute",
    "delete-attribute": "attribute"
});

/**
 * @classdesc An operation that transforms the data tree.
 * @extends module:action~Action
 *
 * @constructor
 *
 * @param {module:wed~Editor} editor The editor for which this
 * transformation must be created.
 * @param {string} type The type of transformation.
 * @param {string} desc The description of this transformation. A
 * transformation's {@link
 * module:transformation~Transformation#getDescriptionFor
 * getDescriptionFor} method will replace ``&lt;name>`` with the name
 * of the node actually being processed. So a string like ``Remove
 * &lt;name>`` would become ``Remove foo`` when the transformation is
 * called for the element ``foo``.
 * @param {string} [abbreviated_desc] An abbreviated description of this
 * transformation.
 * @param {string} [icon_html] An HTML representation of the icon
 * associated with this transformation.
 * @param {boolean} [needs_input=false] Indicates whether this action
 * needs input from the user. For instance, an action which brings up
 * a modal dialog to ask something of the user must have this
 * parameter set to ``true``. It is important to record whether an
 * action needs input because, to take one example, the ``autoinsert``
 * logic will try to insert automatically any element it can. However,
 * doing this for elements that need user input will just confuse the
 * user (or could cause a crash). Therefore, it is important that the
 * insertion operations for such elements be marked with
 * ``needs_input`` set to ``true`` so that the ``autoinsert`` logic
 * backs off from trying to insert these elements.
 * @param {module:transformation~Transformation~handler} handler
 * The handler to call when this
 * transformation is executed.
 */
function Transformation(editor, type, desc, abbreviated_desc, icon_html,
                        needs_input, handler) {
    switch(arguments.length) {
    case 4:
        handler = abbreviated_desc;
        abbreviated_desc = undefined;
        break;
    case 5:
        handler = icon_html;
        icon_html = undefined;
        break;
    case 6:
        handler = needs_input;
        needs_input = undefined;
        break;
    }
    this.handler = handler;
    this.type = type;
    this.kind = TYPE_TO_KIND[type];
    this.node_type = TYPE_TO_NODE_TYPE[type];

    if (icon_html === undefined && this.kind)
        icon_html = icon.makeHTML(this.kind);
    Action.call(this, editor, desc, abbreviated_desc, icon_html, needs_input);
}

/**
 * &lt;p>The transformation types expect the following values for the
 * parameters passed to a handler. For all these types
 * &lt;code>transformation_data&lt;/code> is unused.&lt;/p>
 *
 * Transformation Type | `node` is | `name` is the name of the:
 * ------------------|--------|---------------------------------
 * insert | undefined (we insert at caret position) | element to insert
 * delete-element | element to delete | element to delete
 * delete-parent | element to delete | element to delete
 * wrap | undefined (we wrap the current selection) | wrapping element
 * merge-with-next | element to merge | element to merge
 * merge-with-previous | element to merge | element to merge
 * swap-with-next | element to swap | element to swap
 * swap-with-previous | element to swap | element to swap
 * append | element after which to append | element after which to append
 * prepend | element before which to prepend | element before which to append
 * unwrap | node to unwrap | node to unwrap
 * add-attribute | node to which an attribute is added | attribute to add
 * delete-attribute | attribute to delete | attribute to delete
 * insert-text | node to which text is added | text to add
 *
 * @callback module:transformation~Transformation~handler
 *
 * @param {module:wed~Editor} editor The editor.
 * @param {Object} transformation_data Data for the
 * transformation. Some fields are reserved by wed, but
 * transformations are free to use additional fields. The following
 * fields are reserved *and* set by wed. **Do not set them yourself.**
 *
 * - ``e``: The JavaScript event that triggered the transformation, if
 *   any.
 *
 * The following fields are reserved but should be set by code which
 * invokes a transformation. See the table above to know what values
 * the built-in types of transformations known to wed expect.
 *
 * - ``node``: The node to operate on.
 *
 * - ``name``: The name of the node to add, remove, etc.  (Could be
 *   different from the name of the node that ``node`` refers to.)
 *
 * - ``move_caret_to``: A position to which the caret is moved before
 *   the transformation is fired. **Wed performs the move.**
 */

oop.inherit(Transformation, Action);

// Documented by method in parent class.
Transformation.prototype.getDescriptionFor = function (data) {
    return this._desc.replace(/&lt;name>/, data.name);
};

/**
 * Calls the &lt;code>fireTransformation&lt;/code> method on this
 * transformation's editor.
 *
 * @param {Object} data The data object to pass.
 */
Transformation.prototype.execute = function (data) {
    data = data || {};
    this._editor.fireTransformation(this, data);
};

/**
 * Insert an element in a wed data tree.
 *
 * @param {module:tree_updater~TreeUpdater} data_updater A tree
 * updater through which to update the DOM tree.
 * @param {Node} parent Parent of the new node.
 * @param {integer} index Offset in the parent where to insert the new node.
 * @param {string} ns The URI of the namespace to use for the new element.
 * @param {string} name Name of the new element.
 * @param {Object} [attrs] An object whose fields will become
 * attributes for the new element.
 *
 * @returns {Node} The new element.
 */
function insertElement(data_updater, parent, index, ns, name, attrs) {
    var el = makeElement(parent.ownerDocument, ns, name, attrs);
    data_updater.insertAt(parent, index, el);
    return el;
}

/**
 * Makes an element appropriate for a wed data tree.
 *
 * @param {string} doc The document for which to make the element.
 * @param {string} ns The URI of the namespace to use for the new element.
 * @param {string} name Name of the new element.
 * @param {Object} [attrs] An object whose fields will become
 * attributes for the new element.
 *
 * @returns {Node} The new element.
 */
function makeElement(doc, ns, name, attrs) {
    var e = doc.createElementNS(ns, name);
    if (attrs !== undefined)
    {
        // Create attributes
        var keys = Object.keys(attrs).sort();
        for(var keys_ix = 0, key; (key = keys[keys_ix++]) !== undefined; ) {
            e.setAttribute(key, attrs[key]);
        }
    }
    return e;
}

/**
 * Wraps a span of text in a new element.
 *
 * @param {module:tree_updater~TreeUpdater} data_updater A tree
 * updater through which to update the DOM tree.
 * @param {Node} node The DOM node where to wrap. Must be a text node.
 * @param {integer} offset Offset in the node. This parameter
 * specifies where to start wrapping.
 * @param {integer} end_offset Offset in the node. This parameter
 * specifies where to end wrapping.
 * @param {string} ns The URI of the namespace to use for the new element.
 * @param {string} name Name of the wrapping element.
 * @param {Object} [attrs] An object whose fields will become
 * attributes for the new element.
 *
 * @returns {Node} The new element.
 */
function wrapTextInElement (data_updater, node, offset, end_offset,
                            ns, name, attrs) {
    var text_to_wrap = node.data.slice(offset, end_offset);

    var parent = node.parentNode;
    var node_offset = _indexOf.call(parent.childNodes, node);

    data_updater.deleteText(node, offset, text_to_wrap.length);
    var new_element = makeElement(node.ownerDocument, ns, name, attrs);

    if (text_to_wrap !== "") {
        // It is okay to manipulate the DOM directly as long as the DOM
        // tree being manipulated is not *yet* inserted into the data
        // tree. That is the case here.
        new_element.appendChild(
            node.ownerDocument.createTextNode(text_to_wrap));
    }

    if (!node.parentNode)
        // The entire node was removed.
        data_updater.insertAt(parent, node_offset, new_element);
    else
        data_updater.insertAt(node, offset, new_element);

    return new_element;
}

/**
 * Utility function for {@link module:transformation~wrapInElement
 * wrapInElement}.
 *
 * @private
 * @param {module:tree_updater~TreeUpdater} data_updater A tree
 * updater through which to update the DOM tree.
 * @param {Node} container The text node to split.
 * @param {integer} offset Where to split the node
 *
 * @returns {Array} Returns a caret location marking where the split
 * occurred.
 */
function _wie_splitTextNode(data_updater, container, offset) {
    var parent = container.parentNode;
    var container_offset = _indexOf.call(parent.childNodes, container);
    // The first two cases here just move the start outside of the
    // text node rather than make a split that will create a
    // useless empty text node.
    if (offset === 0)
        offset = container_offset;
    else if (offset >= container.length)
        offset = container_offset + 1;
    else {
        var text = container.data.slice(offset);
        data_updater.setTextNode(container, container.data.slice(0, offset));
        data_updater.insertNodeAt(
            parent, container_offset + 1,
            container.ownerDocument.createTextNode(text));

        offset = container_offset + 1;
    }
    container = parent;
    return [container, offset];
}

/**
 * Wraps a well-formed span in a new element. This span can contain
 * text and element nodes.
 *
 * @param {module:tree_updater~TreeUpdater} data_updater A tree
 * updater through which to update the DOM tree.
 * @param {Node} start_container The node where to start wrapping.
 * @param {integer} start_offset The offset where to start wrapping.
 * @param {Node} end_container The node where to end wrapping.
 * @param {integer} end_offset The offset where to end wrapping.
 * @param {string} ns The URI of the namespace to use for the new element.
 * @param {string} name The name of the new element.
 * @param {Object} [attrs] An object whose fields will become
 * attributes for the new element.
 *
 * @returns {Node} The new element.
 * @throws {Error} If the range is malformed or if there is an
 * internal error.
 */
function wrapInElement (data_updater, start_container, start_offset,
                        end_container, end_offset, ns, name, attrs) {
    if (!domutil.isWellFormedRange({startContainer: start_container,
                                    startOffset: start_offset,
                                    endContainer: end_container,
                                    endOffset: end_offset}))
        throw new Error("malformed range");

    var pair; // damn hoisting
    if (start_container.nodeType === Node.TEXT_NODE) {
        // We already have an algorithm for this case.
        if (start_container === end_container)
            return wrapTextInElement(data_updater, start_container,
                                     start_offset, end_offset,
                                     ns, name, attrs);

        pair = _wie_splitTextNode(data_updater, start_container, start_offset);
        start_container = pair[0];
        start_offset = pair[1];
    }

    if (end_container.nodeType === Node.TEXT_NODE) {
        pair = _wie_splitTextNode(data_updater, end_container, end_offset);
        end_container = pair[0];
        end_offset = pair[1];
    }

    if (start_container !== end_container)
        throw new Error("start_container and end_container are not the same;" +
                        "probably due to an algorithmic mistake");

    var new_element = makeElement(start_container.ownerDocument, ns,
                                  name, attrs);
    while(--end_offset >= start_offset) {
        var end_node = end_container.childNodes[end_offset];
        data_updater.deleteNode(end_node);
        // Okay to change a tree which is not yet connected to the data tree.
        new_element.insertBefore(end_node, new_element.firstChild);
    }

    data_updater.insertAt(start_container, start_offset, new_element);

    return new_element;
}

/**
 * Replaces an element with its contents.
 *
 * @param {module:tree_updater~TreeUpdater} data_updater A tree
 * updater through which to update the DOM tree.
 * @param {Node} node The element to unwrap.
 *
 * @returns {Array.&lt;Node>} The contents of the element.
 */
function unwrap(data_updater, node) {
    var parent = node.parentNode;
    var children = Array.prototype.slice.call(node.childNodes);
    var prev = node.previousSibling;
    var next = node.nextSibling;
    // This does not merge text nodes, which is what we want. We also
    // want to remove it first so that we don't generate so many
    // update events.
    data_updater.deleteNode(node);

    // We want to calculate this index *after* removal.
    var next_ix = next ? _indexOf.call(parent.childNodes, next):
            parent.childNodes.length;

    var last_child = node.lastChild;

    // This also does not merge text nodes.
    while(node.firstChild)
        data_updater.insertNodeAt(parent, next_ix++, node.firstChild);

    // The order of the next two calls is important. We start at the
    // end because going the other way around could cause last_child
    // to leave the DOM tree.

    // Merge possible adjacent text nodes: the last child of the node
    // that was removed in the unwrapping and the node that was after
    // the node that was removed in the unwrapping.
    data_updater.mergeTextNodes(last_child);

    // Merge the possible adjacent text nodes: the one before the
    // start of the children we unwrapped and the first child that was
    // unwrapped. There may not be a prev so we use the NF form of the
    // call.
    data_updater.mergeTextNodesNF(prev);

    return children;
}

/**
 * This function splits a node at the position of the caret. If the
 * caret is not inside the node or its descendants, an exception is
 * raised.
 *
 * @param {module:wed~Editor} editor The editor on which we are to
 * perform the transformation.
 * @param {Node} node The node to split.
 * @throws {Error} If the caret is not inside the node or its descendants.
 */
function splitNode(editor, node) {
    var caret = editor.getDataCaret();

    if (!node.contains(caret.node))
        throw new Error("caret outside node");

    var pair = editor.data_updater.splitAt(node, caret);
    // Find the deepest location at the start of the 2nd
    // element.
    editor.setDataCaret(domutil.firstDescendantOrSelf(pair[1]), 0);
}

/**
 * This function merges an element with a previous element of the same
 * name. For the operation to go forward, the element must have a
 * previous sibling and this sibling must have the same name as the
 * element being merged.
 *
 * @param {module:wed~Editor} editor The editor on which we are to
 * perform the transformation.
 * @param {Node} node The element to merge with previous.
 */
function mergeWithPreviousHomogeneousSibling (editor, node) {
    var prev = node.previousElementSibling;
    if (!prev)
        return;

    if (prev.localName !== node.localName ||
        prev.namespace !== node.namespace)
        return;

    // We need to record these to set the caret to a good position.
    var caret_pos = prev.childNodes.length;
    var was_text = prev.lastChild.nodeType === Node.TEXT_NODE;
    var text_len = was_text ? prev.lastChild.length : 0;

    var insertion_point = prev.childNodes.length;
    // Reverse order
    for (var i = node.childNodes.length - 1; i >= 0; --i)
        editor.data_updater.insertAt(prev, insertion_point,
                                     node.childNodes[i].cloneNode(true));

    if (was_text)
        editor.setDataCaret(prev.childNodes[caret_pos - 1], text_len);
    else
        editor.setDataCaret(prev, caret_pos);
    editor.data_updater.removeNode(node);
}

/**
 * This function merges an element with a next element of the same
 * name. For the operation to go forward, the element must have a
 * next sibling and this sibling must have the same name as the
 * element being merged.
 *
 * @param {module:wed~Editor} editor The editor on which we are to
 * perform the transformation.
 * @param {Node} node The element to merge with next.
 */
function mergeWithNextHomogeneousSibling(editor, node) {
    var next = node.nextElementSibling;
    if (!next)
        return;

    mergeWithPreviousHomogeneousSibling(editor, next);
}

/**
 * This function swaps an element with a previous element of the same
 * name. For the operation to go forward, the element must have a
 * previous sibling and this sibling must have the same name as the
 * element being merged.
 *
 * @param {module:wed~Editor} editor The editor on which we are to
 * perform the transformation.
 * @param {Node} node The element to swap with previous.
 */
function swapWithPreviousHomogeneousSibling (editor, node) {
    var prev = node.previousElementSibling;
    if (!(prev && prev.classList.contains("_real")))
        return;

    var name = util.getOriginalName(node);
    if (!prev.classList.contains(name))
        return;

    var parent = prev.parentNode;
    editor.data_updater.removeNode(node);
    editor.data_updater.insertBefore(parent, node, prev);
    editor.setDataCaret(parent, _indexOf.call(parent.childNodes, node));
}

/**
 * This function swaps an element with a next element of the same
 * name. For the operation to go forward, the element must have a next
 * sibling and this sibling must have the same name as the element
 * being merged.
 *
 * @param {module:wed~Editor} editor The editor on which we are to
 * perform the transformation.
 * @param {Node} node The element to swap with next.
 */
function swapWithNextHomogeneousSibling(editor, node) {
    var next = node.nextElementSibling;
    if (!next)
        return;

    swapWithPreviousHomogeneousSibling(editor, next);
}

exports.Transformation = Transformation;
exports.wrapTextInElement = wrapTextInElement;
exports.wrapInElement = wrapInElement;
exports.insertElement = insertElement;
exports.makeElement = makeElement;
exports.unwrap = unwrap;
exports.splitNode = splitNode;
exports.mergeWithPreviousHomogeneousSibling =
        mergeWithPreviousHomogeneousSibling;
exports.mergeWithNextHomogeneousSibling =
        mergeWithNextHomogeneousSibling;
exports.swapWithPreviousHomogeneousSibling =
        swapWithPreviousHomogeneousSibling;
exports.swapWithNextHomogeneousSibling =
        swapWithNextHomogeneousSibling;
});

//  LocalWords:  concat prepend refman endOffset endContainer DOM oop
//  LocalWords:  startOffset startContainer html Mangalam MPL Dubeau
//  LocalWords:  previousSibling nextSibling insertNodeAt deleteNode
//  LocalWords:  mergeTextNodes lastChild prev deleteText Prepend lt
//  LocalWords:  domutil util
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-action.html">action</a></li><li><a href="module-browsers.html">browsers</a></li><li><a href="module-convert.html">convert</a></li><li><a href="module-decorator.html">decorator</a></li><li><a href="module-dloc.html">dloc</a></li><li><a href="module-domlistener.html">domlistener</a></li><li><a href="module-domutil.html">domutil</a></li><li><a href="module-exceptions.html">exceptions</a></li><li><a href="module-files.html">files</a></li><li><a href="action_context_menu.html">gui/action_context_menu</a></li><li><a href="completion_menu.html">gui/completion_menu</a></li><li><a href="context_menu.html">gui/context_menu</a></li><li><a href="icon.html">gui/icon</a></li><li><a href="modal.html">gui/modal</a></li><li><a href="tooltip.html">gui/tooltip</a></li><li><a href="module-gui_updater.html">gui_updater</a></li><li><a href="module-guiroot.html">guiroot</a></li><li><a href="module-input_trigger.html">input_trigger</a></li><li><a href="module-input_trigger_factory.html">input_trigger_factory</a></li><li><a href="module-key.html">key</a></li><li><a href="module-key_constants.html">key_constants</a></li><li><a href="module-kitchen-sink.html">kitchen-sink</a></li><li><a href="conditioned.html">lib/conditioned</a></li><li><a href="pubsub.html">lib/pubsub</a></li><li><a href="simple_event_emitter.html">lib/simple_event_emitter</a></li><li><a href="module-log.html">log</a></li><li><a href="module-mode.html">mode</a></li><li><a href="module-mode_validator.html">mode_validator</a></li><li><a href="generic.html">modes/generic/generic</a></li><li><a href="generic_decorator.html">modes/generic/generic_decorator</a></li><li><a href="generic_meta.html">modes/generic/generic_meta</a></li><li><a href="generic_tr.html">modes/generic/generic_tr</a></li><li><a href="tei_meta.html">modes/generic/metas/tei_meta</a></li><li><a href="test_decorator.html">modes/test/test_decorator</a></li><li><a href="test_mode.html">modes/test/test_mode</a></li><li><a href="test_mode_validator.html">modes/test/test_mode_validator</a></li><li><a href="module-mutation_domlistener.html">mutation_domlistener</a></li><li><a href="module-object_check.html">object_check</a></li><li><a href="module-onbeforeunload.html">onbeforeunload</a></li><li><a href="module-onerror.html">onerror</a></li><li><a href="module-oop.html">oop</a></li><li><a href="module-preferences.html">preferences</a></li><li><a href="module-refman.html">refman</a></li><li><a href="module-saver.html">saver</a></li><li><a href="ajax.html">savers/ajax</a></li><li><a href="localforage.html">savers/localforage</a></li><li><a href="module-serializer.html">serializer</a></li><li><a href="module-transformation.html">transformation</a></li><li><a href="module-tree_updater.html">tree_updater</a></li><li><a href="module-undo.html">undo</a></li><li><a href="module-undo_recorder.html">undo_recorder</a></li><li><a href="module-updater_domlistener.html">updater_domlistener</a></li><li><a href="module-util.html">util</a></li><li><a href="module-validator.html">validator</a></li><li><a href="module-wed.html">wed</a></li><li><a href="module-wundo.html">wundo</a></li></ul><h3>Externals</h3><ul><li><a href="external-jQuery.html">jQuery</a></li></ul><h3>Classes</h3><ul><li><a href="module-action-Action.html">action~Action</a></li><li><a href="module-decorator-Decorator.html">decorator~Decorator</a></li><li><a href="module-dloc-DLoc.html">dloc~DLoc</a></li><li><a href="module-domlistener-Listener.html">domlistener~Listener</a></li><li><a href="module-exceptions-AbortTransformationException.html">exceptions~AbortTransformationException</a></li><li><a href="action_context_menu-ContextMenu.html">gui/action_context_menu~ContextMenu</a></li><li><a href="completion_menu-CompletionMenu.html">gui/completion_menu~CompletionMenu</a></li><li><a href="context_menu-ContextMenu.html">gui/context_menu~ContextMenu</a></li><li><a href="modal-Modal.html">gui/modal~Modal</a></li><li><a href="module-gui_updater-GUIUpdater.html">gui_updater~GUIUpdater</a></li><li><a href="module-input_trigger-InputTrigger.html">input_trigger~InputTrigger</a></li><li><a href="module-key-Key.html">key~Key</a></li><li><a href="conditioned-Conditioned.html">lib/conditioned~Conditioned</a></li><li><a href="simple_event_emitter-SimpleEventEmitter.html">lib/simple_event_emitter~SimpleEventEmitter</a></li><li><a href="module-log-Handled.html">log~Handled</a></li><li><a href="generic_decorator-GenericDecorator.html">modes/generic/generic_decorator~GenericDecorator</a></li><li><a href="generic_meta-Meta.html">modes/generic/generic_meta~Meta</a></li><li><a href="generic-Mode.html">modes/generic/generic~Mode</a></li><li><a href="tei_meta-TeiMeta.html">modes/generic/metas/tei_meta~TeiMeta</a></li><li><a href="test_decorator-TestDecorator.html">modes/test/test_decorator~TestDecorator</a></li><li><a href="test_mode-TestMode.html">modes/test/test_mode~TestMode</a></li><li><a href="module-mode-Mode.html">mode~Mode</a></li><li><a href="module-mutation_domlistener-Listener.html">mutation_domlistener~Listener</a></li><li><a href="module-refman-ReferenceManager.html">refman~ReferenceManager</a></li><li><a href="module-refman-SenseReferenceManager.html">refman~SenseReferenceManager</a></li><li><a href="ajax-AjaxSaver.html">savers/ajax~AjaxSaver</a></li><li><a href="module-saver-Saver.html">saver~Saver</a></li><li><a href="module-transformation-Transformation.html">transformation~Transformation</a></li><li><a href="module-tree_updater-TreeUpdater.html">tree_updater~TreeUpdater</a></li><li><a href="module-undo_recorder-UndoRecorder.html">undo_recorder~UndoRecorder</a></li><li><a href="module-undo-Undo.html">undo~Undo</a></li><li><a href="module-undo-UndoGroup.html">undo~UndoGroup</a></li><li><a href="module-undo-UndoList.html">undo~UndoList</a></li><li><a href="module-updater_domlistener-Listener.html">updater_domlistener~Listener</a></li><li><a href="module-validator-EventIndexException.html">validator~EventIndexException</a></li><li><a href="module-validator-Validator.html">validator~Validator</a></li><li><a href="module-wed-Editor.html">wed~Editor</a></li><li><a href="module-wundo-MarkerUndo.html">wundo~MarkerUndo</a></li><li><a href="module-wundo-TextUndoGroup.html">wundo~TextUndoGroup</a></li><li><a href="module-wundo-UndoGroup.html">wundo~UndoGroup</a></li></ul><h3>Events</h3><ul><li><a href="module-action-Action.html#event:disabled">action~Action#disabled</a></li><li><a href="module-action-Action.html#event:enabled">action~Action#enabled</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:beforeDeleteNode">gui_updater~GUIUpdater#beforeDeleteNode</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:changed">gui_updater~GUIUpdater#changed</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:deleteNode">gui_updater~GUIUpdater#deleteNode</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:insertNodeAt">gui_updater~GUIUpdater#insertNodeAt</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:setAttributeNS">gui_updater~GUIUpdater#setAttributeNS</a></li><li><a href="module-gui_updater-GUIUpdater.html#event:setTextNodeValue">gui_updater~GUIUpdater#setTextNodeValue</a></li><li><a href="pubsub.html#event:WED">lib/pubsub#WED</a></li><li><a href="pubsub.html#event:WED_MODE">lib/pubsub#WED_MODE</a></li><li><a href="pubsub.html#event:WED_MODE_READY">lib/pubsub#WED_MODE_READY</a></li><li><a href="pubsub.html#event:WED_MODES_GENERIC_META_READY">lib/pubsub#WED_MODES_GENERIC_META_READY</a></li><li><a href="module-saver-Saver.html#event:autosaved">saver~Saver#autosaved</a></li><li><a href="module-saver-Saver.html#event:changed">saver~Saver#changed</a></li><li><a href="module-saver-Saver.html#event:failed">saver~Saver#failed</a></li><li><a href="module-saver-Saver.html#event:saved">saver~Saver#saved</a></li><li><a href="module-transformation-Transformation.html#event:disabled">transformation~Transformation#disabled</a></li><li><a href="module-transformation-Transformation.html#event:enabled">transformation~Transformation#enabled</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:beforeDeleteNode">tree_updater~TreeUpdater#beforeDeleteNode</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:changed">tree_updater~TreeUpdater#changed</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:deleteNode">tree_updater~TreeUpdater#deleteNode</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:insertNodeAt">tree_updater~TreeUpdater#insertNodeAt</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:setAttributeNS">tree_updater~TreeUpdater#setAttributeNS</a></li><li><a href="module-tree_updater-TreeUpdater.html#event:setTextNodeValue">tree_updater~TreeUpdater#setTextNodeValue</a></li><li><a href="module-validator-Validator.html#event:error">validator~Validator#error</a></li><li><a href="module-validator-Validator.html#event:reset-errors">validator~Validator#reset-errors</a></li><li><a href="module-validator-Validator.html#event:state-update">validator~Validator#state-update</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Mon Feb 16 2015 13:40:26 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
