{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salve-dom.min.js","webpack:///webpack/bootstrap 0b58d04b8e0b22da219f","webpack:///./build/dist/lib/main.js","webpack:///external \"salve\"","webpack:///./build/dist/lib/event_emitter.js","webpack:///./build/dist/lib/tools.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_indexOf","parent","needle","Array","indexOf","isAttr","it","attrNodeType","Node","ATTRIBUTE_NODE","Attr","undefined","nodeType","isPossibleDueToWildcard","walker","eventName","ns","evs","possible","toArray","matched","_i","evs_1","length","ev","params","namePattern","matches","match","wildcardMatch","safeParse","source","win","window","doc","parser","DOMParser","parseFromString","ex","code","ParsingError","child","firstChild","ELEMENT_NODE","nextSibling","chromeTest","querySelector","tagName","namespaceURI","MOZILLA_NAMESPACE","XML_NAMESPACE","documentElement","outerHTML","__extends","extendStatics","setPrototypeOf","__proto__","b","__","constructor","create","value","salve_1","event_emitter_1","tools_1","Stage","WorkingState","ProgressState","partDone","portion","ENTER_CONTEXT_EVENT","Event","LEAVE_START_TAG_EVENT","LEAVE_CONTEXT_EVENT","EventIndexException","_super","_this","fixPrototype","Error","Validator","schema","options","_cycleEntered","_timeout","_maxTimespan","_resetting","_errors","_errorsSeen","_boundWrapper","_workWrapper","bind","_validationEvents","_workingState","INCOMPLETE","_partDone","_validationStage","CONTENTS","_previousChild","_validationStack","_walkerCache","_walkerCacheMax","_prefix","_walkerCacheGap","_events","EventEmitter","keys","keys_1","key","prefix","_curEl","_setNodeProperty","_setWorkingState","_validationWalker","newWalker","events","makeKey","getNodeProperty","node","_clearNodeProperties","keys_2","start","_timeoutId","_stop","WORKING","setTimeout","getSchemaNamespaces","getNamespaces","getDocumentNamespaces","_process","attrIxLim","attributes","attrIx","attr","lastIndexOf","slice","array","ret","push","_work","startDate","Date","now","_cycle","stack","stage","this_1","stage_change","state_1","curEl","START_TAG","unshift","_fireAndProcessEvent","parent_1","parentNode","curElIndex","childNodes","ename","resolveName","_processEventResult","ValidationError","EName","_setPossibleDueToWildcard","_fireAttributeEvents","textAccumulatorNode_1","textAccumulator_1","flushText","event_1","join","eventResult","fireEvent","parent_2","TEXT_NODE","data","childElementCount","COMMENT_NODE","END_TAG","end","_runDocumentValidation","INVALID","VALID","originalElement","nextDone","shift","first","stop","state","clearTimeout","restartAt","resetTo","_resetTo","_erase","el","firstElementChild","nextElementSibling","_emit","at","newState","newDone","changed","getWorkingState","results","index","results_1","result","_processError","error","errorId","String","nodeGettingId","oldId","toString","_fireAttributeNameEvent","attrName","event","ix","_validateUpTo","container","toInspect","dataKey","ownerElement","previousElementSibling","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","prev","lastElementChild","_getWalkerAt","fireTextEvent","textNode","readyWalker","clone","getFrom","propName","prevSibling","previousSibling","eventIndex","cache","max","searchIx","Math","possibleAt","possibleWhere","has","_a","candidate","speculativelyValidate","toParse","ownerDocument","createDocumentFragment","toParse_1","insertBefore","cloneNode","createElement","speculativelyValidateFragment","dup","getErrorsFor","errorData","previous","resolveNameAt","attribute","unresolveNameAt","uri","unresolveName","xmlErrors","err","message","_eventListeners","_generalListeners","_trace","addEventListener","listener","listeners","addOneTimeEventListener","me","args","arguments","removeEventListener","apply","splice","removeAllListeners","console","log","listeners_1","listeners_2","obj","getPrototypeOf"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,UACA,kBAAAC,gBAAAC,IACAD,QAAA,SAAAJ,GACA,gBAAAC,SACAA,QAAA,aAAAD,EAAAG,QAAA,UAEAJ,EAAA,aAAAC,EAAAD,EAAA,QACCO,KAAA,SAAAC,GACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAZ,WAUA,OANAO,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,GAAA,EAGAX,EAAAD,QAvBA,GAAAU,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAhB,EAAAiB,EAAAC,GACAV,EAAAW,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAxB,GACA,GAAAiB,GAAAjB,KAAAyB,WACA,WAA2B,MAAAzB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAO,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,GAGAvB,IAAAwB,EAAA,KDgBM,SAAU/B,EAAQD,EAASQ,GAEjC,YE1DA,SAAAyB,GAAAC,EAAAC,GACA,MAAAC,OAAAP,UAAAQ,QAAAxB,KAAAqB,EAAAC,GAEA,QAAAG,GAAAC,GACA,GAAAC,GAAAC,KAAAC,cAMA,OAAAH,aAAAI,WACAC,KAAAJ,GAAAD,EAAAM,WAAAL,EAsFA,QAAAM,GAAAC,EAAAC,EAAAC,EAAAhC,GAGA,OAFAiC,GAAAH,EAAAI,WAAAC,UACAC,GAAA,EACAC,EAAA,EAAAC,EAAAL,EAAiCI,EAAAC,EAAAC,OAAmBF,IAAA,CACpD,GAAAG,GAAAF,EAAAD,EACA,IAAAG,EAAAC,OAAA,KAAAV,EAAA,CAGA,GAAAW,GAAAF,EAAAC,OAAA,GACAE,EAAAD,EAAAE,MAAAZ,EAAAhC,EAKA,IAHAoC,KAAAO,EAGAA,IAAAD,EAAAG,cAAAb,EAAAhC,GACA,UAMA,MAAAoC,GAixCA,QAAAU,GAAAC,EAAAC,OACA,KAAAA,IAAyBA,EAAAC,OACzB,IACAC,GADAC,EAAA,GAAAH,GAAAI,SAEA,KACAF,EAAAC,EAAAE,gBAAAN,EAAA,YAEA,MAAAO,GAEA,mBAAAA,EAAAtD,MAAA,KAAAsD,EAAAC,KACA,KAAAD,EAEA,UAAAE,GAAA,kCAGA,IADA,GAAAC,GAAAP,EAAAQ,WACA,OAAAD,KAAA7B,WAAAJ,KAAAmC,cACAF,IAAAG,WAEA,IAAAC,GAAAX,EAAAY,cAAA,wBAQA,IAEA,OAAAL,GACA,gBAAAA,EAAAM,SACAN,EAAAO,eAAAC,GAEA,OAAAJ,KAAAG,eAAAE,EACA,SAAAV,GAAAN,EAAAiB,gBAAAC,UAEA,OAAAlB,GA97CA,GAAAmB,GAAAjF,WAAAiF,WAAA,WACA,GAAAC,GAAAnE,OAAAoE,iBACUC,uBAAgBrD,QAAA,SAAApB,EAAA0E,GAAsC1E,EAAAyE,UAAAC,IAChE,SAAA1E,EAAA0E,GAAyB,OAAA3D,KAAA2D,KAAA5D,eAAAC,KAAAf,EAAAe,GAAA2D,EAAA3D,IACzB,iBAAAf,EAAA0E,GAEA,QAAAC,KAAuBtF,KAAAuF,YAAA5E,EADvBuE,EAAAvE,EAAA0E,GAEA1E,EAAAa,UAAA,OAAA6D,EAAAtE,OAAAyE,OAAAH,IAAAC,EAAA9D,UAAA6D,EAAA7D,UAAA,GAAA8D,OAGAvE,QAAAC,eAAArB,EAAA,cAA8C8F,OAAA;;;;;;AAO9C,GAAAC,GAAAvF,EAAA,GACAwF,EAAAxF,EAAA,GACAyF,EAAAzF,EAAA,EAcAR,GAAAsC,QAEA,IAAA4D,IACA,SAAAA,GACAA,IAAA,yBACAA,IAAA,uBACAA,IAAA,sBACCA,UAED,IAAAC,IACA,SAAAA,GAIAA,IAAA,2BAIAA,IAAA,qBAKAA,IAAA,qBAKAA,IAAA,kBACCA,EAAAnG,EAAAmG,eAAAnG,EAAAmG,iBAYD,IAAAC,GAAA,WACA,QAAAA,GAAAC,EAAAC,GACAjG,KAAAgG,WACAhG,KAAAiG,UAEA,MAAAF,MAmBAG,EAAA,GAAAR,GAAAS,MAAA,gBACAC,EAAA,GAAAV,GAAAS,MAAA,iBACAE,EAAA,GAAAX,GAAAS,MAAA,gBAMAG,EAAA,SAAAC,GAEA,QAAAD,KACA,GAAAE,GAAAD,EAAA/F,KAAAR,KAAA,wEAA6DA,IAE7D,OADA4F,GAAAa,aAAAD,EAAAF,GACAE,EAEA,MANAvB,GAAAqB,EAAAC,GAMAD,GACCI,OAiDDC,EAAA,WACA,QAAAA,GAAAC,EAAAnH,EAAAoH,OACA,KAAAA,IAAiCA,MACjC7G,KAAA4G,SACA5G,KAAAP,OACAO,KAAA8G,cAAA,EACA9G,KAAA+G,SAAA,IACA/G,KAAAgH,aAAA,IACAhH,KAAAiH,YAAA,EACAjH,KAAAkH,WACAlH,KAAAmH,YAAApG,OAAAyE,OAAA,MACAxF,KAAAoH,cAAApH,KAAAqH,aAAAC,KAAAtH,MAEAA,KAAAuH,qBACAvH,KAAAwH,cAAA1B,EAAA2B,WACAzH,KAAA0H,UAAA,EACA1H,KAAA2H,iBAAA9B,EAAA+B,SACA5H,KAAA6H,eAAA,KACA7H,KAAA8H,kBAAA,GAAA/B,GAAA,MACA/F,KAAA+H,aAAAhH,OAAAyE,OAAA,MACAxF,KAAAgI,iBAAA,EACAhI,KAAAiI,QAAA,WAGAjI,KAAAkI,gBAAA,IACAlI,KAAAmI,QAAA,GAAAxC,GAAAyC,YAGA,QAFAC,IAAA,wBACA,kBACApF,EAAA,EAAAqF,EAAAD,EAAuCpF,EAAAqF,EAAAnF,OAAoBF,IAAA,CAC3D,GAAAsF,GAAAD,EAAArF,GACAwC,EAAAoB,EAAA0B,EACA,QAAAhG,KAAAkD,EAAA,CAGA,GAAAA,EAAA,EACA,SAAAiB,OAAA,iBAAA6B,EAAA,sBAEAvI,MAAA,IAAAuI,GAAA1B,EAAA0B,QAEAhG,KAAAsE,EAAA2B,SACAxI,KAAAiI,QAAApB,EAAA2B,QAEAxI,KAAAyI,OAAAzI,KAAAP,KAGAO,KAAA0I,iBAAA1I,KAAAyI,OAAA,uBAAAzI,KAAAuH,kBAAApE,QACAnD,KAAA2I,iBAAA7C,EAAA2B,WAAA,GACAzH,KAAA4I,kBAAA5I,KAAA4G,OAAAiC,YACA7I,KAAA8I,OAAA9I,KAAAmI,QAypCA,MAvpCAxB,GAAAnF,UAAAuH,QAAA,SAAAR,GACA,SAAAvI,KAAAiI,QAAAM,GAMA5B,EAAAnF,UAAAwH,gBAAA,SAAAC,EAAAV,GACA,MAAAU,GAAAjJ,KAAA+I,QAAAR,KAMA5B,EAAAnF,UAAAkH,iBAAA,SAAAO,EAAAV,EAAA9C,GACAwD,EAAAjJ,KAAA+I,QAAAR,IAAA9C,GAEAkB,EAAAnF,UAAA0H,qBAAA,SAAAD,GASA,OARAZ,IACA,kBACA,uBACA,6BACA,4BACA,wBACA,WAEApF,EAAA,EAAAkG,EAAAd,EAAuCpF,EAAAkG,EAAAhG,OAAoBF,IAAA,CAC3D,GAAAsF,GAAAY,EAAAlG,SACAgG,GAAAjJ,KAAA+I,QAAAR,MAMA5B,EAAAnF,UAAA4H,MAAA,eACA7G,KAAAvC,KAAAqJ,YACArJ,KAAAsJ,MAAAxD,EAAAyD,SAQAvJ,KAAAqJ,WAAAG,WAAAxJ,KAAAoH,cAAA,IAOAT,EAAAnF,UAAAiI,oBAAA,WACA,MAAAzJ,MAAA4G,OAAA8C,iBAWA/C,EAAAnF,UAAAmI,sBAAA,WAEA,QAAAC,GAAAX,GACA,UAAAA,EAAA,CAIA,OADAY,GAAAZ,EAAAa,WAAA3G,OACA4G,EAAA,EAAgCA,EAAAF,IAAoBE,EAAA,CACpD,GAAAC,GAAAf,EAAAa,WAAAC,EACA,QAAAC,EAAApJ,KAAAqJ,YAAA,YACA,GAAA1B,GAAAyB,EAAApJ,KAAAsJ,MAAA,GACAC,EAAAC,EAAA7B,OACAhG,KAAA4H,IACAA,EAAAC,EAAA7B,OAEA4B,EAAAE,KAAAL,EAAAvE,QAIA,IADA,GAAApB,GAAA4E,EAAA3E,WACA,OAAAD,GACAA,EAAA7B,WAAAJ,KAAAmC,cACAqF,EAAAvF,GAEAA,IAAAG,aAtBA,GAAA4F,KA0BA,OADAR,GAAA5J,KAAAP,KAAA6E,YACA8F,GAOAzD,EAAAnF,UAAA6F,aAAA,WACArH,KAAAsK,UACAtK,KAAAqJ,WAAAG,WAAAxJ,KAAAoH,cAAApH,KAAA+G,YAUAJ,EAAAnF,UAAA8I,MAAA,WAEA,IADA,GAAAC,GAAAC,KAAAC,QACA,CAEA,GAAAzK,KAAAgH,aAAA,GACAwD,KAAAC,MAAAF,GAAAvK,KAAAgH,aACA,QAGA,KADAhH,KAAA0K,SAEA,WAaA/D,EAAAnF,UAAAkJ,OAAA,WACA,GAAAlE,GAAAxG,IAaA,IAVAA,KAAAiH,YAAA,EAUAjH,KAAA8G,cAAA,EACA,SAAAJ,OAAA,4CAEA,IAAA1G,KAAA8G,cAAA,EACA,SAAAJ,OAAA,yCAOA1G,MAAA8G,eACA,IAAApE,GAAA1C,KAAA4I,kBACA+B,EAAA3K,KAAA8H,iBACAgB,EAAA9I,KAAAuH,kBACAtB,EAAA0E,EAAA,GAAA1E,QACA2E,EAAA5K,KAAA2H,iBAwJAkD,EAAA7K,IACA8K,GAAA,QACA,GAAAC,GAzJA,WACA,GAAAC,GAAAH,EAAApC,MACA,QAAAmC,GACA,IAAA/E,GAAAoF,UAEAD,IACAL,EAAAO,QAAA,GAAAnF,GAAA8E,EAAAnD,UAAAzB,IAGA4E,EAAAM,qBAAAzI,EAAAwD,EAAA8E,EAAA,EAEA,QADAnB,GAAAmB,EAAAlB,WAAA3G,OACA4G,EAAA,EAAwCA,EAAAF,IAAoBE,EAAA,CAC5D,GAAAC,GAAAgB,EAAAlB,WAAAC,EACA,WAAAC,EAAApJ,KACAiK,EAAAM,qBAAAzI,EAAA,GAAAgD,GAAAS,MAAA,kBAAA6D,EAAAvE,OAAAuF,EAAA,GAEA,IAAAhB,EAAApJ,KAAAqJ,YAAA,aACAY,EAAAM,qBAAAzI,EAAA,GAAAgD,GAAAS,MAAA,eAAA6D,EAAApJ,KAAAsJ,MAAA,GAAAF,EAAAvE,OAAAuF,EAAA,GAGA,GAAArG,GAAAqG,EAAArG,QAEAyG,EAAAJ,EAAAK,WACAC,EAAA1J,EAAAwJ,EAAAG,WAAAP,GACAQ,EAAA9I,EAAA+I,YAAA9G,GAAA,EAoBA,YAnBApC,KAAAiJ,IACAX,EAAAa,qBAAA,GAAAhG,GAAAiG,gBAAA,2BAAAhH,IAAAyG,EAAAE,GAIAE,EAAA,GAAA9F,GAAAkG,MAAA,GAAAjH,IAIAkG,EAAAgB,0BAAAb,EAAAtI,EAAA,gBAAA8I,EAAA5I,GAAA4I,EAAA5K,MACAiK,EAAAM,qBAAAzI,EAAA,GAAAgD,GAAAS,MAAA,gBAAAqF,EAAA5I,GAAA4I,EAAA5K,MAAAwK,EAAAE,GACAT,EAAAnC,iBAAAsC,EAAA,6BAAAlC,EAAA3F,QACA0H,EAAAiB,qBAAApJ,EAAAsI,GACAH,EAAAnC,iBAAAsC,EAAA,4BAAAlC,EAAA3F,QAEA0H,EAAAM,qBAAAzI,EAAA0D,EAAA4E,EAAA,GACAJ,EAAAC,EAAAlD,iBAAA9B,EAAA+B,SACAiD,EAAAnC,iBAAAsC,EAAA,uBAAAlC,EAAA3F,QACA0H,EAAA/D,iBAC4BrB,OAAA,EAG5B,KAAAI,GAAA+B,SAyBA,IAxBA,GAMAmE,GANA9C,EAAA,OAAA4B,EAAAhD,eAEAmD,EAAA1G,WAEAuG,EAAAhD,eAAArD,YACAwH,KAEAC,EAAA,WACA,OAAAD,EAAA7I,OAAA,CACA,GAAA+I,GAAA,GAAAxG,GAAAS,MAAA,OAAA6F,EAAAG,KAAA,KACAC,EAAA1J,EAAA2J,UAAAH,EACA,IAAAE,YAAArK,OAAA,CACA,OAAAQ,KAAAwJ,EACA,SAAArF,OAAA,wCAIA,IAAA4F,GAAAP,EAAAV,UACA7E,GAAAkF,oBAAAU,EAAAE,EAAA1K,EAAA0K,EAAAf,WAAAQ,KAGAC,KACAD,MAAAxJ,IAEA,OAAA0G,GAAA,CACA,OAAAA,EAAAzG,UACA,IAAAJ,MAAAmK,UAKAP,EAAA3B,KAAApB,EAAAuD,UACAjK,KAAAwJ,IACAA,EAAA9C,EAEA,MACA,KAAA7G,MAAAmC,aAMA,MALA0H,KACAhG,GAAA+E,EAAAyB,kBACA5B,EAAApC,OAAAuC,EAAA/B,EACA2B,EAAAC,EAAAlD,iBAAA9B,EAAAoF,UACAJ,EAAAhD,eAAA,KACA,uBACA,KAAAzF,MAAAsK,aACA,KACA,SACA,SAAAhG,OAAA,yBAAAuC,EAAAzG,UAEAyG,IAAAzE,YAEAyH,IACArB,EAAAC,EAAAlD,iBAAA9B,EAAA8G,OACA,MAEA,KAAA9G,GAAA8G,QAEA,GAAA3B,IAAAH,EAAApL,KAAA,CACA,GAAA2M,GAAA1J,EAAAkK,KAUA,OATAR,aAAArK,QACA8I,EAAAa,oBAAAU,EAAApB,IAAAO,WAAApI,QAEA0H,EAAAgC,yBACAhC,EAAAnC,iBAAAsC,EAAA,kBAAAlC,EAAA3F,QACA0H,EAAAnD,UAAA,EACAmD,EAAAvB,MAAAuB,EAAA3D,QAAA/D,OAAA,EAAA2C,EAAAgH,QACAhH,EAAAiH,OACAlC,EAAA/D,iBACgCrB,OAAA,GAGhC,GAAAuH,GAAAhC,EACArG,EAAAqG,EAAArG,QACA6G,EAAA9I,EAAA+I,YAAA9G,GAAA,OACApC,KAAAiJ,IAGAA,EAAA,GAAA9F,GAAAkG,MAAA,GAAAjH,IAEAkG,EAAAM,qBAAAzI,EAAA,GAAAgD,GAAAS,MAAA,SAAAqF,EAAA5I,GAAA4I,EAAA5K,MAAAoK,IAAAO,WAAApI,QACA0H,EAAAM,qBAAAzI,EAAA2D,EAAA2E,IAAAO,WAAApI,QAEA0H,EAAAhD,eAAAmD,EAGAH,EAAApC,OAAAuC,IAAAK,UACA,IAAA4B,GAAApC,EAAAnD,SACA,IAAAsD,IAAAH,EAAApL,KAAA,CACAkL,EAAAuC,OACA,IAAAC,GAAAxC,EAAA,EACAsC,GAAAE,EAAAnH,UAAAC,EACAA,EAAAkH,EAAAlH,QAMA,MAJA4E,GAAAlC,iBAAA7C,EAAAyD,QAAA0D,GACApC,EAAAnC,iBAAAsE,EAAA,kBAAAnC,EAAAtD,kBAAApE,QACAyH,EAAAC,EAAAlD,iBAAA9B,EAAA+B,SACAiD,EAAA/D,iBAC4BrB,OAAA,EAG5B,SACA,SAAAiB,OAAA,uBAMA,oBAAAqE,GACA,MAAAA,GAAAtF,KACA,QAAAsF,GACA,oCAAAD,MAOAnE,EAAAnF,UAAA4L,KAAA,WACApN,KAAAsJ,SAeA3C,EAAAnF,UAAA8H,MAAA,SAAA+D,OACA9K,KAAAvC,KAAAqJ,YACAiE,aAAAtN,KAAAqJ,YAEArJ,KAAAqJ,eAAA9G,OACAA,KAAA8K,EAEArN,KAAAwH,gBAAA1B,EAAAyD,SACAvJ,KAAA2I,iBAAA7C,EAAA2B,WAAAzH,KAAA0H,WAIA1H,KAAA2I,iBAAA0E,EAAArN,KAAA0H,YAQAf,EAAAnF,UAAAqL,uBAAA,aAQAlG,EAAAnF,UAAA+L,UAAA,SAAAtE,GACAjJ,KAAAwN,QAAAvE,GACAjJ,KAAAoJ,SAOAzC,EAAAnF,UAAAgM,QAAA,SAAAvE,GAIAjJ,KAAAiH,aACAjH,KAAAiH,YAAA,EACAjH,KAAAyN,SAAAxE,KAGAtC,EAAAnF,UAAAkM,OAAA,SAAAC,GACA3N,KAAAkJ,qBAAAyE,EAEA,KADA,GAAAtJ,GAAAsJ,EAAAC,kBACA,OAAAvJ,GACArE,KAAA0N,OAAArJ,GACAA,IAAAwJ,oBAWAlH,EAAAnF,UAAAiM,SAAA,SAAAxE,GAQAjJ,KAAA0N,OAAA1N,KAAAP,MACAO,KAAA2H,iBAAA9B,EAAA+B,SACA5H,KAAA6H,eAAA,KACA7H,KAAA4I,kBAAA5I,KAAA4G,OAAAiC,YACA7I,KAAAuH,qBACAvH,KAAAyI,OAAAzI,KAAAP,KACAO,KAAA0H,UAAA,EACA1H,KAAAkH,WACAlH,KAAAmH,YAAApG,OAAAyE,OAAA,MACAxF,KAAA+H,aAAAhH,OAAAyE,OAAA,MACAxF,KAAAgI,iBAAA,EASAhI,KAAAmI,QAAA2F,MAAA,gBAA4CC,GAAA,KAY5CpH,EAAAnF,UAAAmH,iBAAA,SAAAqF,EAAAC,GACA,GAAAC,IAAA,CACAlO,MAAAwH,gBAAAwG,IACAhO,KAAAwH,cAAAwG,EACAE,GAAA,GAEAlO,KAAA0H,YAAAuG,IACAjO,KAAA0H,UAAAuG,EACAC,GAAA,GAEAA,GAMAlO,KAAAmI,QAAA2F,MAAA,gBAAgDT,MAAAW,EAAAhI,SAAAiI,KAQhDtH,EAAAnF,UAAA2M,gBAAA,WACA,OACAd,MAAArN,KAAAwH,cACAxB,SAAAhG,KAAA0H,YAGA3G,OAAAC,eAAA2F,EAAAnF,UAAA,UAIAL,IAAA,WACA,MAAAnB,MAAAkH,QAAAgD,SAEAhJ,YAAA,EACAD,cAAA,IAcA0F,EAAAnF,UAAAkK,oBAAA,SAAA0C,EAAAnF,EAAAoF,GACA,OAAApL,GAAA,EAAAqL,EAAAF,EAA6CnL,EAAAqL,EAAAnL,OAAuBF,IAAA,CACpE,GAAAsL,GAAAD,EAAArL,EACAjD,MAAAwO,eAAgCC,MAAAF,EAAAtF,OAAAoF,YAWhC1H,EAAAnF,UAAAgN,cAAA,SAAAC,GACA,GAAAjI,GAAAxG,KA+BAiJ,EAAAwF,EAAAxF,KACAyF,EAAA,MAAAzF,EAAA,GAAA0F,OAlBA,SAAAC,GACA,GAAAC,GAAArI,EAAAwC,gBAAA4F,EAAA,UAOA,YANArM,KAAAsM,IAGAA,EAAArI,EAAAU,QAAA/D,OACAqD,EAAAkC,iBAAAkG,EAAA,UAAAC,IAEAA,GAUA5F,IACAV,EAAAmG,EAAA,IAAAD,QAAAK,YAGA,IAFA9O,KAAAmH,YAAAoB,KAGAvI,KAAAmH,YAAAoB,IAAA,EACAvI,KAAAkH,QAAAmD,KAAAoE,GAUAzO,KAAAmI,QAAA2F,MAAA,QAAAW,KAMA9H,EAAAnF,UAAAsK,qBAAA,SAAApJ,EAAAiL,GAIA,OAFA7D,GAAA6D,EAAA7D,WAEAxJ,EAAA,EAAuBA,EAAAwJ,EAAA3G,SAAuB7C,EAAA,CAC9C,GAAA0J,GAAAF,EAAAxJ,EAEA,WAAA0J,EAAApJ,MACA,IAAAoJ,EAAApJ,KAAAqJ,YAAA,aAGAjK,KAAA+O,wBAAArM,EAAAiL,EAAA3D,IACAhK,KAAAmL,qBAAAzI,EAAA,GAAAgD,GAAAS,MAAA,iBAAA6D,EAAAvE,OAAAuE,EAAA,MAUArD,EAAAnF,UAAAuN,wBAAA,SAAArM,EAAAiL,EAAA3D,GACA,GAAAgF,GAAAhF,EAAApJ,KACA4K,EAAA9I,EAAA+I,YAAAuD,GAAA,EACA,YAAAzM,KAAAiJ,GACAxL,KAAAwO,eAAgCC,MAAA,GAAA/I,GAAAiG,gBAAA,iCAAAqD,GAAA/F,KAAAe,EAAAqE,MAAA,KAChC,IAEArO,KAAA6L,0BAAA7B,EAAAtH,EAAA,gBAAA8I,EAAA5I,GAAA4I,EAAA5K,MACAZ,KAAAmL,qBAAAzI,EAAA,GAAAgD,GAAAS,MAAA,gBAAAqF,EAAA5I,GAAA4I,EAAA5K,MAAAoJ,EAAA,IACA,IAgBArD,EAAAnF,UAAA2J,qBAAA,SAAAzI,EAAAuM,EAAAtB,EAAAuB,GACAlP,KAAAuH,kBAAA8C,KAAA4E,EACA,IAAA7C,GAAA1J,EAAA2J,UAAA4C,EACA7C,aAAArK,SACA,MAAA4L,OAAApL,KAAA2M,GAAA,gBAAAA,KACAA,EAAAtN,EAAA+L,EAAApC,WAAA2D,IAEAlP,KAAA0L,oBAAAU,EAAAuB,EAAAuB,KAgCAvI,EAAAnF,UAAA2N,cAAA,SAAAC,EAAAf,EAAAvE,GAGA,OAFA,KAAAA,IAAoCA,GAAA,IACpCA,aACAvH,KAAA6M,EAAA7D,YACA6D,EAAA7D,WAAA8C,GAAA7L,WACAJ,KAAAmC,cACA,SAAAmC,OAAA,iHAOA,IAAA2I,GAAAD,EACAE,EAAA,iBAKA,IAAAF,IAAApP,KAAAP,MAAA4O,GAAA,GACA,GAAAvE,EACAwF,EAAA,4BACAD,EAAAD,EAAA7D,WAAA8C,OAEA,QAAAA,EAEA,WAKA,IAAApM,EAAAmN,GACAC,EAAAD,EAAAG,aACAD,EAAA,iCAGA,QAAAF,EAAA5M,UACA,IAAAJ,MAAAmK,UACA8C,EAAAD,EAAAI,uBACA,OAAAH,IAEAA,EAAAD,EAAA/D,WACAiE,EAAA,uBAEA,MACA,KAAAlN,MAAAmC,aACA,IAAAnC,MAAAqN,uBACA,IAAArN,MAAAsN,cACA,GAAAzG,GAAAmG,EAAA7D,WAAA8C,GACAsB,MAAApN,KAAA0G,EACAmG,EAAAQ,iBAEA3G,EAAAuG,sBACA1F,IACAwF,EAAA,4BACAD,EAAApG,GAEA,OAAA0G,EACAN,EAAAM,EAGAL,EAAA,sBAEA,MACA,SACA,SAAA5I,OAAA,yBAAA0I,EAAA5M,UAIA,SAAAD,KAAAvC,KAAAgJ,gBAAAqG,EAAAC,IACAtP,KAAA0K,UA4BA/D,EAAAnF,UAAAqO,aAAA,SAAAT,EAAAf,EAAAvE,GA4BA,QAAAgG,GAAAC,GACA,OAAAxN,KAAAG,EACA,SAAAgE,OAAA,yCAEAhE,GAAA2J,UAAA,GAAA3G,GAAAS,MAAA,OAAA4J,EAAAvD,OA7BA,OAFA,KAAA1C,IAAoCA,GAAA,IACpCA,aACAvH,KAAA6M,EAAA7D,YACA6D,EAAA7D,WAAA8C,GAAA7L,WACAJ,KAAAmC,cACA,SAAAmC,OAAA,qFASA,IALA1G,KAAAmP,cAAAC,EAAAf,EAAAvE,GAKAsF,IAAApP,KAAAP,MAAA4O,GAAA,IACAvE,EAEA,WAAAuE,EACArO,KAAA4G,OAAAiC,YAKA7I,KAAA4I,iBAGA,IAAAlG,EAOA,IAAAT,EAAAmN,GAAA,CACA,GAAAzB,GAAAyB,EAAAG,YACA7M,GAAA1C,KAAAgQ,YAEAhQ,KAAAgJ,gBAAA2E,EAAA,+BAEA,UAAAyB,EAAAxO,MAAA,UAAAwO,EAAA5G,SACA9F,IAAAuN,QACAjQ,KAAA+O,wBAAArM,EAAAiL,EAAAyB,QAIA,QAAAA,EAAA5M,UACA,IAAAJ,MAAAmK,UACA,GAAAoD,GAAAP,EAAAI,uBACAU,MAAA,GACAC,MAAA,EACA,QAAAR,GACAO,EAAAP,EACAQ,EAAA,oBAIAD,EAAAd,EAAA/D,WACA8E,EAAA,wBAGAzN,EAAA1C,KAAAgQ,YAAAhQ,KAAAgJ,gBAAAkH,EAAAC,IASA9B,EAAA,IACA3L,IAAAuN,QACAH,EAAAV,GAEA,MAEA,KAAAhN,MAAAmC,aACA,IAAAnC,MAAAsN,cACA,IAAAtN,MAAAqN,uBACA,GAAAxG,GAAAmG,EAAA7D,WAAA8C,GACAsB,MAAA,GACAO,MAAA,GACAC,MAAA,EAmBA,IAlBArG,GAaAoG,EAAAjH,EACAkH,EAAA,8BAbAR,MAAApN,KAAA0G,EAAAmG,EAAAQ,iBACA3G,EAAAuG,uBACA,OAAAG,GACAO,EAAAP,EACAQ,EAAA,oBAGAD,EAAAd,EACAe,EAAA,yBAQAzN,EAAA1C,KAAAgQ,YAAAhQ,KAAAgJ,gBAAAkH,EAAAC,KACArG,EAAA,CAGA,GAAAsG,GAAA,MAAAnH,IAAAoH,gBAAA,IACA,QAAAD,GAIAA,IAAAT,GACAS,EAAA5N,WAAAJ,KAAAmK,YACA7J,IAAAuN,QACAH,EAAAM,IAIA,KAEA,SACA,SAAA1J,OAAA,yBAAA0I,EAAA5M,UAGA,MAAAE,IAEAiE,EAAAnF,UAAAwO,YAAA,SAAAM,GASA,OAAA/N,KAAA+N,EACA,SAAAhK,EAEA,IAAAiK,GAAAvQ,KAAA+H,aACAyI,EAAAxQ,KAAAgI,gBACAtF,EAAA6N,EAAAD,EACA,QAAA/N,KAAAG,EACA,MAAAA,EAsBA,IAAA+N,GAAAH,CACA,IAAAG,GAAAD,EACAC,EAAAD,EACA9N,EAAA6N,EAAAE,OAGA,UAAAlO,KAAAG,KAAA+N,GAAA,GACA/N,EAAA6N,EAAAE,OAGAlO,KAAAG,EACAA,IAAAuN,SAGAvN,EAAA1C,KAAA4G,OAAAiC,YACA4H,EAAA,EAEA,QAAAvB,GAAAuB,EAA+BvB,EAAAoB,IAAiBpB,EAChDxM,EAAA2J,UAAArM,KAAAuH,kBAAA2H,GAQA,OAJAoB,GAAAG,GAAAzQ,KAAAkI,kBACAqI,EAAAD,GAAA5N,EACA1C,KAAAgI,gBAAA0I,KAAAF,IAAAF,EAAAE,IAEA9N,GAgBAiE,EAAAnF,UAAAmP,WAAA,SAAAvB,EAAAf,EAAAvE,GAIA,WAHA,KAAAA,IAAoCA,GAAA,GACpC9J,KAAA6P,aAAAT,EAAAf,EAAAvE,GAEAhH,YAaA6D,EAAAnF,UAAAoP,cAAA,SAAAxB,EAAAH,GAEA,OADA7E,MACAiE,EAAA,EAA2BA,GAAAe,EAAA7D,WAAApI,SAAsCkL,EAAA,CACjE,GAAAvL,GAAA9C,KAAA2Q,WAAAvB,EAAAf,EACA,IAAAvL,EAAA+N,IAAA5B,GACA7E,EAAAC,KAAAgE,OAEA,sBAAAY,EAAA5L,OAAA,IACA,kBAAA4L,EAAA5L,OAAA,GAOA,OAAAJ,GAAA,EAAA6N,EAAAhO,EAAAC,UAAyDE,EAAA6N,EAAA3N,OAAgBF,IAAA,CACzE,GAAA8N,GAAAD,EAAA7N,EACA,IAAA8N,EAAA1N,OAAA,KAAA4L,EAAA5L,OAAA,IACA0N,EAAA1N,OAAA,GAAAG,MAAAyL,EAAA5L,OAAA,GAAA4L,EAAA5L,OAAA,KACA+G,EAAAC,KAAAgE,EACA,SAKA,MAAAjE,IAmBAzD,EAAAnF,UAAAwP,sBAAA,SAAA5B,EAAAf,EAAA4C,GACA,GAAAhB,EACA,IAAAgB,YAAAlP,OAAA,CACAkO,EAAAb,EAAA8B,cAAAC,wBACA,QAAAlO,GAAA,EAAAmO,EAAAH,EAAiDhO,EAAAmO,EAAAjO,OAAuBF,IAAA,CACxE,GAAAoB,GAAA+M,EAAAnO,EACAgN,GAAAoB,aAAAhN,EAAAiN,WAAA,cAIArB,GAAAgB,EAAAK,WAAA,EAEA,IAAA7R,GAAA2P,EAAA8B,cAAAK,cAAA,MAEA,OADA9R,GAAA4R,aAAApB,EAAA,MACAjQ,KAAAwR,8BAAApC,EAAAf,EAAA5O,IAmBAkH,EAAAnF,UAAAgQ,8BAAA,SAAApC,EAAAf,EAAA4C,GAEA,GAAAA,EAAAzO,WAAAJ,KAAAmC,aACA,SAAAmC,OAAA,4BAIA,IAAA+K,GAAA,GAAA9K,GAAA3G,KAAA4G,OAAAqK,EAKA,OAHAQ,GAAA7I,kBAAA5I,KAAA6P,aAAAT,EAAAf,GAAA4B,QAEAwB,EAAAtC,cAAA8B,IAAA1F,WAAApI,QACA,IAAAsO,EAAAvK,QAAA/D,QACAsO,EAAAvK,SAsBAP,EAAAnF,UAAAkQ,aAAA,SAAAzI,GACA,GAAApH,GAAAoH,EAAAoC,UACA,WAAAxJ,EACA,SAAA6E,OAAA,yBAGA1G,MAAAmP,cAAAtN,EAAAD,EAAAC,EAAA0J,WAAAtC,GAAA,EAEA,QADAmB,MACAnH,EAAA,EAAA6N,EAAA9Q,KAAAkH,QAA2CjE,EAAA6N,EAAA3N,OAAgBF,IAAA,CAC3D,GAAA0O,GAAAb,EAAA7N,EACA0O,GAAA1I,UACAmB,EAAAC,KAAAsH,GAGA,MAAAvH,IAwBAzD,EAAAnF,UAAAqK,0BAAA,SAAA5C,EAAAvG,EAAAC,EAAAC,EAAAhC,GACA,GAAAgR,GAAA5R,KAAAgJ,gBAAAC,EAAA,yBACAnG,EAAAL,EAAAC,EAAAC,EAAAC,EAAAhC,EACAZ,MAAA0I,iBAAAO,EAAA,wBAAAnG,OACAP,KAAAqP,OAAA9O,GASA9C,KAAAmI,QAAA2F,MAAA,kCAAA7E,IAkBAtC,EAAAnF,UAAAqQ,cAAA,SAAAzC,EAAAf,EAAAzN,EAAAkR,GAIA,WAHA,KAAAA,IAAmCA,GAAA,GAGnC9R,KAAA6P,aAAAT,EAAAf,GAAA5C,YAAA7K,EAAAkR,IAiBAnL,EAAAnF,UAAAuQ,gBAAA,SAAA3C,EAAAf,EAAA2D,EAAApR,GACA,MAAAZ,MAAA6P,aAAAT,EAAAf,GAAA4D,cAAAD,EAAApR,IAEA+F,IAEAhH,GAAAgH,WAIA,IAAAvC,GAAA,SAAAmC,GAMA,QAAAnC,GAAA8N,GACA,GAAA1L,GAAAD,EAAA/F,KAAAR,WACAwG,GAAA0L,WACA,IAAAC,GAAA,GAAAzL,OAAA,eAKA,OAJAF,GAAA5F,KAAA,eACA4F,EAAAmE,MAAAwH,EAAAxH,MACAnE,EAAA4L,QAAAD,EAAAC,QACAxM,EAAAa,aAAAD,EAAApC,GACAoC,EAEA,MAfAvB,GAAAb,EAAAmC,GAeAnC,GACCsC,MACD/G,GAAAyE,cAEA,IAAAU,GAAA,+BACAD,EAEA,sDAuDAlF,GAAA+D,aFqFM,SAAU9D,EAAQD,GGthDxBC,EAAAD,QAAAM,GH4hDM,SAAUL,EAAQD,EAASQ,GAEjC;;;;;;AIvhDAY,OAAAC,eAAArB,EAAA,cAA8C8F,OAAA,GAwB9C,IAAA2C,GAAA,WACA,QAAAA,KACApI,KAAAqS,gBAAAtR,OAAAyE,OAAA,MACAxF,KAAAsS,qBACAtS,KAAAuS,QAAA,EA8FA,MA5FAnK,GAAA5G,UAAAgR,iBAAA,SAAA7P,EAAA8P,GACA,SAAA9P,EACA3C,KAAAsS,kBAAAjI,KAAAoI,OAEA,CACA,GAAAC,GAAA1S,KAAAqS,gBAAA1P,OACAJ,KAAAmQ,IACAA,EAAA1S,KAAAqS,gBAAA1P,OAEA+P,EAAArI,KAAAoI,KAGArK,EAAA5G,UAAAmR,wBAAA,SAAAhQ,EAAA8P,GACA,GAAAjM,GAAAxG,KAGA4S,EAAA,WAEA,OADAC,MACA5P,EAAA,EAA4BA,EAAA6P,UAAA3P,OAAuBF,IACnD4P,EAAA5P,GAAA6P,UAAA7P,EAGA,OADAuD,GAAAuM,oBAAApQ,EAAAiQ,GACAH,EAAAO,MAAAxM,EAAAqM,GAGA,OADA7S,MAAAwS,iBAAA7P,EAAAiQ,GACAA,GAEAxK,EAAA5G,UAAAuR,oBAAA,SAAApQ,EAAA8P,GACA,GAAAC,GAAA,MAAA/P,EACA3C,KAAAsS,kBACAtS,KAAAqS,gBAAA1P,EACA,QAAAJ,KAAAmQ,EAAA,CAGA,GAAArE,GAAAqE,EAAAzI,YAAAwI,IACA,IAAApE,GACAqE,EAAAO,OAAA5E,EAAA,KAGAjG,EAAA5G,UAAA0R,mBAAA,SAAAvQ,GACA,MAAAA,EACA3C,KAAAsS,qBAGAtS,KAAAqS,gBAAA1P,OAYAyF,EAAA5G,UAAAsM,MAAA,SAAAnL,EAAAS,GACApD,KAAAuS,QAEAY,QAAAC,IAAA,iCAAAzQ,EAAA,QAAAS,EAGA,IAAAsP,GAAA1S,KAAAsS,iBACA,IAAAI,EAAAvP,OAAA,GAGAuP,IAAAxI,OACA,QAAAjH,GAAA,EAAAoQ,EAAAX,EAAyDzP,EAAAoQ,EAAAlQ,OAAyBF,IAAA,CAClF,GAAAwP,GAAAY,EAAApQ,GACAmH,EAAAqI,EAAAjS,SAAA+B,GAAAI,EAAAS,EACA,SAAAgH,EACA,QAMA,GAAAsI,GAAA1S,KAAAqS,gBAAA1P,EACA,QAAAJ,KAAAmQ,KAAAvP,OAAA,GAGAuP,IAAAxI,OACA,QAAA4G,GAAA,EAAAwC,EAAAZ,EAAyD5B,EAAAwC,EAAAnQ,OAAyB2N,IAAA,CAClF,GAAA2B,GAAAa,EAAAxC,GACA1G,EAAAqI,EAAAjS,SAAA+B,GAAAa,EACA,SAAAgH,EACA,UAMAhC,IAEAzI,GAAAyI,gBJqiDM,SAAUxI,EAAQD,EAASQ,GAEjC,YK/pDA,SAAAsG,GAAA8M,EAAA1R,QACAU,KAAAxB,OAAAyS,eACAzS,OAAAyS,eAAAD,GACAA,EAAAnO,aACAvD,QACAU,KAAAxB,OAAAoE,eACApE,OAAAoE,eAAAoO,EAAA1R,EAAAL,WAGA+R,EAAAnO,UAAAvD,EAAAL,WAnBAT,OAAAC,eAAArB,EAAA,cAA8C8F,OAAA,IAuB9C9F,EAAA8G","file":"salve-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"salve\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"salve\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salve-dom\"] = factory(require(\"salve\"));\n\telse\n\t\troot[\"salve-dom\"] = factory(root[\"salve\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"salve\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"salve\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salve-dom\"] = factory(require(\"salve\"));\n\telse\n\t\troot[\"salve-dom\"] = factory(root[\"salve\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar salve_1 = __webpack_require__(1);\nvar event_emitter_1 = __webpack_require__(2);\nvar tools_1 = __webpack_require__(3);\nfunction _indexOf(parent, needle) {\n    return Array.prototype.indexOf.call(parent, needle);\n}\nfunction isAttr(it) {\n    var attrNodeType = Node.ATTRIBUTE_NODE;\n    // We check that ``attr_node_type`` is not undefined because eventually\n    // ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n    // could be testing ``undefined === undefined`` for objects which are not\n    // attributes, which would return ``true``. The function is not very strict\n    // but it should not be too lax either.\n    return it instanceof Attr ||\n        ((attrNodeType !== undefined) && (it.nodeType === attrNodeType));\n}\nexports.isAttr = isAttr;\n// validation_stage values\nvar Stage;\n(function (Stage) {\n    Stage[Stage[\"START_TAG\"] = 1] = \"START_TAG\";\n    Stage[Stage[\"CONTENTS\"] = 2] = \"CONTENTS\";\n    Stage[Stage[\"END_TAG\"] = 3] = \"END_TAG\";\n})(Stage || (Stage = {}));\n// Working state values\nvar WorkingState;\n(function (WorkingState) {\n    /**\n     * The validator is stopped but has not completed a validation pass yet.\n     */\n    WorkingState[WorkingState[\"INCOMPLETE\"] = 1] = \"INCOMPLETE\";\n    /**\n     * The validator is working on validating the document.\n     */\n    WorkingState[WorkingState[\"WORKING\"] = 2] = \"WORKING\";\n    /**\n     * The validator is stopped and has found the document invalid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"INVALID\"] = 3] = \"INVALID\";\n    /**\n     * The validator is stopped and has found the document valid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"VALID\"] = 4] = \"VALID\";\n})(WorkingState = exports.WorkingState || (exports.WorkingState = {}));\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nvar ProgressState = /** @class */ (function () {\n    function ProgressState(partDone, portion) {\n        this.partDone = partDone;\n        this.portion = portion;\n    }\n    return ProgressState;\n}());\n//\n// Note: the Validator class adds information to the Element nodes it is working\n// with by adding expando properties that start with \"wed_event_\". This deemed\n// acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to be open to\n//   third party software. Even if it were, the chance of a clash is small.\n//\n// * The values of the expando properties are primitives (not objects or other\n//   elements).\n//\n// * We don't care about browsers or situations where expando properties are not\n//   supported.\n//\n//\n// These are constants. So create them once rather than over and over again.\n//\nvar ENTER_CONTEXT_EVENT = new salve_1.Event(\"enterContext\");\nvar LEAVE_START_TAG_EVENT = new salve_1.Event(\"leaveStartTag\");\nvar LEAVE_CONTEXT_EVENT = new salve_1.Event(\"leaveContext\");\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nvar EventIndexException = /** @class */ (function (_super) {\n    __extends(EventIndexException, _super);\n    function EventIndexException() {\n        var _this = _super.call(this, \"undefined event_index; _validateUpTo should have taken care of that\") || this;\n        tools_1.fixPrototype(_this, EventIndexException);\n        return _this;\n    }\n    return EventIndexException;\n}(Error));\n// This private utility function checks whether an event is possible only\n// because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker, eventName, ns, name) {\n    var evs = walker.possible().toArray();\n    var matched = false;\n    for (var _i = 0, evs_1 = evs; _i < evs_1.length; _i++) {\n        var ev = evs_1[_i];\n        if (ev.params[0] !== eventName) {\n            continue;\n        }\n        var namePattern = ev.params[1];\n        var matches = namePattern.match(ns, name);\n        // Keep track of whether it ever matched anything.\n        matched = matched || matches;\n        // We already know that it matches, and this is not merely due to a\n        // wildcard.\n        if (matches && !namePattern.wildcardMatch(ns, name)) {\n            return false;\n        }\n    }\n    // If it never matched any pattern at all, then we must return false.  If we\n    // get here and matched is true then it means that it matched all patterns due\n    // to wildcards.\n    return matched;\n}\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``'s ``constructTree``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nvar Validator = /** @class */ (function () {\n    function Validator(schema, root, options) {\n        if (options === void 0) { options = {}; }\n        this.schema = schema;\n        this.root = root;\n        this._cycleEntered = 0;\n        this._timeout = 200;\n        this._maxTimespan = 100;\n        this._resetting = false;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._boundWrapper = this._workWrapper.bind(this);\n        // Validation state\n        this._validationEvents = [];\n        this._workingState = WorkingState.INCOMPLETE;\n        this._partDone = 0;\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationStack = [new ProgressState(0, 1)];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        this._prefix = \"salveDom\";\n        // The distance between walkers under which we skip saving a walker in the\n        // cache.\n        this._walkerCacheGap = 100;\n        this._events = new event_emitter_1.EventEmitter();\n        var keys = [\"timeout\", \"maxTimespan\",\n            \"walkerCacheGap\"];\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            var value = options[key];\n            if (value === undefined) {\n                continue;\n            }\n            if (value < 0) {\n                throw new Error(\"the value for \" + key + \" cannot be negative\");\n            }\n            this[\"_\" + key] = options[key];\n        }\n        if (options.prefix !== undefined) {\n            this._prefix = options.prefix;\n        }\n        this._curEl = this.root;\n        // This prevents an infinite loop when speculativelyValidate is called to\n        // validate a text node.\n        this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", this._validationEvents.length);\n        this._setWorkingState(WorkingState.INCOMPLETE, 0);\n        this._validationWalker = this.schema.newWalker();\n        this.events = this._events;\n    }\n    Validator.prototype.makeKey = function (key) {\n        return \"\" + this._prefix + key;\n    };\n    /**\n     * Function allowing to get a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype.getNodeProperty = function (node, key) {\n        return node[this.makeKey(key)];\n    };\n    /**\n     * Function allowing to set a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype._setNodeProperty = function (node, key, value) {\n        node[this.makeKey(key)] = value;\n    };\n    Validator.prototype._clearNodeProperties = function (node) {\n        var keys = [\n            \"EventIndexAfter\",\n            \"EventIndexAfterStart\",\n            \"EventIndexBeforeAttributes\",\n            \"EventIndexAfterAttributes\",\n            \"PossibleDueToWildcard\",\n            \"ErrorId\",\n        ];\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            delete node[this.makeKey(key)];\n        }\n    };\n    /**\n     * Starts the background validation process.\n     */\n    Validator.prototype.start = function () {\n        if (this._timeoutId !== undefined) {\n            this._stop(WorkingState.WORKING);\n        }\n        // When we call ``this.start``, we want the validation to start ASAP. So we\n        // do not use ``this._timeout`` here. However, we do not call\n        // ``this._workWrapper`` directly because we want to be able to call\n        // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n        // directly, we'd be calling this._cycle from inside this._cycle, which is\n        // results in an internal error.\n        this._timeoutId = setTimeout(this._boundWrapper, 0);\n    };\n    /**\n     * Get the namespaces defined in the schema passed to the Validator.\n     *\n     * @returns The namespaces known to the schema.\n     */\n    Validator.prototype.getSchemaNamespaces = function () {\n        return this.schema.getNamespaces();\n    };\n    /**\n     * Get the namespaces used in the document. This method does not cache its\n     * information and scan the whole document independently of the current\n     * validation status.\n     *\n     * @returns An object whose keys are namespace prefixes and values are lists\n     * of namespace URIs.  The values are lists because prefixes can be redefined\n     * in a document.\n     */\n    Validator.prototype.getDocumentNamespaces = function () {\n        var ret = {};\n        function _process(node) {\n            if (node === null) {\n                return;\n            }\n            var attrIxLim = node.attributes.length;\n            for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                var attr = node.attributes[attrIx];\n                if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n                    var key = attr.name.slice(6);\n                    var array = ret[key];\n                    if (array === undefined) {\n                        array = ret[key] = [];\n                    }\n                    array.push(attr.value);\n                }\n            }\n            var child = node.firstChild;\n            while (child !== null) {\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    _process(child);\n                }\n                child = child.nextSibling;\n            }\n        }\n        _process(this.root.firstChild);\n        return ret;\n    };\n    /**\n     * Convenience method. The bound version of this method\n     * (``this._boundWrapper``) is what is called by the timeouts to perform the\n     * background validation.\n     */\n    Validator.prototype._workWrapper = function () {\n        if (this._work()) {\n            this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n        }\n    };\n    /**\n     * Controller method for the background validation. Keeps the validator\n     * running only until done or until the maximum time span for one run\n     * of the validator is reached.\n     *\n     * @returns False if there is no more work to do. True otherwise.\n     */\n    Validator.prototype._work = function () {\n        var startDate = Date.now();\n        while (true) {\n            // Give a chance to other operations to work.\n            if ((this._maxTimespan > 0) &&\n                (Date.now() - startDate) >= this._maxTimespan) {\n                return true;\n            }\n            var ret = this._cycle();\n            if (!ret) {\n                return false;\n            }\n        }\n    };\n    /**\n     * Performs one cycle of validation. \"One cycle\" is an arbitrarily small unit\n     * of work.\n     *\n     * @returns False if there is no more work to be done. True otherwise.\n     *\n     * @throws {Error} When there is an internal error.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._cycle = function () {\n        var _this = this;\n        // If we got here after a reset, then we've finished resetting.  If we were\n        // not resetting, then this is a noop.\n        this._resetting = false;\n        //\n        // This check is meant to catch problems that could be hard to diagnose if\n        // wed or one of its modes had a bug such that `_cycle` is reentered from\n        // `_cycle`. This could happen during error processing, for instance. Error\n        // processing causes wed to process the errors, which causes changes in the\n        // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n        // execute something like `getErrorsFor`, which could cause `_cycle` to be\n        // reentered.\n        //\n        if (this._cycleEntered > 0) {\n            throw new Error(\"internal error: _cycle is being reentered\");\n        }\n        if (this._cycleEntered < 0) {\n            throw new Error(\"internal error: _cycleEntered negative\");\n        }\n        //\n        // IMPORTANT: This variable must be decremented before exiting this\n        // method. A try...finally statement is not used here because it would\n        // prevent some virtual machines from optimizing this function.\n        //\n        this._cycleEntered++;\n        var walker = this._validationWalker;\n        var stack = this._validationStack;\n        var events = this._validationEvents;\n        var portion = stack[0].portion;\n        var stage = this._validationStage;\n        var _loop_1 = function () {\n            var curEl = this_1._curEl;\n            switch (stage) {\n                case Stage.START_TAG: {\n                    // The logic is such that if we get here curEl must be an Element.\n                    curEl = curEl;\n                    stack.unshift(new ProgressState(this_1._partDone, portion));\n                    // Handle namespace declarations. Yes, this must happen before we deal\n                    // with the tag name.\n                    this_1._fireAndProcessEvent(walker, ENTER_CONTEXT_EVENT, curEl, 0);\n                    var attrIxLim = curEl.attributes.length;\n                    for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                        var attr = curEl.attributes[attrIx];\n                        if (attr.name === \"xmlns\") {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", \"\", attr.value), curEl, 0);\n                        }\n                        else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", attr.name.slice(6), attr.value), curEl, 0);\n                        }\n                    }\n                    var tagName = curEl.tagName;\n                    // tslint:disable-next-line:no-non-null-assertion\n                    var parent_1 = curEl.parentNode;\n                    var curElIndex = _indexOf(parent_1.childNodes, curEl);\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        this_1._processEventResult([new salve_1.ValidationError(\"cannot resolve the name \" + tagName)], parent_1, curElIndex);\n                        // This allows us to move forward. It will certainly cause a\n                        // validation error, and send salve into its recovery mode for unknown\n                        // elements.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    // Check whether this element is going to be allowed only due to a\n                    // wildcard.\n                    this_1._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\", ename.ns, ename.name);\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"enterStartTag\", ename.ns, ename.name), parent_1, curElIndex);\n                    this_1._setNodeProperty(curEl, \"EventIndexBeforeAttributes\", events.length);\n                    this_1._fireAttributeEvents(walker, curEl);\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterAttributes\", events.length);\n                    // Leave the start tag.\n                    this_1._fireAndProcessEvent(walker, LEAVE_START_TAG_EVENT, curEl, 0);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n                    this_1._cycleEntered--;\n                    return { value: true };\n                    // break would be unreachable.\n                }\n                case Stage.CONTENTS: {\n                    var node = (this_1._previousChild === null) ?\n                        // starting from scratch\n                        curEl.firstChild :\n                        // already validation contents\n                        this_1._previousChild.nextSibling;\n                    var textAccumulator_1 = [];\n                    var textAccumulatorNode_1;\n                    var flushText = function () {\n                        if (textAccumulator_1.length !== 0) {\n                            var event_1 = new salve_1.Event(\"text\", textAccumulator_1.join(\"\"));\n                            var eventResult = walker.fireEvent(event_1);\n                            if (eventResult instanceof Array) {\n                                if (textAccumulatorNode_1 === undefined) {\n                                    throw new Error(\"flushText running with undefined node\");\n                                }\n                                // We are never without a parentNode here.\n                                // tslint:disable-next-line:no-non-null-assertion\n                                var parent_2 = textAccumulatorNode_1.parentNode;\n                                _this._processEventResult(eventResult, parent_2, _indexOf(parent_2.childNodes, textAccumulatorNode_1));\n                            }\n                        }\n                        textAccumulator_1 = [];\n                        textAccumulatorNode_1 = undefined;\n                    };\n                    while (node !== null) {\n                        switch (node.nodeType) {\n                            case Node.TEXT_NODE:\n                                // Salve does not allow multiple text events in a row. If text is\n                                // encountered, then all the text must be passed to salve as a\n                                // single event. We record the text and will flush it to salve\n                                // later.\n                                textAccumulator_1.push(node.data);\n                                if (textAccumulatorNode_1 === undefined) {\n                                    textAccumulatorNode_1 = node;\n                                }\n                                break;\n                            case Node.ELEMENT_NODE:\n                                flushText();\n                                portion /= curEl.childElementCount;\n                                this_1._curEl = curEl = node;\n                                stage = this_1._validationStage = Stage.START_TAG;\n                                this_1._previousChild = null;\n                                return \"continue-stage_change\";\n                            case Node.COMMENT_NODE:\n                                break; // We just skip over comment nodes.\n                            default:\n                                throw new Error(\"unexpected node type: \" + node.nodeType);\n                        }\n                        node = node.nextSibling;\n                    }\n                    flushText();\n                    stage = this_1._validationStage = Stage.END_TAG;\n                    break;\n                }\n                case Stage.END_TAG: {\n                    // We've reached the end...\n                    if (curEl === this_1.root) {\n                        var eventResult = walker.end();\n                        if (eventResult instanceof Array) {\n                            this_1._processEventResult(eventResult, curEl, curEl.childNodes.length);\n                        }\n                        this_1._runDocumentValidation();\n                        this_1._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n                        this_1._partDone = 1;\n                        this_1._stop(this_1._errors.length > 0 ? WorkingState.INVALID :\n                            WorkingState.VALID);\n                        this_1._cycleEntered--;\n                        return { value: false };\n                    }\n                    // we need it later\n                    var originalElement = curEl;\n                    var tagName = curEl.tagName;\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        // We just produce the name name we produced when we encountered the\n                        // start tag.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"endTag\", ename.ns, ename.name), curEl, curEl.childNodes.length);\n                    this_1._fireAndProcessEvent(walker, LEAVE_CONTEXT_EVENT, curEl, curEl.childNodes.length);\n                    // Go back to the parent\n                    this_1._previousChild = curEl;\n                    // We are never without a parentNode here.\n                    // tslint:disable-next-line:no-non-null-assertion\n                    this_1._curEl = curEl = curEl.parentNode;\n                    var nextDone = this_1._partDone;\n                    if (curEl !== this_1.root) {\n                        stack.shift();\n                        var first = stack[0];\n                        nextDone = first.partDone += portion;\n                        portion = first.portion;\n                    }\n                    this_1._setWorkingState(WorkingState.WORKING, nextDone);\n                    this_1._setNodeProperty(originalElement, \"EventIndexAfter\", this_1._validationEvents.length);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._cycleEntered--;\n                    return { value: true };\n                }\n                // break; would be unreachable\n                default:\n                    throw new Error(\"unexpected state\");\n            }\n        };\n        var this_1 = this;\n        stage_change: while (true) {\n            var state_1 = _loop_1();\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n            switch (state_1) {\n                case \"continue-stage_change\": continue stage_change;\n            }\n        }\n    };\n    /**\n     * Stops background validation.\n     */\n    Validator.prototype.stop = function () {\n        this._stop();\n    };\n    /**\n     * This private method takes an argument that allows setting the working state\n     * to a specific value. This is useful to reduce the number of\n     * ``state-update`` events emitted when some internal operations are\n     * performed. The alternative would be to perform a state change before or\n     * after the call to ``stop``, which would result in more events being\n     * emitted.\n     *\n     * If the parameter is unused, then the logic is that if we were not yet in a\n     * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n     *\n     * @param state The state with which to stop.\n     */\n    Validator.prototype._stop = function (state) {\n        if (this._timeoutId !== undefined) {\n            clearTimeout(this._timeoutId);\n        }\n        this._timeoutId = undefined;\n        if (state === undefined) {\n            // We are stopping prematurely, update the state\n            if (this._workingState === WorkingState.WORKING) {\n                this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n            }\n        }\n        else {\n            this._setWorkingState(state, this._partDone);\n        }\n    };\n    /**\n     * Run document-level validation that cannot be modeled by Relax NG.  The\n     * default implementation does nothing. Deriving classes may override it to\n     * call [[_processError]].\n     */\n    Validator.prototype._runDocumentValidation = function () { }; // tslint:disable-line: no-empty\n    /**\n     * Restarts validation from a specific point. After the call returns, the\n     * background validation will be in effect. (So calling it on a stopped\n     * validator has the side effect of starting it.)\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.restartAt = function (node) {\n        this.resetTo(node);\n        this.start();\n    };\n    /**\n     * Reset validation to continue from a certain point.\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.resetTo = function (node) {\n        // We use `this._resetting` to avoid a costly reinitialization if this\n        // method is called twice in a row before any work has had a chance to be\n        // done.\n        if (!this._resetting) {\n            this._resetting = true;\n            this._resetTo(node);\n        }\n    };\n    Validator.prototype._erase = function (el) {\n        this._clearNodeProperties(el);\n        var child = el.firstElementChild;\n        while (child !== null) {\n            this._erase(child);\n            child = child.nextElementSibling;\n        }\n    };\n    /**\n     * Resets validation to continue from a specific point. Any further work done\n     * by the validator will start from the point specified.\n     *\n     * @param node The element to start validation from.\n     *\n     * @emits module:validator~Validator#reset-errors\n     */\n    Validator.prototype._resetTo = function (node) {\n        // An earlier implementation was trying to be clever and to avoid restarting\n        // much earlier than strictly needed. That ended up being more costly than\n        // doing this primitive restart from 0 no matter what. Eventually, Validator\n        // should be updated so that on large documents, restarting from a location\n        // towards the end does not require revalidating the whole document. For\n        // now, since wed is used for smallish documents, it would be a premature\n        // optimization.\n        this._erase(this.root);\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationWalker = this.schema.newWalker();\n        this._validationEvents = [];\n        this._curEl = this.root;\n        this._partDone = 0;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        /**\n         * Tells the listener that it must reset its list of errors.\n         *\n         * @event module:validator~Validator#reset-errors\n         * @type {Object}\n         * @property {integer} at The index of the first error that must\n         * be deleted. This error and all those after it must be deleted.\n         */\n        this._events._emit(\"reset-errors\", { at: 0 });\n    };\n    /**\n     * Sets the working state of the validator. Emits a \"state-update\" event if\n     * the state has changed.\n     *\n     * @param newState The new state of the validator.\n     *\n     * @param newDone The new portion of work done.\n     *\n     * @emits module:validator~Validator#state-update\n     */\n    Validator.prototype._setWorkingState = function (newState, newDone) {\n        var changed = false;\n        if (this._workingState !== newState) {\n            this._workingState = newState;\n            changed = true;\n        }\n        if (this._partDone !== newDone) {\n            this._partDone = newDone;\n            changed = true;\n        }\n        if (changed) {\n            /**\n             * Tells the listener that the validator has changed state.\n             *\n             * @event module:validator~Validator#state-update\n             */\n            this._events._emit(\"state-update\", { state: newState, partDone: newDone });\n        }\n    };\n    /**\n     * Gets the validator working state.\n     *\n     * @returns The working state\n     */\n    Validator.prototype.getWorkingState = function () {\n        return {\n            state: this._workingState,\n            partDone: this._partDone,\n        };\n    };\n    Object.defineProperty(Validator.prototype, \"errors\", {\n        /**\n         * The current set of errors.\n         */\n        get: function () {\n            return this._errors.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Processes the result of firing a tag event. It will emit an \"error\"\n     * event for each error.\n     *\n     * @param results The results of the walker's ``fireEvent`` call.\n     *\n     * @param node The data node to which the result belongs.\n     *\n     * @param index The index into ``node`` to which the result belongs.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processEventResult = function (results, node, index) {\n        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n            var result = results_1[_i];\n            this._processError({ error: result, node: node, index: index });\n        }\n    };\n    /**\n     * This method should be called whenever a new error is detected. It\n     * records the error and emits the corresponding event.\n     *\n     * @param error The error found.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processError = function (error) {\n        var _this = this;\n        /**\n         * We don't make this a method because it should only be called from\n         * ``_processError``. The way we generate new ID values works **only**\n         * because we push a new error in the list when there's no ID already set.\n         *\n         * Ensure the node has an error ID and return it. The error ID is the number\n         * set on the ``ErrorId`` property. If the node has no ID set yet, we assign\n         * one and return the new value. Otherwise, the old value is returned.\n         *\n         * @param node The node of interest.\n         *\n         * @returns The error ID.\n         */\n        var ensureErrorId = function (nodeGettingId) {\n            var oldId = _this.getNodeProperty(nodeGettingId, \"ErrorId\");\n            if (oldId === undefined) {\n                // The length of the error array at the time of first calling this\n                // function is good enough to serve as an ID.\n                oldId = _this._errors.length;\n                _this._setNodeProperty(nodeGettingId, \"ErrorId\", oldId);\n            }\n            return oldId;\n        };\n        // We must first check whether we've seen this error before, and avoid\n        // recording it again if we've seen it. This could happen when\n        // ``_getWalkerAt`` is used, because the validator may repeat firing events\n        // and processing the associated errors. We cannot just turn off error\n        // processing when ``_getWalkerAt`` is used because it may be used in cases\n        // where we are legitimately advancing the state of validation (rather than\n        // going over old stuff).\n        var node = error.node;\n        var errorId = node == null ? \"\" : String(ensureErrorId(node));\n        var key = errorId + \",\" + error.error.toString();\n        var alreadySeen = this._errorsSeen[key];\n        // We want to do a strict compare with true to handle ``undefined``.\n        if (alreadySeen !== true) {\n            this._errorsSeen[key] = true;\n            this._errors.push(error);\n            /**\n             * Tells the listener that an error has occurred.\n             *\n             * @event module:validator~Validator#error\n             * @type {Object}\n             * @property {Object} error The validation error.\n             * @property {Node} node The node where the error occurred.\n             * @property {integer} index The index in this node.\n             */\n            this._events._emit(\"error\", error);\n        }\n    };\n    /**\n     * Fires all the attribute events for a given element.\n     */\n    Validator.prototype._fireAttributeEvents = function (walker, el) {\n        // Find all attributes, fire events for them.\n        var attributes = el.attributes;\n        // tslint:disable-next-line:prefer-for-of\n        for (var i = 0; i < attributes.length; ++i) {\n            var attr = attributes[i];\n            // Skip those attributes which are namespace attributes.\n            if ((attr.name === \"xmlns\") ||\n                (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n                continue;\n            }\n            if (this._fireAttributeNameEvent(walker, el, attr)) {\n                this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeValue\", attr.value), attr, 0);\n            }\n        }\n    };\n    /**\n     * Fires an attributeName event. If the attribute name is in a namespace and\n     * cannot be resolved, the event is not fired.\n     *\n     * @returns True if the event was actually fired, false if not.\n     */\n    Validator.prototype._fireAttributeNameEvent = function (walker, el, attr) {\n        var attrName = attr.name;\n        var ename = walker.resolveName(attrName, true);\n        if (ename === undefined) {\n            this._processError({ error: new salve_1.ValidationError(\"cannot resolve attribute name \" + attrName), node: attr, index: 0 });\n            return false;\n        }\n        this._setPossibleDueToWildcard(attr, walker, \"attributeName\", ename.ns, ename.name);\n        this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeName\", ename.ns, ename.name), attr, 0);\n        return true;\n    };\n    /**\n     * Convenience method to fire events.\n     *\n     * @param walker The walker on which to fire events.\n     *\n     * @param event The event to fire.\n     *\n     * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n     * can be undefined for events that have no location associated with them.\n     *\n     * @param ix The index into ``el`` associated with this event, or a ``Node``\n     * which must be a child of ``el``. The index will be computed from the\n     * location of the child passed as this parameter in ``el``.\n     */\n    Validator.prototype._fireAndProcessEvent = function (walker, event, el, ix) {\n        this._validationEvents.push(event);\n        var eventResult = walker.fireEvent(event);\n        if (eventResult instanceof Array) {\n            if (el != null && ix !== undefined && typeof ix !== \"number\") {\n                ix = _indexOf(el.childNodes, ix);\n            }\n            this._processEventResult(eventResult, el, ix);\n        }\n    };\n    /**\n     * Force an immediate validation which is guaranteed to go at least up to the\n     * point specified by ``container, index``, exclusively. These parameters are\n     * interpreted in the same way a DOM caret is.\n     *\n     * If the validation has not yet reached the location specified, validation\n     * will immediately be performed to reach the point. If the validation has\n     * already reached this point, then this call is a no-op.\n     *\n     * There is one exception in the way the ``container, index`` pair is\n     * interpreted. If the container is the ``root`` that was passed when\n     * constructing the Validator, then setting ``index`` to a negative value will\n     * result in the validation validating all elements **and** considering the\n     * document complete. So unclosed tags or missing elements will be\n     * reported. Otherwise, the validation goes up the ``index`` but considers the\n     * document incomplete, and won't report the errors that are normally reported\n     * at the end of a document. For instance, unclosed elements won't be\n     * reported.\n     *\n     * @param container The location up to where to validate.\n     *\n     * @param index The location up to where to validate.\n     *\n     * @param attributes Whether we are interested to validate up to and including\n     * the attribute events of the node pointed to by ``container, index``. The\n     * validation ends before leaving the start tag.\n     *\n     * @throws {Error} If ``container`` is not of element or text type.\n     */\n    Validator.prototype._validateUpTo = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to validate after attributes but before \" +\n                \"the end of the start tag on a \" +\n                \"node which is not an element node\");\n        }\n        // Set these to reasonable defaults. The rest of the code is dedicated to\n        // changing these values to those necessary depending on specifics of what\n        // is passed to the method.\n        var toInspect = container;\n        var dataKey = \"EventIndexAfter\";\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (attributes) {\n                dataKey = \"EventIndexAfterAttributes\";\n                toInspect = container.childNodes[index];\n            }\n            else if (index === 0) {\n                // We're before the top element, no events to fire.\n                return;\n            }\n            // default values of toInspect and dataKey are what we want\n        }\n        else {\n            if (isAttr(container)) {\n                toInspect = container.ownerElement;\n                dataKey = \"EventIndexBeforeAttributes\";\n            }\n            else {\n                switch (container.nodeType) {\n                    case Node.TEXT_NODE:\n                        toInspect = container.previousElementSibling;\n                        if (toInspect === null) {\n                            // tslint:disable-next-line:no-non-null-assertion\n                            toInspect = container.parentNode;\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    case Node.ELEMENT_NODE:\n                    case Node.DOCUMENT_FRAGMENT_NODE:\n                    case Node.DOCUMENT_NODE:\n                        var node = container.childNodes[index];\n                        var prev = node === undefined ?\n                            container.lastElementChild :\n                            // It may not be an element, in which case we get \"undefined\".\n                            node.previousElementSibling;\n                        if (attributes) {\n                            dataKey = \"EventIndexAfterAttributes\";\n                            toInspect = node;\n                        }\n                        else if (prev !== null) {\n                            toInspect = prev;\n                        }\n                        else {\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    default:\n                        throw new Error(\"unexpected node type: \" + container.nodeType);\n                }\n            }\n        }\n        while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n            this._cycle();\n        }\n    };\n    /**\n     * Gets the walker which would represent the state of parsing at the point\n     * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n     * of how these parameters are interpreted.\n     *\n     * **The walker returned by this function is not guaranteed to be a new\n     *   instance. Callers should not modify the walker returned but instead clone\n     *   it.**\n     *\n     * @param container\n     *\n     * @param index\n     *\n     * @param attributes Whether we are interested to validate up to but not\n     * including the attribute events of the node pointed to by ``container,\n     * index``. If ``true`` the walker returned will have all events fired on it\n     * up to, and including, those attribute events on the element pointed to by\n     * ``container, index``.\n     *\n     * @returns The walker.\n     *\n     * @throws {EventIndexException} If it runs out of events or computes an event\n     * index that makes no sense.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._getWalkerAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to get a walker for attribute events on a \" +\n                \"node which is not an element node\");\n        }\n        // Make sure we have the data we need.\n        this._validateUpTo(container, index, attributes);\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (!attributes) {\n                // We're before the top element, no events to fire.\n                if (index === 0) {\n                    return this.schema.newWalker();\n                }\n                // _validateUpTo ensures that the current walker held by the validator\n                // is what we want. We can just return it here because it is the\n                // caller's reponsibility to either not modify it or clone it.\n                return this._validationWalker;\n            }\n        }\n        var walker;\n        function fireTextEvent(textNode) {\n            if (walker === undefined) {\n                throw new Error(\"calling fireTextEvent without a walker\");\n            }\n            walker.fireEvent(new salve_1.Event(\"text\", textNode.data));\n        }\n        if (isAttr(container)) {\n            var el = container.ownerElement;\n            walker = this.readyWalker(\n            // tslint:disable-next-line:no-non-null-assertion\n            this.getNodeProperty(el, \"EventIndexBeforeAttributes\"));\n            // Don't fire on namespace attributes.\n            if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n                walker = walker.clone();\n                this._fireAttributeNameEvent(walker, el, container);\n            }\n        }\n        else {\n            switch (container.nodeType) {\n                case Node.TEXT_NODE: {\n                    var prev = container.previousElementSibling;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (prev !== null) {\n                        getFrom = prev;\n                        propName = \"EventIndexAfter\";\n                    }\n                    else {\n                        // tslint:disable-next-line:no-non-null-assertion\n                        getFrom = container.parentNode;\n                        propName = \"EventIndexAfterStart\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    // We will attempt to fire a text event if our location is inside the\n                    // current text node.\n                    //\n                    // A previous version of this code was also checking whether there is a\n                    // text node between this text node and prev but this cannot happen\n                    // because the tree on which validation is performed cannot have two\n                    // adjacent text nodes. It was also checking whether there was a _text\n                    // element between prev and this text node but this also cannot happen.\n                    if (index > 0) {\n                        walker = walker.clone();\n                        fireTextEvent(container);\n                    }\n                    break;\n                }\n                case Node.ELEMENT_NODE:\n                case Node.DOCUMENT_NODE:\n                case Node.DOCUMENT_FRAGMENT_NODE: {\n                    var node = container.childNodes[index];\n                    var prev = void 0;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (!attributes) {\n                        prev = node === undefined ? container.lastElementChild :\n                            node.previousElementSibling;\n                        if (prev !== null) {\n                            getFrom = prev;\n                            propName = \"EventIndexAfter\";\n                        }\n                        else {\n                            getFrom = container;\n                            propName = \"EventIndexAfterStart\";\n                        }\n                    }\n                    else {\n                        getFrom = node;\n                        propName = \"EventIndexAfterAttributes\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    if (!attributes) {\n                        // We will attempt to fire a text event if another text node appeared\n                        // between the node we care about and the element just before it.\n                        var prevSibling = node != null ? node.previousSibling : null;\n                        if (prevSibling !== null &&\n                            // If the previous sibling is the same as the previous *element*\n                            // sibbling, then there is nothing *between* that we need to take\n                            // care of.\n                            prevSibling !== prev) {\n                            if (prevSibling.nodeType === Node.TEXT_NODE) {\n                                walker = walker.clone();\n                                fireTextEvent(prevSibling);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(\"unexpected node type: \" + container.nodeType);\n            }\n        }\n        return walker;\n    };\n    Validator.prototype.readyWalker = function (eventIndex) {\n        //\n        // Perceptive readers will notice that the caching being done here could be\n        // more aggressive. It turns out that the cases where we have to clone the\n        // walker after getting it from the cache are not that frequently used, so\n        // there is little to gain from being more aggressive. Furthermore, it is\n        // likely that the caching system will change when we implement a saner way\n        // to reset validation and segment large documents into smaller chunks.\n        //\n        if (eventIndex === undefined) {\n            throw new EventIndexException();\n        }\n        var cache = this._walkerCache;\n        var max = this._walkerCacheMax;\n        var walker = cache[eventIndex];\n        if (walker !== undefined) {\n            return walker;\n        }\n        //\n        // Scan the cache for a walker we could use... rather than start from zero.\n        //\n        // There is no point in trying to be clever by using this._walkerCacheGap to\n        // start our search. If _getWalkerAt is called with decreasing positions in\n        // the document, then the gap is meaningless for our search. (Such scenario\n        // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n        // cannot assume that it won't happen.)\n        //\n        // Also, the following approach is a bit crude but trying to be clever with\n        // Object.keys() and then searching through a sorted list does not yield an\n        // appreciable improvement. Maybe on very large documents it would but this\n        // module will have to be redesigned to tackle that so there's no point now\n        // to be cleverer than this. We also tested using a sparse Array for the\n        // cache and got visibly worse performance. And we tested to see if a flag\n        // indicating if the cache has anything in it would help avoid doing a long\n        // search but it maked things worse. Basically, it seems that the typical\n        // usage pattern of _getWalkerAt is such that it will usually be called in\n        // increasing order of position in the document.\n        //\n        var searchIx = eventIndex;\n        if (searchIx >= max) {\n            searchIx = max;\n            walker = cache[searchIx];\n        }\n        else {\n            while (walker === undefined && --searchIx >= 0) {\n                walker = cache[searchIx];\n            }\n        }\n        if (walker !== undefined) {\n            walker = walker.clone();\n        }\n        else {\n            walker = this.schema.newWalker();\n            searchIx = 0;\n        }\n        for (var ix = searchIx; ix < eventIndex; ++ix) {\n            walker.fireEvent(this._validationEvents[ix]);\n        }\n        // This is a bit arbitrary to find a balance between caching too much\n        // information and spending too much time computing walkers.\n        if (eventIndex - searchIx >= this._walkerCacheGap) {\n            cache[eventIndex] = walker;\n            this._walkerCacheMax = Math.max(eventIndex, max);\n        }\n        return walker;\n    };\n    /**\n     * Returns the set of possible events for the location specified by the\n     * parameters.\n     *\n     * @param container Together with ``index`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param index Together with ``container`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param attributes\n     *\n     * @returns A set of possible events.\n     */\n    Validator.prototype.possibleAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        var walker = this._getWalkerAt(container, index, attributes);\n        // Calling possible does not *modify* the walker.\n        return walker.possible();\n    };\n    /**\n     * Finds the locations in a node where a certain validation event is\n     * possible.\n     *\n     * @param container A node.\n     *\n     * @param event The event to search for. The event should be presented in the\n     * same format used for ``fireEvent``.\n     *\n     * @returns The locations in ``container`` where the event is possible.\n     */\n    Validator.prototype.possibleWhere = function (container, event) {\n        var ret = [];\n        for (var index = 0; index <= container.childNodes.length; ++index) {\n            var possible = this.possibleAt(container, index);\n            if (possible.has(event)) {\n                ret.push(index);\n            }\n            else if (event.params[0] === \"enterStartTag\" ||\n                event.params[0] === \"attributeName\") {\n                // In the case where we have a name pattern as the 2nd parameter, and\n                // this pattern can be complex or have wildcards, then we have to check\n                // all events one by one for a name pattern match. (While enterStartTag,\n                // endTag and attributeName all have name patterns, endTag cannot be\n                // complex or allow wildcards because what it allows much match the tag\n                // that started the current element.\n                for (var _i = 0, _a = possible.toArray(); _i < _a.length; _i++) {\n                    var candidate = _a[_i];\n                    if (candidate.params[0] === event.params[0] &&\n                        candidate.params[1].match(event.params[1], event.params[2])) {\n                        ret.push(index);\n                        break;\n                    }\n                }\n            }\n        }\n        return ret;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidate = function (container, index, toParse) {\n        var clone;\n        if (toParse instanceof Array) {\n            clone = container.ownerDocument.createDocumentFragment();\n            for (var _i = 0, toParse_1 = toParse; _i < toParse_1.length; _i++) {\n                var child = toParse_1[_i];\n                clone.insertBefore(child.cloneNode(true), null);\n            }\n        }\n        else {\n            clone = toParse.cloneNode(true);\n        }\n        var root = container.ownerDocument.createElement(\"div\");\n        root.insertBefore(clone, null);\n        return this.speculativelyValidateFragment(container, index, root);\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse. See above.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidateFragment = function (container, index, toParse) {\n        // This is useful for pure-JS code that may be calling this.\n        if (toParse.nodeType !== Node.ELEMENT_NODE) {\n            throw new Error(\"toParse is not an element\");\n        }\n        // We create a new validator with the proper state to parse the fragment\n        // we've been given.\n        var dup = new Validator(this.schema, toParse);\n        // We have to clone the walker to prevent messing up the internal cache.\n        dup._validationWalker = this._getWalkerAt(container, index).clone();\n        // This forces validating the whole fragment\n        dup._validateUpTo(toParse, toParse.childNodes.length);\n        if (dup._errors.length !== 0) {\n            return dup._errors;\n        }\n        return false;\n    };\n    /**\n     * Obtain the validation errors that belong to a specific node.\n     *\n     * The term \"that belong to\" has a specific meaning here:\n     *\n     * - An error in the contents of an element belongs to the element whose\n     *   contents are incorrect. For instance if in the sequence\n     *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n     *   error belongs to the node for the element ``foo``, not the node for the\n     *   element ``blip``.\n     *\n     * - Attribute errors belong to the element node to which the attributes\n     *   belong.\n     *\n     * @param node The node whose errors we want to get.\n     *\n     * @returns The errors.\n     */\n    Validator.prototype.getErrorsFor = function (node) {\n        var parent = node.parentNode;\n        if (parent === null) {\n            throw new Error(\"node without a parent!\");\n        }\n        // Validate to after the closing tag of the node.\n        this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n        var ret = [];\n        for (var _i = 0, _a = this._errors; _i < _a.length; _i++) {\n            var errorData = _a[_i];\n            if (errorData.node === node) {\n                ret.push(errorData);\n            }\n        }\n        return ret;\n    };\n    /**\n     * Sets a flag indicating whether a node is possible only due to a name\n     * pattern wildcard, and emits an event if setting the flag is a change from\n     * the previous value of the flag. It does this by inspecting the event that\n     * would be fired when ``node`` is validated. The parameters ``eventName``,\n     * ``ns`` and ``name`` are used to determine what we are looking for among\n     * possible events.\n     *\n     * @param node The node we want to check.\n     *\n     * @param walker A walker whose last fired event is the one just before the\n     * event that would be fired when validating ``node``.\n     *\n     * @param eventName The event name we are interested in.\n     *\n     * @param ns The namespace to use with the event.\n     *\n     * @param name The name to use with the event.\n     *\n     * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n     *\n     */\n    Validator.prototype._setPossibleDueToWildcard = function (node, walker, eventName, ns, name) {\n        var previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n        var possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n        this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n        if (previous === undefined || previous !== possible) {\n            /**\n             * Tells the listener that a node's flag indicating whether it is possible\n             * only due to a wildcard has changed.\n             *\n             * @event module:validator~Validator#possible-due-to-wildcard-change\n             *\n             * @type {Node} The node whose flag has changed.\n             */\n            this._events._emit(\"possible-due-to-wildcard-change\", node);\n        }\n    };\n    /**\n     * Resolve a qualified name to an expanded name. See\n     * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n     * takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param name The name to rresolve.\n     *\n     * @param attributes Whether the name is an attribute's name.\n     *\n     * @return The resolved name.\n     */\n    Validator.prototype.resolveNameAt = function (container, index, name, attribute) {\n        if (attribute === void 0) { attribute = false; }\n        // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n        // its ``attribute`` parameter ``false``.\n        return this._getWalkerAt(container, index).resolveName(name, attribute);\n    };\n    /**\n     * Unresolve an expanded name to a qualified name. See\n     * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n     * method takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param uri The URI to unresolve.\n     *\n     * @param name The name to unresolve.\n     *\n     * @return The unresolved name.\n     */\n    Validator.prototype.unresolveNameAt = function (container, index, uri, name) {\n        return this._getWalkerAt(container, index).unresolveName(uri, name);\n    };\n    return Validator;\n}());\nexports.Validator = Validator;\n/**\n * Exception to be raised if we cannot parse a string as an XML document.\n */\nvar ParsingError = /** @class */ (function (_super) {\n    __extends(ParsingError, _super);\n    /**\n     * @param xmlErrors A string that contains the errors reported. The library\n     * here simply serializes the error document produced by the parser.\n     */\n    function ParsingError(xmlErrors) {\n        var _this = _super.call(this) || this;\n        _this.xmlErrors = xmlErrors;\n        var err = new Error(\"cannot parse\");\n        _this.name = \"ParsingError\";\n        _this.stack = err.stack;\n        _this.message = err.message;\n        tools_1.fixPrototype(_this, ParsingError);\n        return _this;\n    }\n    return ParsingError;\n}(Error));\nexports.ParsingError = ParsingError;\n// tslint:disable-next-line:no-http-string\nvar XML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\nvar MOZILLA_NAMESPACE = \n// tslint:disable-next-line:no-http-string\n\"http://www.mozilla.org/newlayout/xml/parsererror.xml\";\n/**\n * A utility function that detects whether the parsing fails and throws an error\n * in such case.\n *\n * Note that if you pass a well-formed and correctly structured error document\n * to this function, the result will look like an error, even though it was\n * parsed properly. Given the way ``DOMParser`` reports errors, this cannot be\n * helped.\n *\n * @param source The XML to parse.\n *\n * @param win The window from which to create a ``DOMParser``.\n *\n * @returns The parsed document.\n *\n * @throws {ParsingError} If the source cannot be parsed.\n */\nfunction safeParse(source, win) {\n    if (win === void 0) { win = window; }\n    var parser = new win.DOMParser();\n    var doc;\n    try {\n        doc = parser.parseFromString(source, \"text/xml\");\n    }\n    catch (ex) {\n        // On IE10/11 bad source will cause a SyntaxError.\n        if (ex.name !== \"SyntaxError\" || ex.code !== 12) {\n            throw ex;\n        }\n        throw new ParsingError(\"no error information available\");\n    }\n    var child = doc.firstChild;\n    while (child !== null && child.nodeType !== Node.ELEMENT_NODE) {\n        child = child.nextSibling;\n    }\n    var chromeTest = doc.querySelector(\"html>body>parsererror\");\n    // A DOMParser will generate a document that contains a description of the\n    // error(s). Unfortunately, this document is not consistently generated across\n    // browsers.\n    //\n    // However, running the code through Browser Stack on Chrome, Firefox, IE\n    // 10-100, Edge, Opera, and Safari that they boil down either to the Chrome\n    // case or the Firefox case.\n    if (\n    // Firefox\n    (child !== null &&\n        child.tagName === \"parsererror\" &&\n        child.namespaceURI === MOZILLA_NAMESPACE) ||\n        // Chrome\n        (chromeTest !== null && chromeTest.namespaceURI === XML_NAMESPACE)) {\n        throw new ParsingError(doc.documentElement.outerHTML);\n    }\n    return doc;\n}\nexports.safeParse = safeParse;\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this._eventListeners = Object.create(null);\n        this._generalListeners = [];\n        this._trace = false;\n    }\n    EventEmitter.prototype.addEventListener = function (eventName, listener) {\n        if (eventName === \"*\") {\n            this._generalListeners.push(listener);\n        }\n        else {\n            var listeners = this._eventListeners[eventName];\n            if (listeners === undefined) {\n                listeners = this._eventListeners[eventName] = [];\n            }\n            listeners.push(listener);\n        }\n    };\n    EventEmitter.prototype.addOneTimeEventListener = function (eventName, listener) {\n        var _this = this;\n        // We perform casts as any here to indicate to TypeScript that it is\n        // safe to pass this stub.\n        var me = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.removeEventListener(eventName, me);\n            return listener.apply(_this, args);\n        };\n        this.addEventListener(eventName, me);\n        return me;\n    };\n    EventEmitter.prototype.removeEventListener = function (eventName, listener) {\n        var listeners = (eventName === \"*\") ?\n            this._generalListeners :\n            this._eventListeners[eventName];\n        if (listeners === undefined) {\n            return;\n        }\n        var index = listeners.lastIndexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    EventEmitter.prototype.removeAllListeners = function (eventName) {\n        if (eventName === \"*\") {\n            this._generalListeners = [];\n        }\n        else {\n            this._eventListeners[eventName] = [];\n        }\n    };\n    /**\n     * This is the function that the class using this mixin must call to\n     * indicate that an event has occurred.\n     *\n     * @param eventName The name of the event to emit.\n     *\n     * @param ev The event data to provide to handlers. The type can be\n     * anything.\n     */\n    EventEmitter.prototype._emit = function (eventName, ev) {\n        if (this._trace) {\n            // tslint:disable-next-line: no-console\n            console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n        }\n        {\n            var listeners = this._generalListeners;\n            if (listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n                    var listener = listeners_1[_i];\n                    var ret = listener.call(undefined, eventName, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n        {\n            var listeners = this._eventListeners[eventName];\n            if (listeners !== undefined && listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _a = 0, listeners_2 = listeners; _a < listeners_2.length; _a++) {\n                    var listener = listeners_2[_a];\n                    var ret = listener.call(undefined, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n//  LocalWords:  Mangalam MPL Dubeau noop ev mixin\n//# sourceMappingURL=event_emitter.js.map\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\nfunction fixPrototype(obj, parent) {\n    var oldProto = Object.getPrototypeOf !== undefined ?\n        Object.getPrototypeOf(obj) :\n        obj.__proto__;\n    if (oldProto !== parent) {\n        if (Object.setPrototypeOf !== undefined) {\n            Object.setPrototypeOf(obj, parent.prototype);\n        }\n        else {\n            obj.__proto__ = parent.prototype;\n        }\n    }\n}\nexports.fixPrototype = fixPrototype;\n//# sourceMappingURL=tools.js.map\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// salve-dom.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0b58d04b8e0b22da219f","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar salve_1 = require(\"salve\");\nvar event_emitter_1 = require(\"./event_emitter\");\nvar tools_1 = require(\"./tools\");\nfunction _indexOf(parent, needle) {\n    return Array.prototype.indexOf.call(parent, needle);\n}\nfunction isAttr(it) {\n    var attrNodeType = Node.ATTRIBUTE_NODE;\n    // We check that ``attr_node_type`` is not undefined because eventually\n    // ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n    // could be testing ``undefined === undefined`` for objects which are not\n    // attributes, which would return ``true``. The function is not very strict\n    // but it should not be too lax either.\n    return it instanceof Attr ||\n        ((attrNodeType !== undefined) && (it.nodeType === attrNodeType));\n}\nexports.isAttr = isAttr;\n// validation_stage values\nvar Stage;\n(function (Stage) {\n    Stage[Stage[\"START_TAG\"] = 1] = \"START_TAG\";\n    Stage[Stage[\"CONTENTS\"] = 2] = \"CONTENTS\";\n    Stage[Stage[\"END_TAG\"] = 3] = \"END_TAG\";\n})(Stage || (Stage = {}));\n// Working state values\nvar WorkingState;\n(function (WorkingState) {\n    /**\n     * The validator is stopped but has not completed a validation pass yet.\n     */\n    WorkingState[WorkingState[\"INCOMPLETE\"] = 1] = \"INCOMPLETE\";\n    /**\n     * The validator is working on validating the document.\n     */\n    WorkingState[WorkingState[\"WORKING\"] = 2] = \"WORKING\";\n    /**\n     * The validator is stopped and has found the document invalid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"INVALID\"] = 3] = \"INVALID\";\n    /**\n     * The validator is stopped and has found the document valid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"VALID\"] = 4] = \"VALID\";\n})(WorkingState = exports.WorkingState || (exports.WorkingState = {}));\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nvar ProgressState = /** @class */ (function () {\n    function ProgressState(partDone, portion) {\n        this.partDone = partDone;\n        this.portion = portion;\n    }\n    return ProgressState;\n}());\n//\n// Note: the Validator class adds information to the Element nodes it is working\n// with by adding expando properties that start with \"wed_event_\". This deemed\n// acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to be open to\n//   third party software. Even if it were, the chance of a clash is small.\n//\n// * The values of the expando properties are primitives (not objects or other\n//   elements).\n//\n// * We don't care about browsers or situations where expando properties are not\n//   supported.\n//\n//\n// These are constants. So create them once rather than over and over again.\n//\nvar ENTER_CONTEXT_EVENT = new salve_1.Event(\"enterContext\");\nvar LEAVE_START_TAG_EVENT = new salve_1.Event(\"leaveStartTag\");\nvar LEAVE_CONTEXT_EVENT = new salve_1.Event(\"leaveContext\");\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nvar EventIndexException = /** @class */ (function (_super) {\n    __extends(EventIndexException, _super);\n    function EventIndexException() {\n        var _this = _super.call(this, \"undefined event_index; _validateUpTo should have taken care of that\") || this;\n        tools_1.fixPrototype(_this, EventIndexException);\n        return _this;\n    }\n    return EventIndexException;\n}(Error));\n// This private utility function checks whether an event is possible only\n// because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker, eventName, ns, name) {\n    var evs = walker.possible().toArray();\n    var matched = false;\n    for (var _i = 0, evs_1 = evs; _i < evs_1.length; _i++) {\n        var ev = evs_1[_i];\n        if (ev.params[0] !== eventName) {\n            continue;\n        }\n        var namePattern = ev.params[1];\n        var matches = namePattern.match(ns, name);\n        // Keep track of whether it ever matched anything.\n        matched = matched || matches;\n        // We already know that it matches, and this is not merely due to a\n        // wildcard.\n        if (matches && !namePattern.wildcardMatch(ns, name)) {\n            return false;\n        }\n    }\n    // If it never matched any pattern at all, then we must return false.  If we\n    // get here and matched is true then it means that it matched all patterns due\n    // to wildcards.\n    return matched;\n}\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``'s ``constructTree``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nvar Validator = /** @class */ (function () {\n    function Validator(schema, root, options) {\n        if (options === void 0) { options = {}; }\n        this.schema = schema;\n        this.root = root;\n        this._cycleEntered = 0;\n        this._timeout = 200;\n        this._maxTimespan = 100;\n        this._resetting = false;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._boundWrapper = this._workWrapper.bind(this);\n        // Validation state\n        this._validationEvents = [];\n        this._workingState = WorkingState.INCOMPLETE;\n        this._partDone = 0;\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationStack = [new ProgressState(0, 1)];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        this._prefix = \"salveDom\";\n        // The distance between walkers under which we skip saving a walker in the\n        // cache.\n        this._walkerCacheGap = 100;\n        this._events = new event_emitter_1.EventEmitter();\n        var keys = [\"timeout\", \"maxTimespan\",\n            \"walkerCacheGap\"];\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            var value = options[key];\n            if (value === undefined) {\n                continue;\n            }\n            if (value < 0) {\n                throw new Error(\"the value for \" + key + \" cannot be negative\");\n            }\n            this[\"_\" + key] = options[key];\n        }\n        if (options.prefix !== undefined) {\n            this._prefix = options.prefix;\n        }\n        this._curEl = this.root;\n        // This prevents an infinite loop when speculativelyValidate is called to\n        // validate a text node.\n        this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", this._validationEvents.length);\n        this._setWorkingState(WorkingState.INCOMPLETE, 0);\n        this._validationWalker = this.schema.newWalker();\n        this.events = this._events;\n    }\n    Validator.prototype.makeKey = function (key) {\n        return \"\" + this._prefix + key;\n    };\n    /**\n     * Function allowing to get a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype.getNodeProperty = function (node, key) {\n        return node[this.makeKey(key)];\n    };\n    /**\n     * Function allowing to set a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype._setNodeProperty = function (node, key, value) {\n        node[this.makeKey(key)] = value;\n    };\n    Validator.prototype._clearNodeProperties = function (node) {\n        var keys = [\n            \"EventIndexAfter\",\n            \"EventIndexAfterStart\",\n            \"EventIndexBeforeAttributes\",\n            \"EventIndexAfterAttributes\",\n            \"PossibleDueToWildcard\",\n            \"ErrorId\",\n        ];\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            delete node[this.makeKey(key)];\n        }\n    };\n    /**\n     * Starts the background validation process.\n     */\n    Validator.prototype.start = function () {\n        if (this._timeoutId !== undefined) {\n            this._stop(WorkingState.WORKING);\n        }\n        // When we call ``this.start``, we want the validation to start ASAP. So we\n        // do not use ``this._timeout`` here. However, we do not call\n        // ``this._workWrapper`` directly because we want to be able to call\n        // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n        // directly, we'd be calling this._cycle from inside this._cycle, which is\n        // results in an internal error.\n        this._timeoutId = setTimeout(this._boundWrapper, 0);\n    };\n    /**\n     * Get the namespaces defined in the schema passed to the Validator.\n     *\n     * @returns The namespaces known to the schema.\n     */\n    Validator.prototype.getSchemaNamespaces = function () {\n        return this.schema.getNamespaces();\n    };\n    /**\n     * Get the namespaces used in the document. This method does not cache its\n     * information and scan the whole document independently of the current\n     * validation status.\n     *\n     * @returns An object whose keys are namespace prefixes and values are lists\n     * of namespace URIs.  The values are lists because prefixes can be redefined\n     * in a document.\n     */\n    Validator.prototype.getDocumentNamespaces = function () {\n        var ret = {};\n        function _process(node) {\n            if (node === null) {\n                return;\n            }\n            var attrIxLim = node.attributes.length;\n            for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                var attr = node.attributes[attrIx];\n                if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n                    var key = attr.name.slice(6);\n                    var array = ret[key];\n                    if (array === undefined) {\n                        array = ret[key] = [];\n                    }\n                    array.push(attr.value);\n                }\n            }\n            var child = node.firstChild;\n            while (child !== null) {\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    _process(child);\n                }\n                child = child.nextSibling;\n            }\n        }\n        _process(this.root.firstChild);\n        return ret;\n    };\n    /**\n     * Convenience method. The bound version of this method\n     * (``this._boundWrapper``) is what is called by the timeouts to perform the\n     * background validation.\n     */\n    Validator.prototype._workWrapper = function () {\n        if (this._work()) {\n            this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n        }\n    };\n    /**\n     * Controller method for the background validation. Keeps the validator\n     * running only until done or until the maximum time span for one run\n     * of the validator is reached.\n     *\n     * @returns False if there is no more work to do. True otherwise.\n     */\n    Validator.prototype._work = function () {\n        var startDate = Date.now();\n        while (true) {\n            // Give a chance to other operations to work.\n            if ((this._maxTimespan > 0) &&\n                (Date.now() - startDate) >= this._maxTimespan) {\n                return true;\n            }\n            var ret = this._cycle();\n            if (!ret) {\n                return false;\n            }\n        }\n    };\n    /**\n     * Performs one cycle of validation. \"One cycle\" is an arbitrarily small unit\n     * of work.\n     *\n     * @returns False if there is no more work to be done. True otherwise.\n     *\n     * @throws {Error} When there is an internal error.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._cycle = function () {\n        var _this = this;\n        // If we got here after a reset, then we've finished resetting.  If we were\n        // not resetting, then this is a noop.\n        this._resetting = false;\n        //\n        // This check is meant to catch problems that could be hard to diagnose if\n        // wed or one of its modes had a bug such that `_cycle` is reentered from\n        // `_cycle`. This could happen during error processing, for instance. Error\n        // processing causes wed to process the errors, which causes changes in the\n        // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n        // execute something like `getErrorsFor`, which could cause `_cycle` to be\n        // reentered.\n        //\n        if (this._cycleEntered > 0) {\n            throw new Error(\"internal error: _cycle is being reentered\");\n        }\n        if (this._cycleEntered < 0) {\n            throw new Error(\"internal error: _cycleEntered negative\");\n        }\n        //\n        // IMPORTANT: This variable must be decremented before exiting this\n        // method. A try...finally statement is not used here because it would\n        // prevent some virtual machines from optimizing this function.\n        //\n        this._cycleEntered++;\n        var walker = this._validationWalker;\n        var stack = this._validationStack;\n        var events = this._validationEvents;\n        var portion = stack[0].portion;\n        var stage = this._validationStage;\n        var _loop_1 = function () {\n            var curEl = this_1._curEl;\n            switch (stage) {\n                case Stage.START_TAG: {\n                    // The logic is such that if we get here curEl must be an Element.\n                    curEl = curEl;\n                    stack.unshift(new ProgressState(this_1._partDone, portion));\n                    // Handle namespace declarations. Yes, this must happen before we deal\n                    // with the tag name.\n                    this_1._fireAndProcessEvent(walker, ENTER_CONTEXT_EVENT, curEl, 0);\n                    var attrIxLim = curEl.attributes.length;\n                    for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                        var attr = curEl.attributes[attrIx];\n                        if (attr.name === \"xmlns\") {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", \"\", attr.value), curEl, 0);\n                        }\n                        else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", attr.name.slice(6), attr.value), curEl, 0);\n                        }\n                    }\n                    var tagName = curEl.tagName;\n                    // tslint:disable-next-line:no-non-null-assertion\n                    var parent_1 = curEl.parentNode;\n                    var curElIndex = _indexOf(parent_1.childNodes, curEl);\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        this_1._processEventResult([new salve_1.ValidationError(\"cannot resolve the name \" + tagName)], parent_1, curElIndex);\n                        // This allows us to move forward. It will certainly cause a\n                        // validation error, and send salve into its recovery mode for unknown\n                        // elements.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    // Check whether this element is going to be allowed only due to a\n                    // wildcard.\n                    this_1._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\", ename.ns, ename.name);\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"enterStartTag\", ename.ns, ename.name), parent_1, curElIndex);\n                    this_1._setNodeProperty(curEl, \"EventIndexBeforeAttributes\", events.length);\n                    this_1._fireAttributeEvents(walker, curEl);\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterAttributes\", events.length);\n                    // Leave the start tag.\n                    this_1._fireAndProcessEvent(walker, LEAVE_START_TAG_EVENT, curEl, 0);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n                    this_1._cycleEntered--;\n                    return { value: true };\n                    // break would be unreachable.\n                }\n                case Stage.CONTENTS: {\n                    var node = (this_1._previousChild === null) ?\n                        // starting from scratch\n                        curEl.firstChild :\n                        // already validation contents\n                        this_1._previousChild.nextSibling;\n                    var textAccumulator_1 = [];\n                    var textAccumulatorNode_1;\n                    var flushText = function () {\n                        if (textAccumulator_1.length !== 0) {\n                            var event_1 = new salve_1.Event(\"text\", textAccumulator_1.join(\"\"));\n                            var eventResult = walker.fireEvent(event_1);\n                            if (eventResult instanceof Array) {\n                                if (textAccumulatorNode_1 === undefined) {\n                                    throw new Error(\"flushText running with undefined node\");\n                                }\n                                // We are never without a parentNode here.\n                                // tslint:disable-next-line:no-non-null-assertion\n                                var parent_2 = textAccumulatorNode_1.parentNode;\n                                _this._processEventResult(eventResult, parent_2, _indexOf(parent_2.childNodes, textAccumulatorNode_1));\n                            }\n                        }\n                        textAccumulator_1 = [];\n                        textAccumulatorNode_1 = undefined;\n                    };\n                    while (node !== null) {\n                        switch (node.nodeType) {\n                            case Node.TEXT_NODE:\n                                // Salve does not allow multiple text events in a row. If text is\n                                // encountered, then all the text must be passed to salve as a\n                                // single event. We record the text and will flush it to salve\n                                // later.\n                                textAccumulator_1.push(node.data);\n                                if (textAccumulatorNode_1 === undefined) {\n                                    textAccumulatorNode_1 = node;\n                                }\n                                break;\n                            case Node.ELEMENT_NODE:\n                                flushText();\n                                portion /= curEl.childElementCount;\n                                this_1._curEl = curEl = node;\n                                stage = this_1._validationStage = Stage.START_TAG;\n                                this_1._previousChild = null;\n                                return \"continue-stage_change\";\n                            case Node.COMMENT_NODE:\n                                break; // We just skip over comment nodes.\n                            default:\n                                throw new Error(\"unexpected node type: \" + node.nodeType);\n                        }\n                        node = node.nextSibling;\n                    }\n                    flushText();\n                    stage = this_1._validationStage = Stage.END_TAG;\n                    break;\n                }\n                case Stage.END_TAG: {\n                    // We've reached the end...\n                    if (curEl === this_1.root) {\n                        var eventResult = walker.end();\n                        if (eventResult instanceof Array) {\n                            this_1._processEventResult(eventResult, curEl, curEl.childNodes.length);\n                        }\n                        this_1._runDocumentValidation();\n                        this_1._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n                        this_1._partDone = 1;\n                        this_1._stop(this_1._errors.length > 0 ? WorkingState.INVALID :\n                            WorkingState.VALID);\n                        this_1._cycleEntered--;\n                        return { value: false };\n                    }\n                    // we need it later\n                    var originalElement = curEl;\n                    var tagName = curEl.tagName;\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        // We just produce the name name we produced when we encountered the\n                        // start tag.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"endTag\", ename.ns, ename.name), curEl, curEl.childNodes.length);\n                    this_1._fireAndProcessEvent(walker, LEAVE_CONTEXT_EVENT, curEl, curEl.childNodes.length);\n                    // Go back to the parent\n                    this_1._previousChild = curEl;\n                    // We are never without a parentNode here.\n                    // tslint:disable-next-line:no-non-null-assertion\n                    this_1._curEl = curEl = curEl.parentNode;\n                    var nextDone = this_1._partDone;\n                    if (curEl !== this_1.root) {\n                        stack.shift();\n                        var first = stack[0];\n                        nextDone = first.partDone += portion;\n                        portion = first.portion;\n                    }\n                    this_1._setWorkingState(WorkingState.WORKING, nextDone);\n                    this_1._setNodeProperty(originalElement, \"EventIndexAfter\", this_1._validationEvents.length);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._cycleEntered--;\n                    return { value: true };\n                }\n                // break; would be unreachable\n                default:\n                    throw new Error(\"unexpected state\");\n            }\n        };\n        var this_1 = this;\n        stage_change: while (true) {\n            var state_1 = _loop_1();\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n            switch (state_1) {\n                case \"continue-stage_change\": continue stage_change;\n            }\n        }\n    };\n    /**\n     * Stops background validation.\n     */\n    Validator.prototype.stop = function () {\n        this._stop();\n    };\n    /**\n     * This private method takes an argument that allows setting the working state\n     * to a specific value. This is useful to reduce the number of\n     * ``state-update`` events emitted when some internal operations are\n     * performed. The alternative would be to perform a state change before or\n     * after the call to ``stop``, which would result in more events being\n     * emitted.\n     *\n     * If the parameter is unused, then the logic is that if we were not yet in a\n     * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n     *\n     * @param state The state with which to stop.\n     */\n    Validator.prototype._stop = function (state) {\n        if (this._timeoutId !== undefined) {\n            clearTimeout(this._timeoutId);\n        }\n        this._timeoutId = undefined;\n        if (state === undefined) {\n            // We are stopping prematurely, update the state\n            if (this._workingState === WorkingState.WORKING) {\n                this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n            }\n        }\n        else {\n            this._setWorkingState(state, this._partDone);\n        }\n    };\n    /**\n     * Run document-level validation that cannot be modeled by Relax NG.  The\n     * default implementation does nothing. Deriving classes may override it to\n     * call [[_processError]].\n     */\n    Validator.prototype._runDocumentValidation = function () { }; // tslint:disable-line: no-empty\n    /**\n     * Restarts validation from a specific point. After the call returns, the\n     * background validation will be in effect. (So calling it on a stopped\n     * validator has the side effect of starting it.)\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.restartAt = function (node) {\n        this.resetTo(node);\n        this.start();\n    };\n    /**\n     * Reset validation to continue from a certain point.\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.resetTo = function (node) {\n        // We use `this._resetting` to avoid a costly reinitialization if this\n        // method is called twice in a row before any work has had a chance to be\n        // done.\n        if (!this._resetting) {\n            this._resetting = true;\n            this._resetTo(node);\n        }\n    };\n    Validator.prototype._erase = function (el) {\n        this._clearNodeProperties(el);\n        var child = el.firstElementChild;\n        while (child !== null) {\n            this._erase(child);\n            child = child.nextElementSibling;\n        }\n    };\n    /**\n     * Resets validation to continue from a specific point. Any further work done\n     * by the validator will start from the point specified.\n     *\n     * @param node The element to start validation from.\n     *\n     * @emits module:validator~Validator#reset-errors\n     */\n    Validator.prototype._resetTo = function (node) {\n        // An earlier implementation was trying to be clever and to avoid restarting\n        // much earlier than strictly needed. That ended up being more costly than\n        // doing this primitive restart from 0 no matter what. Eventually, Validator\n        // should be updated so that on large documents, restarting from a location\n        // towards the end does not require revalidating the whole document. For\n        // now, since wed is used for smallish documents, it would be a premature\n        // optimization.\n        this._erase(this.root);\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationWalker = this.schema.newWalker();\n        this._validationEvents = [];\n        this._curEl = this.root;\n        this._partDone = 0;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        /**\n         * Tells the listener that it must reset its list of errors.\n         *\n         * @event module:validator~Validator#reset-errors\n         * @type {Object}\n         * @property {integer} at The index of the first error that must\n         * be deleted. This error and all those after it must be deleted.\n         */\n        this._events._emit(\"reset-errors\", { at: 0 });\n    };\n    /**\n     * Sets the working state of the validator. Emits a \"state-update\" event if\n     * the state has changed.\n     *\n     * @param newState The new state of the validator.\n     *\n     * @param newDone The new portion of work done.\n     *\n     * @emits module:validator~Validator#state-update\n     */\n    Validator.prototype._setWorkingState = function (newState, newDone) {\n        var changed = false;\n        if (this._workingState !== newState) {\n            this._workingState = newState;\n            changed = true;\n        }\n        if (this._partDone !== newDone) {\n            this._partDone = newDone;\n            changed = true;\n        }\n        if (changed) {\n            /**\n             * Tells the listener that the validator has changed state.\n             *\n             * @event module:validator~Validator#state-update\n             */\n            this._events._emit(\"state-update\", { state: newState, partDone: newDone });\n        }\n    };\n    /**\n     * Gets the validator working state.\n     *\n     * @returns The working state\n     */\n    Validator.prototype.getWorkingState = function () {\n        return {\n            state: this._workingState,\n            partDone: this._partDone,\n        };\n    };\n    Object.defineProperty(Validator.prototype, \"errors\", {\n        /**\n         * The current set of errors.\n         */\n        get: function () {\n            return this._errors.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Processes the result of firing a tag event. It will emit an \"error\"\n     * event for each error.\n     *\n     * @param results The results of the walker's ``fireEvent`` call.\n     *\n     * @param node The data node to which the result belongs.\n     *\n     * @param index The index into ``node`` to which the result belongs.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processEventResult = function (results, node, index) {\n        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n            var result = results_1[_i];\n            this._processError({ error: result, node: node, index: index });\n        }\n    };\n    /**\n     * This method should be called whenever a new error is detected. It\n     * records the error and emits the corresponding event.\n     *\n     * @param error The error found.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processError = function (error) {\n        var _this = this;\n        /**\n         * We don't make this a method because it should only be called from\n         * ``_processError``. The way we generate new ID values works **only**\n         * because we push a new error in the list when there's no ID already set.\n         *\n         * Ensure the node has an error ID and return it. The error ID is the number\n         * set on the ``ErrorId`` property. If the node has no ID set yet, we assign\n         * one and return the new value. Otherwise, the old value is returned.\n         *\n         * @param node The node of interest.\n         *\n         * @returns The error ID.\n         */\n        var ensureErrorId = function (nodeGettingId) {\n            var oldId = _this.getNodeProperty(nodeGettingId, \"ErrorId\");\n            if (oldId === undefined) {\n                // The length of the error array at the time of first calling this\n                // function is good enough to serve as an ID.\n                oldId = _this._errors.length;\n                _this._setNodeProperty(nodeGettingId, \"ErrorId\", oldId);\n            }\n            return oldId;\n        };\n        // We must first check whether we've seen this error before, and avoid\n        // recording it again if we've seen it. This could happen when\n        // ``_getWalkerAt`` is used, because the validator may repeat firing events\n        // and processing the associated errors. We cannot just turn off error\n        // processing when ``_getWalkerAt`` is used because it may be used in cases\n        // where we are legitimately advancing the state of validation (rather than\n        // going over old stuff).\n        var node = error.node;\n        var errorId = node == null ? \"\" : String(ensureErrorId(node));\n        var key = errorId + \",\" + error.error.toString();\n        var alreadySeen = this._errorsSeen[key];\n        // We want to do a strict compare with true to handle ``undefined``.\n        if (alreadySeen !== true) {\n            this._errorsSeen[key] = true;\n            this._errors.push(error);\n            /**\n             * Tells the listener that an error has occurred.\n             *\n             * @event module:validator~Validator#error\n             * @type {Object}\n             * @property {Object} error The validation error.\n             * @property {Node} node The node where the error occurred.\n             * @property {integer} index The index in this node.\n             */\n            this._events._emit(\"error\", error);\n        }\n    };\n    /**\n     * Fires all the attribute events for a given element.\n     */\n    Validator.prototype._fireAttributeEvents = function (walker, el) {\n        // Find all attributes, fire events for them.\n        var attributes = el.attributes;\n        // tslint:disable-next-line:prefer-for-of\n        for (var i = 0; i < attributes.length; ++i) {\n            var attr = attributes[i];\n            // Skip those attributes which are namespace attributes.\n            if ((attr.name === \"xmlns\") ||\n                (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n                continue;\n            }\n            if (this._fireAttributeNameEvent(walker, el, attr)) {\n                this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeValue\", attr.value), attr, 0);\n            }\n        }\n    };\n    /**\n     * Fires an attributeName event. If the attribute name is in a namespace and\n     * cannot be resolved, the event is not fired.\n     *\n     * @returns True if the event was actually fired, false if not.\n     */\n    Validator.prototype._fireAttributeNameEvent = function (walker, el, attr) {\n        var attrName = attr.name;\n        var ename = walker.resolveName(attrName, true);\n        if (ename === undefined) {\n            this._processError({ error: new salve_1.ValidationError(\"cannot resolve attribute name \" + attrName), node: attr, index: 0 });\n            return false;\n        }\n        this._setPossibleDueToWildcard(attr, walker, \"attributeName\", ename.ns, ename.name);\n        this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeName\", ename.ns, ename.name), attr, 0);\n        return true;\n    };\n    /**\n     * Convenience method to fire events.\n     *\n     * @param walker The walker on which to fire events.\n     *\n     * @param event The event to fire.\n     *\n     * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n     * can be undefined for events that have no location associated with them.\n     *\n     * @param ix The index into ``el`` associated with this event, or a ``Node``\n     * which must be a child of ``el``. The index will be computed from the\n     * location of the child passed as this parameter in ``el``.\n     */\n    Validator.prototype._fireAndProcessEvent = function (walker, event, el, ix) {\n        this._validationEvents.push(event);\n        var eventResult = walker.fireEvent(event);\n        if (eventResult instanceof Array) {\n            if (el != null && ix !== undefined && typeof ix !== \"number\") {\n                ix = _indexOf(el.childNodes, ix);\n            }\n            this._processEventResult(eventResult, el, ix);\n        }\n    };\n    /**\n     * Force an immediate validation which is guaranteed to go at least up to the\n     * point specified by ``container, index``, exclusively. These parameters are\n     * interpreted in the same way a DOM caret is.\n     *\n     * If the validation has not yet reached the location specified, validation\n     * will immediately be performed to reach the point. If the validation has\n     * already reached this point, then this call is a no-op.\n     *\n     * There is one exception in the way the ``container, index`` pair is\n     * interpreted. If the container is the ``root`` that was passed when\n     * constructing the Validator, then setting ``index`` to a negative value will\n     * result in the validation validating all elements **and** considering the\n     * document complete. So unclosed tags or missing elements will be\n     * reported. Otherwise, the validation goes up the ``index`` but considers the\n     * document incomplete, and won't report the errors that are normally reported\n     * at the end of a document. For instance, unclosed elements won't be\n     * reported.\n     *\n     * @param container The location up to where to validate.\n     *\n     * @param index The location up to where to validate.\n     *\n     * @param attributes Whether we are interested to validate up to and including\n     * the attribute events of the node pointed to by ``container, index``. The\n     * validation ends before leaving the start tag.\n     *\n     * @throws {Error} If ``container`` is not of element or text type.\n     */\n    Validator.prototype._validateUpTo = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to validate after attributes but before \" +\n                \"the end of the start tag on a \" +\n                \"node which is not an element node\");\n        }\n        // Set these to reasonable defaults. The rest of the code is dedicated to\n        // changing these values to those necessary depending on specifics of what\n        // is passed to the method.\n        var toInspect = container;\n        var dataKey = \"EventIndexAfter\";\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (attributes) {\n                dataKey = \"EventIndexAfterAttributes\";\n                toInspect = container.childNodes[index];\n            }\n            else if (index === 0) {\n                // We're before the top element, no events to fire.\n                return;\n            }\n            // default values of toInspect and dataKey are what we want\n        }\n        else {\n            if (isAttr(container)) {\n                toInspect = container.ownerElement;\n                dataKey = \"EventIndexBeforeAttributes\";\n            }\n            else {\n                switch (container.nodeType) {\n                    case Node.TEXT_NODE:\n                        toInspect = container.previousElementSibling;\n                        if (toInspect === null) {\n                            // tslint:disable-next-line:no-non-null-assertion\n                            toInspect = container.parentNode;\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    case Node.ELEMENT_NODE:\n                    case Node.DOCUMENT_FRAGMENT_NODE:\n                    case Node.DOCUMENT_NODE:\n                        var node = container.childNodes[index];\n                        var prev = node === undefined ?\n                            container.lastElementChild :\n                            // It may not be an element, in which case we get \"undefined\".\n                            node.previousElementSibling;\n                        if (attributes) {\n                            dataKey = \"EventIndexAfterAttributes\";\n                            toInspect = node;\n                        }\n                        else if (prev !== null) {\n                            toInspect = prev;\n                        }\n                        else {\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    default:\n                        throw new Error(\"unexpected node type: \" + container.nodeType);\n                }\n            }\n        }\n        while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n            this._cycle();\n        }\n    };\n    /**\n     * Gets the walker which would represent the state of parsing at the point\n     * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n     * of how these parameters are interpreted.\n     *\n     * **The walker returned by this function is not guaranteed to be a new\n     *   instance. Callers should not modify the walker returned but instead clone\n     *   it.**\n     *\n     * @param container\n     *\n     * @param index\n     *\n     * @param attributes Whether we are interested to validate up to but not\n     * including the attribute events of the node pointed to by ``container,\n     * index``. If ``true`` the walker returned will have all events fired on it\n     * up to, and including, those attribute events on the element pointed to by\n     * ``container, index``.\n     *\n     * @returns The walker.\n     *\n     * @throws {EventIndexException} If it runs out of events or computes an event\n     * index that makes no sense.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._getWalkerAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to get a walker for attribute events on a \" +\n                \"node which is not an element node\");\n        }\n        // Make sure we have the data we need.\n        this._validateUpTo(container, index, attributes);\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (!attributes) {\n                // We're before the top element, no events to fire.\n                if (index === 0) {\n                    return this.schema.newWalker();\n                }\n                // _validateUpTo ensures that the current walker held by the validator\n                // is what we want. We can just return it here because it is the\n                // caller's reponsibility to either not modify it or clone it.\n                return this._validationWalker;\n            }\n        }\n        var walker;\n        function fireTextEvent(textNode) {\n            if (walker === undefined) {\n                throw new Error(\"calling fireTextEvent without a walker\");\n            }\n            walker.fireEvent(new salve_1.Event(\"text\", textNode.data));\n        }\n        if (isAttr(container)) {\n            var el = container.ownerElement;\n            walker = this.readyWalker(\n            // tslint:disable-next-line:no-non-null-assertion\n            this.getNodeProperty(el, \"EventIndexBeforeAttributes\"));\n            // Don't fire on namespace attributes.\n            if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n                walker = walker.clone();\n                this._fireAttributeNameEvent(walker, el, container);\n            }\n        }\n        else {\n            switch (container.nodeType) {\n                case Node.TEXT_NODE: {\n                    var prev = container.previousElementSibling;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (prev !== null) {\n                        getFrom = prev;\n                        propName = \"EventIndexAfter\";\n                    }\n                    else {\n                        // tslint:disable-next-line:no-non-null-assertion\n                        getFrom = container.parentNode;\n                        propName = \"EventIndexAfterStart\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    // We will attempt to fire a text event if our location is inside the\n                    // current text node.\n                    //\n                    // A previous version of this code was also checking whether there is a\n                    // text node between this text node and prev but this cannot happen\n                    // because the tree on which validation is performed cannot have two\n                    // adjacent text nodes. It was also checking whether there was a _text\n                    // element between prev and this text node but this also cannot happen.\n                    if (index > 0) {\n                        walker = walker.clone();\n                        fireTextEvent(container);\n                    }\n                    break;\n                }\n                case Node.ELEMENT_NODE:\n                case Node.DOCUMENT_NODE:\n                case Node.DOCUMENT_FRAGMENT_NODE: {\n                    var node = container.childNodes[index];\n                    var prev = void 0;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (!attributes) {\n                        prev = node === undefined ? container.lastElementChild :\n                            node.previousElementSibling;\n                        if (prev !== null) {\n                            getFrom = prev;\n                            propName = \"EventIndexAfter\";\n                        }\n                        else {\n                            getFrom = container;\n                            propName = \"EventIndexAfterStart\";\n                        }\n                    }\n                    else {\n                        getFrom = node;\n                        propName = \"EventIndexAfterAttributes\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    if (!attributes) {\n                        // We will attempt to fire a text event if another text node appeared\n                        // between the node we care about and the element just before it.\n                        var prevSibling = node != null ? node.previousSibling : null;\n                        if (prevSibling !== null &&\n                            // If the previous sibling is the same as the previous *element*\n                            // sibbling, then there is nothing *between* that we need to take\n                            // care of.\n                            prevSibling !== prev) {\n                            if (prevSibling.nodeType === Node.TEXT_NODE) {\n                                walker = walker.clone();\n                                fireTextEvent(prevSibling);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(\"unexpected node type: \" + container.nodeType);\n            }\n        }\n        return walker;\n    };\n    Validator.prototype.readyWalker = function (eventIndex) {\n        //\n        // Perceptive readers will notice that the caching being done here could be\n        // more aggressive. It turns out that the cases where we have to clone the\n        // walker after getting it from the cache are not that frequently used, so\n        // there is little to gain from being more aggressive. Furthermore, it is\n        // likely that the caching system will change when we implement a saner way\n        // to reset validation and segment large documents into smaller chunks.\n        //\n        if (eventIndex === undefined) {\n            throw new EventIndexException();\n        }\n        var cache = this._walkerCache;\n        var max = this._walkerCacheMax;\n        var walker = cache[eventIndex];\n        if (walker !== undefined) {\n            return walker;\n        }\n        //\n        // Scan the cache for a walker we could use... rather than start from zero.\n        //\n        // There is no point in trying to be clever by using this._walkerCacheGap to\n        // start our search. If _getWalkerAt is called with decreasing positions in\n        // the document, then the gap is meaningless for our search. (Such scenario\n        // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n        // cannot assume that it won't happen.)\n        //\n        // Also, the following approach is a bit crude but trying to be clever with\n        // Object.keys() and then searching through a sorted list does not yield an\n        // appreciable improvement. Maybe on very large documents it would but this\n        // module will have to be redesigned to tackle that so there's no point now\n        // to be cleverer than this. We also tested using a sparse Array for the\n        // cache and got visibly worse performance. And we tested to see if a flag\n        // indicating if the cache has anything in it would help avoid doing a long\n        // search but it maked things worse. Basically, it seems that the typical\n        // usage pattern of _getWalkerAt is such that it will usually be called in\n        // increasing order of position in the document.\n        //\n        var searchIx = eventIndex;\n        if (searchIx >= max) {\n            searchIx = max;\n            walker = cache[searchIx];\n        }\n        else {\n            while (walker === undefined && --searchIx >= 0) {\n                walker = cache[searchIx];\n            }\n        }\n        if (walker !== undefined) {\n            walker = walker.clone();\n        }\n        else {\n            walker = this.schema.newWalker();\n            searchIx = 0;\n        }\n        for (var ix = searchIx; ix < eventIndex; ++ix) {\n            walker.fireEvent(this._validationEvents[ix]);\n        }\n        // This is a bit arbitrary to find a balance between caching too much\n        // information and spending too much time computing walkers.\n        if (eventIndex - searchIx >= this._walkerCacheGap) {\n            cache[eventIndex] = walker;\n            this._walkerCacheMax = Math.max(eventIndex, max);\n        }\n        return walker;\n    };\n    /**\n     * Returns the set of possible events for the location specified by the\n     * parameters.\n     *\n     * @param container Together with ``index`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param index Together with ``container`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param attributes\n     *\n     * @returns A set of possible events.\n     */\n    Validator.prototype.possibleAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        var walker = this._getWalkerAt(container, index, attributes);\n        // Calling possible does not *modify* the walker.\n        return walker.possible();\n    };\n    /**\n     * Finds the locations in a node where a certain validation event is\n     * possible.\n     *\n     * @param container A node.\n     *\n     * @param event The event to search for. The event should be presented in the\n     * same format used for ``fireEvent``.\n     *\n     * @returns The locations in ``container`` where the event is possible.\n     */\n    Validator.prototype.possibleWhere = function (container, event) {\n        var ret = [];\n        for (var index = 0; index <= container.childNodes.length; ++index) {\n            var possible = this.possibleAt(container, index);\n            if (possible.has(event)) {\n                ret.push(index);\n            }\n            else if (event.params[0] === \"enterStartTag\" ||\n                event.params[0] === \"attributeName\") {\n                // In the case where we have a name pattern as the 2nd parameter, and\n                // this pattern can be complex or have wildcards, then we have to check\n                // all events one by one for a name pattern match. (While enterStartTag,\n                // endTag and attributeName all have name patterns, endTag cannot be\n                // complex or allow wildcards because what it allows much match the tag\n                // that started the current element.\n                for (var _i = 0, _a = possible.toArray(); _i < _a.length; _i++) {\n                    var candidate = _a[_i];\n                    if (candidate.params[0] === event.params[0] &&\n                        candidate.params[1].match(event.params[1], event.params[2])) {\n                        ret.push(index);\n                        break;\n                    }\n                }\n            }\n        }\n        return ret;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidate = function (container, index, toParse) {\n        var clone;\n        if (toParse instanceof Array) {\n            clone = container.ownerDocument.createDocumentFragment();\n            for (var _i = 0, toParse_1 = toParse; _i < toParse_1.length; _i++) {\n                var child = toParse_1[_i];\n                clone.insertBefore(child.cloneNode(true), null);\n            }\n        }\n        else {\n            clone = toParse.cloneNode(true);\n        }\n        var root = container.ownerDocument.createElement(\"div\");\n        root.insertBefore(clone, null);\n        return this.speculativelyValidateFragment(container, index, root);\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse. See above.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidateFragment = function (container, index, toParse) {\n        // This is useful for pure-JS code that may be calling this.\n        if (toParse.nodeType !== Node.ELEMENT_NODE) {\n            throw new Error(\"toParse is not an element\");\n        }\n        // We create a new validator with the proper state to parse the fragment\n        // we've been given.\n        var dup = new Validator(this.schema, toParse);\n        // We have to clone the walker to prevent messing up the internal cache.\n        dup._validationWalker = this._getWalkerAt(container, index).clone();\n        // This forces validating the whole fragment\n        dup._validateUpTo(toParse, toParse.childNodes.length);\n        if (dup._errors.length !== 0) {\n            return dup._errors;\n        }\n        return false;\n    };\n    /**\n     * Obtain the validation errors that belong to a specific node.\n     *\n     * The term \"that belong to\" has a specific meaning here:\n     *\n     * - An error in the contents of an element belongs to the element whose\n     *   contents are incorrect. For instance if in the sequence\n     *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n     *   error belongs to the node for the element ``foo``, not the node for the\n     *   element ``blip``.\n     *\n     * - Attribute errors belong to the element node to which the attributes\n     *   belong.\n     *\n     * @param node The node whose errors we want to get.\n     *\n     * @returns The errors.\n     */\n    Validator.prototype.getErrorsFor = function (node) {\n        var parent = node.parentNode;\n        if (parent === null) {\n            throw new Error(\"node without a parent!\");\n        }\n        // Validate to after the closing tag of the node.\n        this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n        var ret = [];\n        for (var _i = 0, _a = this._errors; _i < _a.length; _i++) {\n            var errorData = _a[_i];\n            if (errorData.node === node) {\n                ret.push(errorData);\n            }\n        }\n        return ret;\n    };\n    /**\n     * Sets a flag indicating whether a node is possible only due to a name\n     * pattern wildcard, and emits an event if setting the flag is a change from\n     * the previous value of the flag. It does this by inspecting the event that\n     * would be fired when ``node`` is validated. The parameters ``eventName``,\n     * ``ns`` and ``name`` are used to determine what we are looking for among\n     * possible events.\n     *\n     * @param node The node we want to check.\n     *\n     * @param walker A walker whose last fired event is the one just before the\n     * event that would be fired when validating ``node``.\n     *\n     * @param eventName The event name we are interested in.\n     *\n     * @param ns The namespace to use with the event.\n     *\n     * @param name The name to use with the event.\n     *\n     * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n     *\n     */\n    Validator.prototype._setPossibleDueToWildcard = function (node, walker, eventName, ns, name) {\n        var previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n        var possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n        this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n        if (previous === undefined || previous !== possible) {\n            /**\n             * Tells the listener that a node's flag indicating whether it is possible\n             * only due to a wildcard has changed.\n             *\n             * @event module:validator~Validator#possible-due-to-wildcard-change\n             *\n             * @type {Node} The node whose flag has changed.\n             */\n            this._events._emit(\"possible-due-to-wildcard-change\", node);\n        }\n    };\n    /**\n     * Resolve a qualified name to an expanded name. See\n     * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n     * takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param name The name to rresolve.\n     *\n     * @param attributes Whether the name is an attribute's name.\n     *\n     * @return The resolved name.\n     */\n    Validator.prototype.resolveNameAt = function (container, index, name, attribute) {\n        if (attribute === void 0) { attribute = false; }\n        // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n        // its ``attribute`` parameter ``false``.\n        return this._getWalkerAt(container, index).resolveName(name, attribute);\n    };\n    /**\n     * Unresolve an expanded name to a qualified name. See\n     * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n     * method takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param uri The URI to unresolve.\n     *\n     * @param name The name to unresolve.\n     *\n     * @return The unresolved name.\n     */\n    Validator.prototype.unresolveNameAt = function (container, index, uri, name) {\n        return this._getWalkerAt(container, index).unresolveName(uri, name);\n    };\n    return Validator;\n}());\nexports.Validator = Validator;\n/**\n * Exception to be raised if we cannot parse a string as an XML document.\n */\nvar ParsingError = /** @class */ (function (_super) {\n    __extends(ParsingError, _super);\n    /**\n     * @param xmlErrors A string that contains the errors reported. The library\n     * here simply serializes the error document produced by the parser.\n     */\n    function ParsingError(xmlErrors) {\n        var _this = _super.call(this) || this;\n        _this.xmlErrors = xmlErrors;\n        var err = new Error(\"cannot parse\");\n        _this.name = \"ParsingError\";\n        _this.stack = err.stack;\n        _this.message = err.message;\n        tools_1.fixPrototype(_this, ParsingError);\n        return _this;\n    }\n    return ParsingError;\n}(Error));\nexports.ParsingError = ParsingError;\n// tslint:disable-next-line:no-http-string\nvar XML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\nvar MOZILLA_NAMESPACE = \n// tslint:disable-next-line:no-http-string\n\"http://www.mozilla.org/newlayout/xml/parsererror.xml\";\n/**\n * A utility function that detects whether the parsing fails and throws an error\n * in such case.\n *\n * Note that if you pass a well-formed and correctly structured error document\n * to this function, the result will look like an error, even though it was\n * parsed properly. Given the way ``DOMParser`` reports errors, this cannot be\n * helped.\n *\n * @param source The XML to parse.\n *\n * @param win The window from which to create a ``DOMParser``.\n *\n * @returns The parsed document.\n *\n * @throws {ParsingError} If the source cannot be parsed.\n */\nfunction safeParse(source, win) {\n    if (win === void 0) { win = window; }\n    var parser = new win.DOMParser();\n    var doc;\n    try {\n        doc = parser.parseFromString(source, \"text/xml\");\n    }\n    catch (ex) {\n        // On IE10/11 bad source will cause a SyntaxError.\n        if (ex.name !== \"SyntaxError\" || ex.code !== 12) {\n            throw ex;\n        }\n        throw new ParsingError(\"no error information available\");\n    }\n    var child = doc.firstChild;\n    while (child !== null && child.nodeType !== Node.ELEMENT_NODE) {\n        child = child.nextSibling;\n    }\n    var chromeTest = doc.querySelector(\"html>body>parsererror\");\n    // A DOMParser will generate a document that contains a description of the\n    // error(s). Unfortunately, this document is not consistently generated across\n    // browsers.\n    //\n    // However, running the code through Browser Stack on Chrome, Firefox, IE\n    // 10-100, Edge, Opera, and Safari that they boil down either to the Chrome\n    // case or the Firefox case.\n    if (\n    // Firefox\n    (child !== null &&\n        child.tagName === \"parsererror\" &&\n        child.namespaceURI === MOZILLA_NAMESPACE) ||\n        // Chrome\n        (chromeTest !== null && chromeTest.namespaceURI === XML_NAMESPACE)) {\n        throw new ParsingError(doc.documentElement.outerHTML);\n    }\n    return doc;\n}\nexports.safeParse = safeParse;\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/main.js\n// module id = 0\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"salve\"\n// module id = 1\n// module chunks = 0 1","\"use strict\";\n/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this._eventListeners = Object.create(null);\n        this._generalListeners = [];\n        this._trace = false;\n    }\n    EventEmitter.prototype.addEventListener = function (eventName, listener) {\n        if (eventName === \"*\") {\n            this._generalListeners.push(listener);\n        }\n        else {\n            var listeners = this._eventListeners[eventName];\n            if (listeners === undefined) {\n                listeners = this._eventListeners[eventName] = [];\n            }\n            listeners.push(listener);\n        }\n    };\n    EventEmitter.prototype.addOneTimeEventListener = function (eventName, listener) {\n        var _this = this;\n        // We perform casts as any here to indicate to TypeScript that it is\n        // safe to pass this stub.\n        var me = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.removeEventListener(eventName, me);\n            return listener.apply(_this, args);\n        };\n        this.addEventListener(eventName, me);\n        return me;\n    };\n    EventEmitter.prototype.removeEventListener = function (eventName, listener) {\n        var listeners = (eventName === \"*\") ?\n            this._generalListeners :\n            this._eventListeners[eventName];\n        if (listeners === undefined) {\n            return;\n        }\n        var index = listeners.lastIndexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    EventEmitter.prototype.removeAllListeners = function (eventName) {\n        if (eventName === \"*\") {\n            this._generalListeners = [];\n        }\n        else {\n            this._eventListeners[eventName] = [];\n        }\n    };\n    /**\n     * This is the function that the class using this mixin must call to\n     * indicate that an event has occurred.\n     *\n     * @param eventName The name of the event to emit.\n     *\n     * @param ev The event data to provide to handlers. The type can be\n     * anything.\n     */\n    EventEmitter.prototype._emit = function (eventName, ev) {\n        if (this._trace) {\n            // tslint:disable-next-line: no-console\n            console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n        }\n        {\n            var listeners = this._generalListeners;\n            if (listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n                    var listener = listeners_1[_i];\n                    var ret = listener.call(undefined, eventName, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n        {\n            var listeners = this._eventListeners[eventName];\n            if (listeners !== undefined && listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _a = 0, listeners_2 = listeners; _a < listeners_2.length; _a++) {\n                    var listener = listeners_2[_a];\n                    var ret = listener.call(undefined, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n//  LocalWords:  Mangalam MPL Dubeau noop ev mixin\n//# sourceMappingURL=event_emitter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/event_emitter.js\n// module id = 2\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\nfunction fixPrototype(obj, parent) {\n    var oldProto = Object.getPrototypeOf !== undefined ?\n        Object.getPrototypeOf(obj) :\n        obj.__proto__;\n    if (oldProto !== parent) {\n        if (Object.setPrototypeOf !== undefined) {\n            Object.setPrototypeOf(obj, parent.prototype);\n        }\n        else {\n            obj.__proto__ = parent.prototype;\n        }\n    }\n}\nexports.fixPrototype = fixPrototype;\n//# sourceMappingURL=tools.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/tools.js\n// module id = 3\n// module chunks = 0 1"],"sourceRoot":""}