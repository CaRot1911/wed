{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///salve-dom.min.js","webpack:///webpack/bootstrap c40b253cb9911ad5a8e1?e1c1","webpack:///./build/dist/lib/event_emitter.js?99a2","webpack:///./build/dist/lib/tools.js?25f8","webpack:///external \"salve\"?df10","webpack:///./build/dist/lib/main.js?f18c"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","EventEmitter","_eventListeners","create","_generalListeners","_trace","addEventListener","eventName","listener","push","listeners","undefined","addOneTimeEventListener","_this","me","args","_i","arguments","length","removeEventListener","apply","index","lastIndexOf","splice","removeAllListeners","_emit","ev","console","log","slice","listeners_1","ret","_a","listeners_2","fixPrototype","obj","parent","getPrototypeOf","__proto__","setPrototypeOf","_indexOf","needle","Array","indexOf","isAttr","it","attrNodeType","Node","ATTRIBUTE_NODE","Attr","nodeType","isPossibleDueToWildcard","walker","ns","evs","possible","toArray","matched","evs_1","params","namePattern","matches","match","wildcardMatch","__extends","extendStatics","b","__","constructor","salve_1","event_emitter_1","tools_1","Stage","WorkingState","ProgressState","partDone","portion","ENTER_CONTEXT_EVENT","Event","LEAVE_START_TAG_EVENT","LEAVE_CONTEXT_EVENT","EventIndexException","_super","Error","Validator","schema","options","_cycleEntered","_timeout","_maxTimespan","_resetting","_errors","_boundWrapper","_workWrapper","bind","_validationEvents","_workingState","INCOMPLETE","_partDone","_validationStage","CONTENTS","_previousChild","_validationStack","_walkerCache","_walkerCacheMax","_prefix","_walkerCacheGap","_events","keys","keys_1","key","prefix","_curEl","_setNodeProperty","_setWorkingState","_validationWalker","newWalker","events","makeKey","getNodeProperty","node","_clearNodeProperties","keys_2","start","_timeoutId","_stop","WORKING","setTimeout","getSchemaNamespaces","getNamespaces","getDocumentNamespaces","_process","attrIxLim","attributes","attrIx","attr","array","child","firstChild","ELEMENT_NODE","nextSibling","_work","startDate","Date","now","_cycle","stack","stage","_loop_1","curEl","this_1","START_TAG","unshift","_fireAndProcessEvent","tagName","parent_1","parentNode","curElIndex","childNodes","ename","resolveName","_processEventResult","ValidationError","EName","_setPossibleDueToWildcard","_fireAttributeEvents","textAccumulatorNode_1","textAccumulator_1","flushText","event_1","join","eventResult","fireEvent","parent_2","TEXT_NODE","data","childElementCount","COMMENT_NODE","END_TAG","end","_runDocumentValidation","INVALID","VALID","originalElement","nextDone","shift","first","stage_change","state_1","stop","state","clearTimeout","restartAt","resetTo","_resetTo","_erase","el","firstElementChild","nextElementSibling","at","newState","newDone","changed","getWorkingState","results","results_1","result","_processError","error","_fireAttributeNameEvent","attrName","event","ix","_validateUpTo","container","toInspect","dataKey","ownerElement","previousElementSibling","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","prev","lastElementChild","_getWalkerAt","fireTextEvent","textNode","readyWalker","clone","getFrom","propName","prevSibling","previousSibling","eventIndex","cache","max","searchIx","Math","possibleAt","possibleWhere","has","candidate","speculativelyValidate","toParse","ownerDocument","createDocumentFragment","toParse_1","insertBefore","cloneNode","createElement","speculativelyValidateFragment","dup","getErrorsFor","errorData","previous","resolveNameAt","attribute","unresolveNameAt","uri","unresolveName"],"mappings":"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","file":"salve-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"salve\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"salve\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salve-dom\"] = factory(require(\"salve\"));\n\telse\n\t\troot[\"salve-dom\"] = factory(root[\"salve\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"salve\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"salve\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salve-dom\"] = factory(require(\"salve\"));\n\telse\n\t\troot[\"salve-dom\"] = factory(root[\"salve\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        this._eventListeners = Object.create(null);\n        this._generalListeners = [];\n        this._trace = false;\n    }\n    EventEmitter.prototype.addEventListener = function (eventName, listener) {\n        if (eventName === \"*\") {\n            this._generalListeners.push(listener);\n        }\n        else {\n            var listeners = this._eventListeners[eventName];\n            if (listeners === undefined) {\n                listeners = this._eventListeners[eventName] = [];\n            }\n            listeners.push(listener);\n        }\n    };\n    EventEmitter.prototype.addOneTimeEventListener = function (eventName, listener) {\n        var _this = this;\n        // We perform casts as any here to indicate to TypeScript that it is\n        // safe to pass this stub.\n        var me = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.removeEventListener(eventName, me);\n            return listener.apply(_this, args);\n        };\n        this.addEventListener(eventName, me);\n        return me;\n    };\n    EventEmitter.prototype.removeEventListener = function (eventName, listener) {\n        var listeners = (eventName === \"*\") ?\n            this._generalListeners :\n            this._eventListeners[eventName];\n        if (listeners === undefined) {\n            return;\n        }\n        var index = listeners.lastIndexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    EventEmitter.prototype.removeAllListeners = function (eventName) {\n        if (eventName === \"*\") {\n            this._generalListeners = [];\n        }\n        else {\n            this._eventListeners[eventName] = [];\n        }\n    };\n    /**\n     * This is the function that the class using this mixin must call to\n     * indicate that an event has occurred.\n     *\n     * @param eventName The name of the event to emit.\n     *\n     * @param ev The event data to provide to handlers. The type can be\n     * anything.\n     */\n    EventEmitter.prototype._emit = function (eventName, ev) {\n        if (this._trace) {\n            // tslint:disable-next-line: no-console\n            console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n        }\n        {\n            var listeners = this._generalListeners;\n            if (listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n                    var listener = listeners_1[_i];\n                    var ret = listener.call(undefined, eventName, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n        {\n            var listeners = this._eventListeners[eventName];\n            if (listeners !== undefined && listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _a = 0, listeners_2 = listeners; _a < listeners_2.length; _a++) {\n                    var listener = listeners_2[_a];\n                    var ret = listener.call(undefined, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n//  LocalWords:  Mangalam MPL Dubeau noop ev mixin\n\n//# sourceMappingURL=event_emitter.js.map\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\nfunction fixPrototype(obj, parent) {\n    var oldProto = Object.getPrototypeOf !== undefined ?\n        Object.getPrototypeOf(obj) :\n        obj.__proto__;\n    if (oldProto !== parent) {\n        if (Object.setPrototypeOf !== undefined) {\n            Object.setPrototypeOf(obj, parent.prototype);\n        }\n        else {\n            obj.__proto__ = parent.prototype;\n        }\n    }\n}\nexports.fixPrototype = fixPrototype;\n\n//# sourceMappingURL=tools.js.map\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar salve_1 = __webpack_require__(2);\nvar event_emitter_1 = __webpack_require__(0);\nvar tools_1 = __webpack_require__(1);\nfunction _indexOf(parent, needle) {\n    return Array.prototype.indexOf.call(parent, needle);\n}\nfunction isAttr(it) {\n    var attrNodeType = Node.ATTRIBUTE_NODE;\n    // We check that ``attr_node_type`` is not undefined because eventually\n    // ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n    // could be testing ``undefined === undefined`` for objects which are not\n    // attributes, which would return ``true``. The function is not very strict\n    // but it should not be too lax either.\n    return it instanceof Attr ||\n        ((attrNodeType !== undefined) && (it.nodeType === attrNodeType));\n}\nexports.isAttr = isAttr;\n// validation_stage values\nvar Stage;\n(function (Stage) {\n    Stage[Stage[\"START_TAG\"] = 1] = \"START_TAG\";\n    Stage[Stage[\"CONTENTS\"] = 2] = \"CONTENTS\";\n    Stage[Stage[\"END_TAG\"] = 3] = \"END_TAG\";\n})(Stage || (Stage = {}));\n// Working state values\nvar WorkingState;\n(function (WorkingState) {\n    /**\n     * The validator is stopped but has not completed a validation pass yet.\n     */\n    WorkingState[WorkingState[\"INCOMPLETE\"] = 1] = \"INCOMPLETE\";\n    /**\n     * The validator is working on validating the document.\n     */\n    WorkingState[WorkingState[\"WORKING\"] = 2] = \"WORKING\";\n    /**\n     * The validator is stopped and has found the document invalid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"INVALID\"] = 3] = \"INVALID\";\n    /**\n     * The validator is stopped and has found the document valid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"VALID\"] = 4] = \"VALID\";\n})(WorkingState = exports.WorkingState || (exports.WorkingState = {}));\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nvar ProgressState = (function () {\n    function ProgressState(partDone, portion) {\n        this.partDone = partDone;\n        this.portion = portion;\n    }\n    return ProgressState;\n}());\n//\n// Note: the Validator class adds information to the Element nodes it\n// is working with by adding expando properties that start with\n// \"wed_event_\". This deemed acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to\n//   be open to third party software. Even if it were, the chance of a\n//   clash is small.\n//\n// * The values of the expando properties are primitives (not objects\n//   or other elements).\n//\n// * We don't care about browsers or situations where expando\n//   properties are not supported.\n//\n//\n// These are constants. So create them once rather than over and over\n// again.\n//\nvar ENTER_CONTEXT_EVENT = new salve_1.Event(\"enterContext\");\nvar LEAVE_START_TAG_EVENT = new salve_1.Event(\"leaveStartTag\");\nvar LEAVE_CONTEXT_EVENT = new salve_1.Event(\"leaveContext\");\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nvar EventIndexException = (function (_super) {\n    __extends(EventIndexException, _super);\n    function EventIndexException() {\n        var _this = _super.call(this, \"undefined event_index; _validateUpTo should have taken care of that\") || this;\n        tools_1.fixPrototype(_this, EventIndexException);\n        return _this;\n    }\n    return EventIndexException;\n}(Error));\n// This private utility function checks whether an event is possible\n// only because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker, eventName, ns, name) {\n    var evs = walker.possible().toArray();\n    var matched = false;\n    for (var _i = 0, evs_1 = evs; _i < evs_1.length; _i++) {\n        var ev = evs_1[_i];\n        if (ev.params[0] !== eventName) {\n            continue;\n        }\n        var namePattern = ev.params[1];\n        var matches = namePattern.match(ns, name);\n        // Keep track of whether it ever matched anything.\n        matched = matched || matches;\n        // We already know that it matches, and this is not merely due\n        // to a wildcard.\n        if (matches && !namePattern.wildcardMatch(ns, name)) {\n            return false;\n        }\n    }\n    // If it never matched any pattern at all, then we must return false.  If we\n    // get here and matched is true then it means that it matched all patterns due\n    // to wildcards.\n    return matched;\n}\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``'s ``constructTree``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nvar Validator = (function () {\n    function Validator(schema, root, options) {\n        if (options === void 0) { options = {}; }\n        this.schema = schema;\n        this.root = root;\n        this._cycleEntered = 0;\n        this._timeout = 200;\n        this._maxTimespan = 100;\n        this._resetting = false;\n        this._errors = [];\n        this._boundWrapper = this._workWrapper.bind(this);\n        // Validation state\n        this._validationEvents = [];\n        this._workingState = WorkingState.INCOMPLETE;\n        this._partDone = 0;\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationStack = [new ProgressState(0, 1)];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        this._prefix = \"salveDom\";\n        // The distance between walkers under which we skip saving a\n        // walker in the cache.\n        this._walkerCacheGap = 100;\n        this._events = new event_emitter_1.EventEmitter();\n        var keys = [\"timeout\", \"maxTimespan\",\n            \"walkerCacheGap\"];\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            var value = options[key];\n            if (value === undefined) {\n                continue;\n            }\n            if (value < 0) {\n                throw new Error(\"the value for \" + key + \" cannot be negative\");\n            }\n            this[\"_\" + key] = options[key];\n        }\n        if (options.prefix !== undefined) {\n            this._prefix = options.prefix;\n        }\n        this._curEl = this.root;\n        // This prevents an infinite loop when speculativelyValidate is\n        // called to validate a text node.\n        this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", this._validationEvents.length);\n        this._setWorkingState(WorkingState.INCOMPLETE, 0);\n        this._validationWalker = this.schema.newWalker();\n        this.events = this._events;\n    }\n    Validator.prototype.makeKey = function (key) {\n        return \"\" + this._prefix + key;\n    };\n    /**\n     * Function allowing to get a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype.getNodeProperty = function (node, key) {\n        return node[this.makeKey(key)];\n    };\n    /**\n     * Function allowing to set a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype._setNodeProperty = function (node, key, value) {\n        node[this.makeKey(key)] = value;\n    };\n    Validator.prototype._clearNodeProperties = function (node) {\n        var keys = [\n            \"EventIndexAfter\",\n            \"EventIndexAfterStart\",\n            \"EventIndexBeforeAttributes\",\n            \"EventIndexAfterAttributes\",\n            \"PossibleDueToWildcard\",\n        ];\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            delete node[this.makeKey(key)];\n        }\n    };\n    /**\n     * Starts the background validation process.\n     */\n    Validator.prototype.start = function () {\n        if (this._timeoutId !== undefined) {\n            this._stop(WorkingState.WORKING);\n        }\n        // When we call ``this.start``, we want the validation to start ASAP. So we\n        // do not use ``this._timeout`` here. However, we do not call\n        // ``this._workWrapper`` directly because we want to be able to call\n        // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n        // directly, we'd be calling this._cycle from inside this._cycle, which is\n        // results in an internal error.\n        this._timeoutId = setTimeout(this._boundWrapper, 0);\n    };\n    /**\n     * Get the namespaces defined in the schema passed to the\n     * Validator.\n     *\n     * @returns The namespaces known to the schema.\n     */\n    Validator.prototype.getSchemaNamespaces = function () {\n        return this.schema.getNamespaces();\n    };\n    /**\n     * Get the namespaces used in the document. This method does not cache its\n     * information and scan the whole document independently of the current\n     * validation status.\n     *\n     * @returns An object whose keys are namespace prefixes and values are lists\n     * of namespace URIs.  The values are lists because prefixes can be redefined\n     * in a document.\n     */\n    Validator.prototype.getDocumentNamespaces = function () {\n        var ret = {};\n        function _process(node) {\n            if (node === null) {\n                return;\n            }\n            var attrIxLim = node.attributes.length;\n            for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                var attr = node.attributes[attrIx];\n                if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n                    var key = attr.name.slice(6);\n                    var array = ret[key];\n                    if (array === undefined) {\n                        array = ret[key] = [];\n                    }\n                    array.push(attr.value);\n                }\n            }\n            var child = node.firstChild;\n            while (child !== null) {\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    _process(child);\n                }\n                child = child.nextSibling;\n            }\n        }\n        _process(this.root.firstChild);\n        return ret;\n    };\n    /**\n     * Convenience method. The bound version of this method\n     * (``this._boundWrapper``) is what is called by the timeouts to perform the\n     * background validation.\n     */\n    Validator.prototype._workWrapper = function () {\n        if (this._work()) {\n            this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n        }\n    };\n    /**\n     * Controller method for the background validation. Keeps the validator\n     * running only until done or until the maximum time span for one run\n     * of the validator is reached.\n     *\n     * @returns False if there is no more work to do. True otherwise.\n     */\n    Validator.prototype._work = function () {\n        var startDate = Date.now();\n        while (true) {\n            // Give a chance to other operations to work.\n            if ((this._maxTimespan > 0) &&\n                (Date.now() - startDate) >= this._maxTimespan) {\n                return true;\n            }\n            var ret = this._cycle();\n            if (!ret) {\n                return false;\n            }\n        }\n    };\n    /**\n     * Performs one cycle of validation. \"One cycle\" is an arbitrarily\n     * small unit of work.\n     *\n     * @returns False if there is no more work to be done. True otherwise.\n     *\n     * @throws {Error} When there is an internal error.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._cycle = function () {\n        var _this = this;\n        // If we got here after a reset, then we've finished resetting.  If we were\n        // not resetting, then this is a noop.\n        this._resetting = false;\n        //\n        // This check is meant to catch problems that could be hard to diagnose if\n        // wed or one of its modes had a bug such that `_cycle` is reentered from\n        // `_cycle`. This could happen during error processing, for instance. Error\n        // processing causes wed to process the errors, which causes changes in the\n        // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n        // execute something like `getErrorsFor`, which could cause `_cycle` to be\n        // reentered.\n        //\n        if (this._cycleEntered > 0) {\n            throw new Error(\"internal error: _cycle is being reentered\");\n        }\n        if (this._cycleEntered < 0) {\n            throw new Error(\"internal error: _cycleEntered negative\");\n        }\n        //\n        // IMPORTANT: This variable must be decremented before exiting this\n        // method. A try...finally statement is not used here because it would\n        // prevent some virtual machines from optimizing this function.\n        //\n        this._cycleEntered++;\n        var walker = this._validationWalker;\n        var stack = this._validationStack;\n        var events = this._validationEvents;\n        var portion = stack[0].portion;\n        var stage = this._validationStage;\n        var _loop_1 = function () {\n            var curEl = this_1._curEl;\n            switch (stage) {\n                case Stage.START_TAG: {\n                    // The logic is such that if we get here curEl must be an Element.\n                    curEl = curEl;\n                    stack.unshift(new ProgressState(this_1._partDone, portion));\n                    // Handle namespace declarations. Yes, this must happen before we deal\n                    // with the tag name.\n                    this_1._fireAndProcessEvent(walker, ENTER_CONTEXT_EVENT, curEl, 0);\n                    var attrIxLim = curEl.attributes.length;\n                    for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                        var attr = curEl.attributes[attrIx];\n                        if (attr.name === \"xmlns\") {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", \"\", attr.value), curEl, 0);\n                        }\n                        else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", attr.name.slice(6), attr.value), curEl, 0);\n                        }\n                    }\n                    var tagName = curEl.tagName;\n                    // tslint:disable-next-line:no-non-null-assertion\n                    var parent_1 = curEl.parentNode;\n                    var curElIndex = _indexOf(parent_1.childNodes, curEl);\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        this_1._processEventResult([new salve_1.ValidationError(\"cannot resolve the name \" + tagName)], parent_1, curElIndex);\n                        // This allows us to move forward. It will certainly cause a\n                        // validation error, and send salve into its recovery mode for unknown\n                        // elements.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    // Check whether this element is going to be allowed only\n                    // due to a wildcard.\n                    this_1._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\", ename.ns, ename.name);\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"enterStartTag\", ename.ns, ename.name), parent_1, curElIndex);\n                    this_1._setNodeProperty(curEl, \"EventIndexBeforeAttributes\", events.length);\n                    this_1._fireAttributeEvents(walker, curEl);\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterAttributes\", events.length);\n                    // Leave the start tag.\n                    this_1._fireAndProcessEvent(walker, LEAVE_START_TAG_EVENT, curEl, 0);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n                    this_1._cycleEntered--;\n                    return { value: true };\n                    // break would be unreachable.\n                }\n                case Stage.CONTENTS: {\n                    var node = (this_1._previousChild === null) ?\n                        // starting from scratch\n                        curEl.firstChild :\n                        // already validation contents\n                        this_1._previousChild.nextSibling;\n                    var textAccumulator_1 = [];\n                    var textAccumulatorNode_1;\n                    var flushText = function () {\n                        if (textAccumulator_1.length !== 0) {\n                            var event_1 = new salve_1.Event(\"text\", textAccumulator_1.join(\"\"));\n                            var eventResult = walker.fireEvent(event_1);\n                            if (eventResult instanceof Array) {\n                                if (textAccumulatorNode_1 === undefined) {\n                                    throw new Error(\"flushText running with undefined node\");\n                                }\n                                // We are never without a parentNode here.\n                                // tslint:disable-next-line:no-non-null-assertion\n                                var parent_2 = textAccumulatorNode_1.parentNode;\n                                _this._processEventResult(eventResult, parent_2, _indexOf(parent_2.childNodes, textAccumulatorNode_1));\n                            }\n                        }\n                        textAccumulator_1 = [];\n                        textAccumulatorNode_1 = undefined;\n                    };\n                    while (node !== null) {\n                        switch (node.nodeType) {\n                            case Node.TEXT_NODE:\n                                // Salve does not allow multiple text events in a row. If text is\n                                // encountered, then all the text must be passed to salve as a\n                                // single event. We record the text and will flush it to salve\n                                // later.\n                                textAccumulator_1.push(node.data);\n                                if (textAccumulatorNode_1 === undefined) {\n                                    textAccumulatorNode_1 = node;\n                                }\n                                break;\n                            case Node.ELEMENT_NODE:\n                                flushText();\n                                portion /= curEl.childElementCount;\n                                this_1._curEl = curEl = node;\n                                stage = this_1._validationStage = Stage.START_TAG;\n                                this_1._previousChild = null;\n                                return \"continue-stage_change\";\n                            case Node.COMMENT_NODE:\n                                break; // We just skip over comment nodes.\n                            default:\n                                throw new Error(\"unexpected node type: \" + node.nodeType);\n                        }\n                        node = node.nextSibling;\n                    }\n                    flushText();\n                    stage = this_1._validationStage = Stage.END_TAG;\n                    break;\n                }\n                case Stage.END_TAG: {\n                    // We've reached the end...\n                    if (curEl === this_1.root) {\n                        var eventResult = walker.end();\n                        if (eventResult instanceof Array) {\n                            this_1._processEventResult(eventResult, curEl, curEl.childNodes.length);\n                        }\n                        this_1._runDocumentValidation();\n                        this_1._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n                        this_1._partDone = 1;\n                        this_1._stop(this_1._errors.length > 0 ? WorkingState.INVALID :\n                            WorkingState.VALID);\n                        this_1._cycleEntered--;\n                        return { value: false };\n                    }\n                    // we need it later\n                    var originalElement = curEl;\n                    var tagName = curEl.tagName;\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        // We just produce the name name we produced when we encountered the\n                        // start tag.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"endTag\", ename.ns, ename.name), curEl, curEl.childNodes.length);\n                    this_1._fireAndProcessEvent(walker, LEAVE_CONTEXT_EVENT, curEl, curEl.childNodes.length);\n                    // Go back to the parent\n                    this_1._previousChild = curEl;\n                    // We are never without a parentNode here.\n                    // tslint:disable-next-line:no-non-null-assertion\n                    this_1._curEl = curEl = curEl.parentNode;\n                    var nextDone = this_1._partDone;\n                    if (curEl !== this_1.root) {\n                        stack.shift();\n                        var first = stack[0];\n                        nextDone = first.partDone += portion;\n                        portion = first.portion;\n                    }\n                    this_1._setWorkingState(WorkingState.WORKING, nextDone);\n                    this_1._setNodeProperty(originalElement, \"EventIndexAfter\", this_1._validationEvents.length);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._cycleEntered--;\n                    return { value: true };\n                }\n                // break; would be unreachable\n                default:\n                    throw new Error(\"unexpected state\");\n            }\n        };\n        var this_1 = this;\n        stage_change: while (true) {\n            var state_1 = _loop_1();\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n            switch (state_1) {\n                case \"continue-stage_change\": continue stage_change;\n            }\n        }\n    };\n    /**\n     * Stops background validation.\n     */\n    Validator.prototype.stop = function () {\n        this._stop();\n    };\n    /**\n     * This private method takes an argument that allows setting the working state\n     * to a specific value. This is useful to reduce the number of\n     * ``state-update`` events emitted when some internal operations are\n     * performed. The alternative would be to perform a state change before or\n     * after the call to ``stop``, which would result in more events being\n     * emitted.\n     *\n     * If the parameter is unused, then the logic is that if we were not yet in a\n     * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n     *\n     * @param state The state with which to stop.\n     */\n    Validator.prototype._stop = function (state) {\n        if (this._timeoutId !== undefined) {\n            clearTimeout(this._timeoutId);\n        }\n        this._timeoutId = undefined;\n        if (state === undefined) {\n            // We are stopping prematurely, update the state\n            if (this._workingState === WorkingState.WORKING) {\n                this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n            }\n        }\n        else {\n            this._setWorkingState(state, this._partDone);\n        }\n    };\n    /**\n     * Run document-level validation that cannot be modeled by Relax NG.  The\n     * default implementation does nothing. Deriving classes may override it to\n     * call [[_processError]].\n     */\n    Validator.prototype._runDocumentValidation = function () { }; // tslint:disable-line: no-empty\n    /**\n     * Restarts validation from a specific point. After the call returns, the\n     * background validation will be in effect. (So calling it on a stopped\n     * validator has the side effect of starting it.)\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.restartAt = function (node) {\n        this.resetTo(node);\n        this.start();\n    };\n    /**\n     * Reset validation to continue from a certain point.\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.resetTo = function (node) {\n        // We use `this._resetting` to avoid a costly reinitialization if this\n        // method is called twice in a row before any work has had a chance to be\n        // done.\n        if (!this._resetting) {\n            this._resetting = true;\n            this._resetTo(node);\n        }\n    };\n    Validator.prototype._erase = function (el) {\n        this._clearNodeProperties(el);\n        var child = el.firstElementChild;\n        while (child !== null) {\n            this._erase(child);\n            child = child.nextElementSibling;\n        }\n    };\n    /**\n     * Resets validation to continue from a specific point. Any further work done\n     * by the validator will start from the point specified.\n     *\n     * @param node The element to start validation from.\n     *\n     * @emits module:validator~Validator#reset-errors\n     */\n    Validator.prototype._resetTo = function (node) {\n        // An earlier implementation was trying to be clever and to avoid restarting\n        // much earlier than strictly needed. That ended up being more costly than\n        // doing this primitive restart from 0 no matter what. Eventually, Validator\n        // should be updated so that on large documents, restarting from a location\n        // towards the end does not require revalidating the whole document. For\n        // now, since wed is used for smallish documents, it would be a premature\n        // optimization.\n        this._erase(this.root);\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationWalker = this.schema.newWalker();\n        this._validationEvents = [];\n        this._curEl = this.root;\n        this._partDone = 0;\n        this._errors = [];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        /**\n         * Tells the listener that it must reset its list of errors.\n         *\n         * @event module:validator~Validator#reset-errors\n         * @type {Object}\n         * @property {integer} at The index of the first error that must\n         * be deleted. This error and all those after it must be deleted.\n         */\n        this._events._emit(\"reset-errors\", { at: 0 });\n    };\n    /**\n     * Sets the working state of the validator. Emits a \"state-update\"\n     * event if the state has changed.\n     *\n     * @param newState The new state of the validator.\n     *\n     * @param newDone The new portion of work done.\n     *\n     * @emits module:validator~Validator#state-update\n     */\n    Validator.prototype._setWorkingState = function (newState, newDone) {\n        var changed = false;\n        if (this._workingState !== newState) {\n            this._workingState = newState;\n            changed = true;\n        }\n        if (this._partDone !== newDone) {\n            this._partDone = newDone;\n            changed = true;\n        }\n        if (changed) {\n            /**\n             * Tells the listener that the validator has changed state.\n             *\n             * @event module:validator~Validator#state-update\n             */\n            this._events._emit(\"state-update\", { state: newState, partDone: newDone });\n        }\n    };\n    /**\n     * Gets the validator working state.\n     *\n     * @returns The working state\n     */\n    Validator.prototype.getWorkingState = function () {\n        return {\n            state: this._workingState,\n            partDone: this._partDone,\n        };\n    };\n    Object.defineProperty(Validator.prototype, \"errors\", {\n        /**\n         * The current set of errors.\n         */\n        get: function () {\n            return this._errors.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Processes the result of firing a tag event. It will emit an \"error\"\n     * event for each error.\n     *\n     * @param results The results of the walker's ``fireEvent`` call.\n     *\n     * @param node The data node to which the result belongs.\n     *\n     * @param index The index into ``node`` to which the result belongs.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processEventResult = function (results, node, index) {\n        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n            var result = results_1[_i];\n            this._processError({ error: result, node: node, index: index });\n        }\n    };\n    /**\n     * This method should be called whenever a new error is detected. It\n     * records the error and emits the corresponding event.\n     *\n     * @param error The error found.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processError = function (error) {\n        this._errors.push(error);\n        /**\n         * Tells the listener that an error has occurred.\n         *\n         * @event module:validator~Validator#error\n         * @type {Object}\n         * @property {Object} error The validation error.\n         * @property {Node} node The node where the error occurred.\n         * @property {integer} index The index in this node.\n         */\n        this._events._emit(\"error\", error);\n    };\n    /**\n     * Fires all the attribute events for a given element.\n     */\n    Validator.prototype._fireAttributeEvents = function (walker, el) {\n        // Find all attributes, fire events for them.\n        var attributes = el.attributes;\n        // tslint:disable-next-line:prefer-for-of\n        for (var i = 0; i < attributes.length; ++i) {\n            var attr = attributes[i];\n            // Skip those attributes which are namespace attributes.\n            if ((attr.name === \"xmlns\") ||\n                (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n                continue;\n            }\n            if (this._fireAttributeNameEvent(walker, el, attr)) {\n                this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeValue\", attr.value), attr, 0);\n            }\n        }\n    };\n    /**\n     * Fires an attributeName event. If the attribute name is in a namespace and\n     * cannot be resolved, the event is not fired.\n     *\n     * @returns True if the event was actually fired, false if not.\n     */\n    Validator.prototype._fireAttributeNameEvent = function (walker, el, attr) {\n        var attrName = attr.name;\n        var ename = walker.resolveName(attrName, true);\n        if (ename === undefined) {\n            this._processError({ error: new salve_1.ValidationError(\"cannot resolve attribute name \" + attrName), node: attr, index: 0 });\n            return false;\n        }\n        this._setPossibleDueToWildcard(attr, walker, \"attributeName\", ename.ns, ename.name);\n        this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeName\", ename.ns, ename.name), attr, 0);\n        return true;\n    };\n    /**\n     * Convenience method to fire events.\n     *\n     * @param walker The walker on which to fire events.\n     *\n     * @param event The event to fire.\n     *\n     * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n     * can be undefined for events that have no location associated with them.\n     *\n     * @param ix The index into ``el`` associated with this event, or a ``Node``\n     * which must be a child of ``el``. The index will be computed from the\n     * location of the child passed as this parameter in ``el``.\n     */\n    Validator.prototype._fireAndProcessEvent = function (walker, event, el, ix) {\n        this._validationEvents.push(event);\n        var eventResult = walker.fireEvent(event);\n        if (eventResult instanceof Array) {\n            if (el != null && ix !== undefined && typeof ix !== \"number\") {\n                ix = _indexOf(el.childNodes, ix);\n            }\n            this._processEventResult(eventResult, el, ix);\n        }\n    };\n    /**\n     * Force an immediate validation which is guaranteed to go at least up to the\n     * point specified by ``container, index``, exclusively. These parameters are\n     * interpreted in the same way a DOM caret is.\n     *\n     * If the validation has not yet reached the location specified, validation\n     * will immediately be performed to reach the point. If the validation has\n     * already reached this point, then this call is a no-op.\n     *\n     * There is one exception in the way the ``container, index`` pair is\n     * interpreted. If the container is the ``root`` that was passed when\n     * constructing the Validator, then setting ``index`` to a negative value will\n     * result in the validation validating all elements **and** considering the\n     * document complete. So unclosed tags or missing elements will be\n     * reported. Otherwise, the validation goes up the ``index`` but considers the\n     * document incomplete, and won't report the errors that are normally reported\n     * at the end of a document. For instance, unclosed elements won't be\n     * reported.\n     *\n     * @param container The location up to where to validate.\n     *\n     * @param index The location up to where to validate.\n     *\n     * @param attributes Whether we are interested to validate up to and including\n     * the attribute events of the node pointed to by ``container, index``. The\n     * validation ends before leaving the start tag.\n     *\n     * @throws {Error} If ``container`` is not of element or text type.\n     */\n    Validator.prototype._validateUpTo = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to validate after attributes but before \" +\n                \"the end of the start tag on a \" +\n                \"node which is not an element node\");\n        }\n        // Set these to reasonable defaults. The rest of the code is\n        // dedicated to changing these values to those necessary depending\n        // on specifics of what is passed to the method.\n        var toInspect = container;\n        var dataKey = \"EventIndexAfter\";\n        // This function could be called with container === root if the\n        // document is empty or if the user has the caret before the start\n        // tag of the first element of the actual structure we want to\n        // validate or after the end tag of that element.\n        if (container === this.root && index <= 0) {\n            if (attributes) {\n                dataKey = \"EventIndexAfterAttributes\";\n                toInspect = container.childNodes[index];\n            }\n            else if (index === 0) {\n                // We're before the top element, no events to fire.\n                return;\n            }\n            // default values of toInspect and dataKey are what we want\n        }\n        else {\n            if (isAttr(container)) {\n                toInspect = container.ownerElement;\n                dataKey = \"EventIndexBeforeAttributes\";\n            }\n            else {\n                switch (container.nodeType) {\n                    case Node.TEXT_NODE:\n                        toInspect = container.previousElementSibling;\n                        if (toInspect === null) {\n                            // tslint:disable-next-line:no-non-null-assertion\n                            toInspect = container.parentNode;\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    case Node.ELEMENT_NODE:\n                    case Node.DOCUMENT_FRAGMENT_NODE:\n                    case Node.DOCUMENT_NODE:\n                        var node = container.childNodes[index];\n                        var prev = node === undefined ?\n                            container.lastElementChild :\n                            // It may not be an element, in which case we get \"undefined\".\n                            node.previousElementSibling;\n                        if (attributes) {\n                            dataKey = \"EventIndexAfterAttributes\";\n                            toInspect = node;\n                        }\n                        else if (prev !== null) {\n                            toInspect = prev;\n                        }\n                        else {\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    default:\n                        throw new Error(\"unexpected node type: \" + container.nodeType);\n                }\n            }\n        }\n        while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n            this._cycle();\n        }\n    };\n    /**\n     * Gets the walker which would represent the state of parsing at the point\n     * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n     * of how these parameters are interpreted.\n     *\n     * **The walker returned by this function is not guaranteed to be a new\n     *   instance. Callers should not modify the walker returned but instead clone\n     *   it.**\n     *\n     * @param container\n     *\n     * @param index\n     *\n     * @param attributes Whether we are interested to validate up to but not\n     * including the attribute events of the node pointed to by ``container,\n     * index``. If ``true`` the walker returned will have all events fired on it\n     * up to, and including, those attribute events on the element pointed to by\n     * ``container, index``.\n     *\n     * @returns The walker.\n     *\n     * @throws {EventIndexException} If it runs out of events or computes an event\n     * index that makes no sense.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._getWalkerAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to get a walker for attribute events on a \" +\n                \"node which is not an element node\");\n        }\n        // Make sure we have the data we need.\n        this._validateUpTo(container, index, attributes);\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (!attributes) {\n                // We're before the top element, no events to fire.\n                if (index === 0) {\n                    return this.schema.newWalker();\n                }\n                // _validateUpTo ensures that the current walker held by the validator\n                // is what we want. We can just return it here because it is the\n                // caller's reponsibility to either not modify it or clone it.\n                return this._validationWalker;\n            }\n        }\n        var walker;\n        function fireTextEvent(textNode) {\n            if (walker === undefined) {\n                throw new Error(\"calling fireTextEvent without a walker\");\n            }\n            walker.fireEvent(new salve_1.Event(\"text\", textNode.data));\n        }\n        if (isAttr(container)) {\n            var el = container.ownerElement;\n            walker = this.readyWalker(\n            // tslint:disable-next-line:no-non-null-assertion\n            this.getNodeProperty(el, \"EventIndexBeforeAttributes\"));\n            // Don't fire on namespace attributes.\n            if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n                walker = walker.clone();\n                this._fireAttributeNameEvent(walker, el, container);\n            }\n        }\n        else {\n            switch (container.nodeType) {\n                case Node.TEXT_NODE: {\n                    var prev = container.previousElementSibling;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (prev !== null) {\n                        getFrom = prev;\n                        propName = \"EventIndexAfter\";\n                    }\n                    else {\n                        // tslint:disable-next-line:no-non-null-assertion\n                        getFrom = container.parentNode;\n                        propName = \"EventIndexAfterStart\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    // We will attempt to fire a text event if our location is inside the\n                    // current text node.\n                    //\n                    // A previous version of this code was also checking whether there is a\n                    // text node between this text node and prev but this cannot happen\n                    // because the tree on which validation is performed cannot have two\n                    // adjacent text nodes. It was also checking whether there was a _text\n                    // element between prev and this text node but this also cannot happen.\n                    if (index > 0) {\n                        walker = walker.clone();\n                        fireTextEvent(container);\n                    }\n                    break;\n                }\n                case Node.ELEMENT_NODE:\n                case Node.DOCUMENT_NODE:\n                case Node.DOCUMENT_FRAGMENT_NODE: {\n                    var node = container.childNodes[index];\n                    var prev = void 0;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (!attributes) {\n                        prev = node === undefined ? container.lastElementChild :\n                            node.previousElementSibling;\n                        if (prev !== null) {\n                            getFrom = prev;\n                            propName = \"EventIndexAfter\";\n                        }\n                        else {\n                            getFrom = container;\n                            propName = \"EventIndexAfterStart\";\n                        }\n                    }\n                    else {\n                        getFrom = node;\n                        propName = \"EventIndexAfterAttributes\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    if (!attributes) {\n                        // We will attempt to fire a text event if another text node appeared\n                        // between the node we care about and the element just before it.\n                        var prevSibling = node != null ? node.previousSibling : null;\n                        if (prevSibling !== null &&\n                            // If the previous sibling is the same as the previous *element*\n                            // sibbling, then there is nothing *between* that we need to take\n                            // care of.\n                            prevSibling !== prev) {\n                            if (prevSibling.nodeType === Node.TEXT_NODE) {\n                                walker = walker.clone();\n                                fireTextEvent(prevSibling);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(\"unexpected node type: \" + container.nodeType);\n            }\n        }\n        return walker;\n    };\n    Validator.prototype.readyWalker = function (eventIndex) {\n        //\n        // Perceptive readers will notice that the caching being done here could be\n        // more aggressive. It turns out that the cases where we have to clone the\n        // walker after getting it from the cache are not that frequently used, so\n        // there is little to gain from being more aggressive. Furthermore, it is\n        // likely that the caching system will change when we implement a saner way\n        // to reset validation and segment large documents into smaller chunks.\n        //\n        if (eventIndex === undefined) {\n            throw new EventIndexException();\n        }\n        var cache = this._walkerCache;\n        var max = this._walkerCacheMax;\n        var walker = cache[eventIndex];\n        if (walker) {\n            return walker;\n        }\n        //\n        // Scan the cache for a walker we could use... rather than start from zero.\n        //\n        // There is no point in trying to be clever by using this._walkerCacheGap to\n        // start our search. If _getWalkerAt is called with decreasing positions in\n        // the document, then the gap is meaningless for our search. (Such scenario\n        // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n        // cannot assume that it won't happen.)\n        //\n        // Also, the following approach is a bit crude but trying to be clever with\n        // Object.keys() and then searching through a sorted list does not yield an\n        // appreciable improvement. Maybe on very large documents it would but this\n        // module will have to be redesigned to tackle that so there's no point now\n        // to be cleverer than this. We also tested using a sparse Array for the\n        // cache and got visibly worse performance. And we tested to see if a flag\n        // indicating if the cache has anything in it would help avoid doing a long\n        // search but it maked things worse. Basically, it seems that the typical\n        // usage pattern of _getWalkerAt is such that it will usually be called in\n        // increasing order of position in the document.\n        //\n        var searchIx = eventIndex;\n        if (searchIx >= max) {\n            searchIx = max;\n            walker = cache[searchIx];\n        }\n        else {\n            while (!walker && --searchIx >= 0) {\n                walker = cache[searchIx];\n            }\n        }\n        if (walker) {\n            walker = walker.clone();\n        }\n        else {\n            walker = this.schema.newWalker();\n            searchIx = 0;\n        }\n        for (var ix = searchIx; ix < eventIndex; ++ix) {\n            walker.fireEvent(this._validationEvents[ix]);\n        }\n        // This is a bit arbitrary to find a balance between caching too much\n        // information and spending too much time computing walkers.\n        if (eventIndex - searchIx >= this._walkerCacheGap) {\n            cache[eventIndex] = walker;\n            this._walkerCacheMax = Math.max(eventIndex, max);\n        }\n        return walker;\n    };\n    /**\n     * Returns the set of possible events for the location specified by the\n     * parameters.\n     *\n     * @param container Together with ``index`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param index Together with ``container`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param attributes\n     *\n     * @returns A set of possible events.\n     */\n    Validator.prototype.possibleAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        var walker = this._getWalkerAt(container, index, attributes);\n        // Calling possible does not *modify* the walker.\n        return walker.possible();\n    };\n    /**\n     * Finds the locations in a node where a certain validation event is\n     * possible.\n     *\n     * @param container A node.\n     *\n     * @param event The event to search for. The event should be presented in the\n     * same format used for ``fireEvent``.\n     *\n     * @returns The locations in ``container`` where the event is possible.\n     */\n    Validator.prototype.possibleWhere = function (container, event) {\n        var ret = [];\n        for (var index = 0; index <= container.childNodes.length; ++index) {\n            var possible = this.possibleAt(container, index);\n            if (possible.has(event)) {\n                ret.push(index);\n            }\n            else if (event.params[0] === \"enterStartTag\" ||\n                event.params[0] === \"attributeName\") {\n                // In the case where we have a name pattern as the 2nd parameter, and\n                // this pattern can be complex or have wildcards, then we have to check\n                // all events one by one for a name pattern match. (While enterStartTag,\n                // endTag and attributeName all have name patterns, endTag cannot be\n                // complex or allow wildcards because what it allows much match the tag\n                // that started the current element.\n                for (var _i = 0, _a = possible.toArray(); _i < _a.length; _i++) {\n                    var candidate = _a[_i];\n                    if (candidate.params[0] === event.params[0] &&\n                        candidate.params[1].match(event.params[1], event.params[2])) {\n                        ret.push(index);\n                        break;\n                    }\n                }\n            }\n        }\n        return ret;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidate = function (container, index, toParse) {\n        var clone;\n        if (toParse instanceof Array) {\n            clone = container.ownerDocument.createDocumentFragment();\n            for (var _i = 0, toParse_1 = toParse; _i < toParse_1.length; _i++) {\n                var child = toParse_1[_i];\n                clone.insertBefore(child.cloneNode(true), null);\n            }\n        }\n        else {\n            clone = toParse.cloneNode(true);\n        }\n        var root = container.ownerDocument.createElement(\"div\");\n        root.insertBefore(clone, null);\n        return this.speculativelyValidateFragment(container, index, root);\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse. See above.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidateFragment = function (container, index, toParse) {\n        // This is useful for pure-JS code that may be calling this.\n        if (toParse.nodeType !== Node.ELEMENT_NODE) {\n            throw new Error(\"toParse is not an element\");\n        }\n        // We create a new validator with the proper state to parse the fragment\n        // we've been given.\n        var dup = new Validator(this.schema, toParse);\n        // We have to clone the walker to prevent messing up the internal cache.\n        dup._validationWalker = this._getWalkerAt(container, index).clone();\n        // This forces validating the whole fragment\n        dup._validateUpTo(toParse, toParse.childNodes.length);\n        if (dup._errors.length !== 0) {\n            return dup._errors;\n        }\n        return false;\n    };\n    /**\n     * Obtain the validation errors that belong to a specific node.\n     *\n     * The term \"that belong to\" has a specific meaning here:\n     *\n     * - An error in the contents of an element belongs to the element whose\n     *   contents are incorrect. For instance if in the sequence\n     *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n     *   error belongs to the node for the element ``foo``, not the node for the\n     *   element ``blip``.\n     *\n     * - Attribute errors belong to the element node to which the attributes\n     *   belong.\n     *\n     * @param node The node whose errors we want to get.\n     *\n     * @returns The errors.\n     */\n    Validator.prototype.getErrorsFor = function (node) {\n        var parent = node.parentNode;\n        if (parent === null) {\n            throw new Error(\"node without a parent!\");\n        }\n        // Validate to after the closing tag of the node.\n        this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n        var ret = [];\n        for (var _i = 0, _a = this._errors; _i < _a.length; _i++) {\n            var errorData = _a[_i];\n            if (errorData.node === node) {\n                ret.push(errorData);\n            }\n        }\n        return ret;\n    };\n    /**\n     * Sets a flag indicating whether a node is possible only due to a name\n     * pattern wildcard, and emits an event if setting the flag is a change from\n     * the previous value of the flag. It does this by inspecting the event that\n     * would be fired when ``node`` is validated. The parameters ``eventName``,\n     * ``ns`` and ``name`` are used to determine what we are looking for among\n     * possible events.\n     *\n     * @param node The node we want to check.\n     *\n     * @param walker A walker whose last fired event is the one just before the\n     * event that would be fired when validating ``node``.\n     *\n     * @param eventName The event name we are interested in.\n     *\n     * @param ns The namespace to use with the event.\n     *\n     * @param name The name to use with the event.\n     *\n     * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n     *\n     */\n    Validator.prototype._setPossibleDueToWildcard = function (node, walker, eventName, ns, name) {\n        var previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n        var possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n        this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n        if (previous === undefined || previous !== possible) {\n            /**\n             * Tells the listener that a node's flag indicating whether it is possible\n             * only due to a wildcard has changed.\n             *\n             * @event module:validator~Validator#possible-due-to-wildcard-change\n             *\n             * @type {Node} The node whose flag has changed.\n             */\n            this._events._emit(\"possible-due-to-wildcard-change\", node);\n        }\n    };\n    /**\n     * Resolve a qualified name to an expanded name. See\n     * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n     * takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param name The name to rresolve.\n     *\n     * @param attributes Whether the name is an attribute's name.\n     *\n     * @return The resolved name.\n     */\n    Validator.prototype.resolveNameAt = function (container, index, name, attribute) {\n        if (attribute === void 0) { attribute = false; }\n        // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n        // its ``attribute`` parameter ``false``.\n        return this._getWalkerAt(container, index).resolveName(name, attribute);\n    };\n    /**\n     * Unresolve an expanded name to a qualified name. See\n     * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n     * method takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param uri The URI to unresolve.\n     *\n     * @param name The name to unresolve.\n     *\n     * @return The unresolved name.\n     */\n    Validator.prototype.unresolveNameAt = function (container, index, uri, name) {\n        return this._getWalkerAt(container, index).unresolveName(uri, name);\n    };\n    return Validator;\n}());\nexports.Validator = Validator;\n\n//# sourceMappingURL=main.js.map\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// salve-dom.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c40b253cb9911ad5a8e1","\"use strict\";\n/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        this._eventListeners = Object.create(null);\n        this._generalListeners = [];\n        this._trace = false;\n    }\n    EventEmitter.prototype.addEventListener = function (eventName, listener) {\n        if (eventName === \"*\") {\n            this._generalListeners.push(listener);\n        }\n        else {\n            var listeners = this._eventListeners[eventName];\n            if (listeners === undefined) {\n                listeners = this._eventListeners[eventName] = [];\n            }\n            listeners.push(listener);\n        }\n    };\n    EventEmitter.prototype.addOneTimeEventListener = function (eventName, listener) {\n        var _this = this;\n        // We perform casts as any here to indicate to TypeScript that it is\n        // safe to pass this stub.\n        var me = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.removeEventListener(eventName, me);\n            return listener.apply(_this, args);\n        };\n        this.addEventListener(eventName, me);\n        return me;\n    };\n    EventEmitter.prototype.removeEventListener = function (eventName, listener) {\n        var listeners = (eventName === \"*\") ?\n            this._generalListeners :\n            this._eventListeners[eventName];\n        if (listeners === undefined) {\n            return;\n        }\n        var index = listeners.lastIndexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    EventEmitter.prototype.removeAllListeners = function (eventName) {\n        if (eventName === \"*\") {\n            this._generalListeners = [];\n        }\n        else {\n            this._eventListeners[eventName] = [];\n        }\n    };\n    /**\n     * This is the function that the class using this mixin must call to\n     * indicate that an event has occurred.\n     *\n     * @param eventName The name of the event to emit.\n     *\n     * @param ev The event data to provide to handlers. The type can be\n     * anything.\n     */\n    EventEmitter.prototype._emit = function (eventName, ev) {\n        if (this._trace) {\n            // tslint:disable-next-line: no-console\n            console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n        }\n        {\n            var listeners = this._generalListeners;\n            if (listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n                    var listener = listeners_1[_i];\n                    var ret = listener.call(undefined, eventName, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n        {\n            var listeners = this._eventListeners[eventName];\n            if (listeners !== undefined && listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                for (var _a = 0, listeners_2 = listeners; _a < listeners_2.length; _a++) {\n                    var listener = listeners_2[_a];\n                    var ret = listener.call(undefined, ev);\n                    if (ret === false) {\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n//  LocalWords:  Mangalam MPL Dubeau noop ev mixin\n\n//# sourceMappingURL=event_emitter.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/event_emitter.js\n// module id = 0\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\nfunction fixPrototype(obj, parent) {\n    var oldProto = Object.getPrototypeOf !== undefined ?\n        Object.getPrototypeOf(obj) :\n        obj.__proto__;\n    if (oldProto !== parent) {\n        if (Object.setPrototypeOf !== undefined) {\n            Object.setPrototypeOf(obj, parent.prototype);\n        }\n        else {\n            obj.__proto__ = parent.prototype;\n        }\n    }\n}\nexports.fixPrototype = fixPrototype;\n\n//# sourceMappingURL=tools.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/tools.js\n// module id = 1\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"salve\"\n// module id = 2\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar salve_1 = require(\"salve\");\nvar event_emitter_1 = require(\"./event_emitter\");\nvar tools_1 = require(\"./tools\");\nfunction _indexOf(parent, needle) {\n    return Array.prototype.indexOf.call(parent, needle);\n}\nfunction isAttr(it) {\n    var attrNodeType = Node.ATTRIBUTE_NODE;\n    // We check that ``attr_node_type`` is not undefined because eventually\n    // ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n    // could be testing ``undefined === undefined`` for objects which are not\n    // attributes, which would return ``true``. The function is not very strict\n    // but it should not be too lax either.\n    return it instanceof Attr ||\n        ((attrNodeType !== undefined) && (it.nodeType === attrNodeType));\n}\nexports.isAttr = isAttr;\n// validation_stage values\nvar Stage;\n(function (Stage) {\n    Stage[Stage[\"START_TAG\"] = 1] = \"START_TAG\";\n    Stage[Stage[\"CONTENTS\"] = 2] = \"CONTENTS\";\n    Stage[Stage[\"END_TAG\"] = 3] = \"END_TAG\";\n})(Stage || (Stage = {}));\n// Working state values\nvar WorkingState;\n(function (WorkingState) {\n    /**\n     * The validator is stopped but has not completed a validation pass yet.\n     */\n    WorkingState[WorkingState[\"INCOMPLETE\"] = 1] = \"INCOMPLETE\";\n    /**\n     * The validator is working on validating the document.\n     */\n    WorkingState[WorkingState[\"WORKING\"] = 2] = \"WORKING\";\n    /**\n     * The validator is stopped and has found the document invalid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"INVALID\"] = 3] = \"INVALID\";\n    /**\n     * The validator is stopped and has found the document valid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"VALID\"] = 4] = \"VALID\";\n})(WorkingState = exports.WorkingState || (exports.WorkingState = {}));\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nvar ProgressState = (function () {\n    function ProgressState(partDone, portion) {\n        this.partDone = partDone;\n        this.portion = portion;\n    }\n    return ProgressState;\n}());\n//\n// Note: the Validator class adds information to the Element nodes it\n// is working with by adding expando properties that start with\n// \"wed_event_\". This deemed acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to\n//   be open to third party software. Even if it were, the chance of a\n//   clash is small.\n//\n// * The values of the expando properties are primitives (not objects\n//   or other elements).\n//\n// * We don't care about browsers or situations where expando\n//   properties are not supported.\n//\n//\n// These are constants. So create them once rather than over and over\n// again.\n//\nvar ENTER_CONTEXT_EVENT = new salve_1.Event(\"enterContext\");\nvar LEAVE_START_TAG_EVENT = new salve_1.Event(\"leaveStartTag\");\nvar LEAVE_CONTEXT_EVENT = new salve_1.Event(\"leaveContext\");\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nvar EventIndexException = (function (_super) {\n    __extends(EventIndexException, _super);\n    function EventIndexException() {\n        var _this = _super.call(this, \"undefined event_index; _validateUpTo should have taken care of that\") || this;\n        tools_1.fixPrototype(_this, EventIndexException);\n        return _this;\n    }\n    return EventIndexException;\n}(Error));\n// This private utility function checks whether an event is possible\n// only because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker, eventName, ns, name) {\n    var evs = walker.possible().toArray();\n    var matched = false;\n    for (var _i = 0, evs_1 = evs; _i < evs_1.length; _i++) {\n        var ev = evs_1[_i];\n        if (ev.params[0] !== eventName) {\n            continue;\n        }\n        var namePattern = ev.params[1];\n        var matches = namePattern.match(ns, name);\n        // Keep track of whether it ever matched anything.\n        matched = matched || matches;\n        // We already know that it matches, and this is not merely due\n        // to a wildcard.\n        if (matches && !namePattern.wildcardMatch(ns, name)) {\n            return false;\n        }\n    }\n    // If it never matched any pattern at all, then we must return false.  If we\n    // get here and matched is true then it means that it matched all patterns due\n    // to wildcards.\n    return matched;\n}\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``'s ``constructTree``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nvar Validator = (function () {\n    function Validator(schema, root, options) {\n        if (options === void 0) { options = {}; }\n        this.schema = schema;\n        this.root = root;\n        this._cycleEntered = 0;\n        this._timeout = 200;\n        this._maxTimespan = 100;\n        this._resetting = false;\n        this._errors = [];\n        this._boundWrapper = this._workWrapper.bind(this);\n        // Validation state\n        this._validationEvents = [];\n        this._workingState = WorkingState.INCOMPLETE;\n        this._partDone = 0;\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationStack = [new ProgressState(0, 1)];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        this._prefix = \"salveDom\";\n        // The distance between walkers under which we skip saving a\n        // walker in the cache.\n        this._walkerCacheGap = 100;\n        this._events = new event_emitter_1.EventEmitter();\n        var keys = [\"timeout\", \"maxTimespan\",\n            \"walkerCacheGap\"];\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            var value = options[key];\n            if (value === undefined) {\n                continue;\n            }\n            if (value < 0) {\n                throw new Error(\"the value for \" + key + \" cannot be negative\");\n            }\n            this[\"_\" + key] = options[key];\n        }\n        if (options.prefix !== undefined) {\n            this._prefix = options.prefix;\n        }\n        this._curEl = this.root;\n        // This prevents an infinite loop when speculativelyValidate is\n        // called to validate a text node.\n        this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", this._validationEvents.length);\n        this._setWorkingState(WorkingState.INCOMPLETE, 0);\n        this._validationWalker = this.schema.newWalker();\n        this.events = this._events;\n    }\n    Validator.prototype.makeKey = function (key) {\n        return \"\" + this._prefix + key;\n    };\n    /**\n     * Function allowing to get a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype.getNodeProperty = function (node, key) {\n        return node[this.makeKey(key)];\n    };\n    /**\n     * Function allowing to set a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype._setNodeProperty = function (node, key, value) {\n        node[this.makeKey(key)] = value;\n    };\n    Validator.prototype._clearNodeProperties = function (node) {\n        var keys = [\n            \"EventIndexAfter\",\n            \"EventIndexAfterStart\",\n            \"EventIndexBeforeAttributes\",\n            \"EventIndexAfterAttributes\",\n            \"PossibleDueToWildcard\",\n        ];\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            delete node[this.makeKey(key)];\n        }\n    };\n    /**\n     * Starts the background validation process.\n     */\n    Validator.prototype.start = function () {\n        if (this._timeoutId !== undefined) {\n            this._stop(WorkingState.WORKING);\n        }\n        // When we call ``this.start``, we want the validation to start ASAP. So we\n        // do not use ``this._timeout`` here. However, we do not call\n        // ``this._workWrapper`` directly because we want to be able to call\n        // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n        // directly, we'd be calling this._cycle from inside this._cycle, which is\n        // results in an internal error.\n        this._timeoutId = setTimeout(this._boundWrapper, 0);\n    };\n    /**\n     * Get the namespaces defined in the schema passed to the\n     * Validator.\n     *\n     * @returns The namespaces known to the schema.\n     */\n    Validator.prototype.getSchemaNamespaces = function () {\n        return this.schema.getNamespaces();\n    };\n    /**\n     * Get the namespaces used in the document. This method does not cache its\n     * information and scan the whole document independently of the current\n     * validation status.\n     *\n     * @returns An object whose keys are namespace prefixes and values are lists\n     * of namespace URIs.  The values are lists because prefixes can be redefined\n     * in a document.\n     */\n    Validator.prototype.getDocumentNamespaces = function () {\n        var ret = {};\n        function _process(node) {\n            if (node === null) {\n                return;\n            }\n            var attrIxLim = node.attributes.length;\n            for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                var attr = node.attributes[attrIx];\n                if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n                    var key = attr.name.slice(6);\n                    var array = ret[key];\n                    if (array === undefined) {\n                        array = ret[key] = [];\n                    }\n                    array.push(attr.value);\n                }\n            }\n            var child = node.firstChild;\n            while (child !== null) {\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    _process(child);\n                }\n                child = child.nextSibling;\n            }\n        }\n        _process(this.root.firstChild);\n        return ret;\n    };\n    /**\n     * Convenience method. The bound version of this method\n     * (``this._boundWrapper``) is what is called by the timeouts to perform the\n     * background validation.\n     */\n    Validator.prototype._workWrapper = function () {\n        if (this._work()) {\n            this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n        }\n    };\n    /**\n     * Controller method for the background validation. Keeps the validator\n     * running only until done or until the maximum time span for one run\n     * of the validator is reached.\n     *\n     * @returns False if there is no more work to do. True otherwise.\n     */\n    Validator.prototype._work = function () {\n        var startDate = Date.now();\n        while (true) {\n            // Give a chance to other operations to work.\n            if ((this._maxTimespan > 0) &&\n                (Date.now() - startDate) >= this._maxTimespan) {\n                return true;\n            }\n            var ret = this._cycle();\n            if (!ret) {\n                return false;\n            }\n        }\n    };\n    /**\n     * Performs one cycle of validation. \"One cycle\" is an arbitrarily\n     * small unit of work.\n     *\n     * @returns False if there is no more work to be done. True otherwise.\n     *\n     * @throws {Error} When there is an internal error.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._cycle = function () {\n        var _this = this;\n        // If we got here after a reset, then we've finished resetting.  If we were\n        // not resetting, then this is a noop.\n        this._resetting = false;\n        //\n        // This check is meant to catch problems that could be hard to diagnose if\n        // wed or one of its modes had a bug such that `_cycle` is reentered from\n        // `_cycle`. This could happen during error processing, for instance. Error\n        // processing causes wed to process the errors, which causes changes in the\n        // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n        // execute something like `getErrorsFor`, which could cause `_cycle` to be\n        // reentered.\n        //\n        if (this._cycleEntered > 0) {\n            throw new Error(\"internal error: _cycle is being reentered\");\n        }\n        if (this._cycleEntered < 0) {\n            throw new Error(\"internal error: _cycleEntered negative\");\n        }\n        //\n        // IMPORTANT: This variable must be decremented before exiting this\n        // method. A try...finally statement is not used here because it would\n        // prevent some virtual machines from optimizing this function.\n        //\n        this._cycleEntered++;\n        var walker = this._validationWalker;\n        var stack = this._validationStack;\n        var events = this._validationEvents;\n        var portion = stack[0].portion;\n        var stage = this._validationStage;\n        var _loop_1 = function () {\n            var curEl = this_1._curEl;\n            switch (stage) {\n                case Stage.START_TAG: {\n                    // The logic is such that if we get here curEl must be an Element.\n                    curEl = curEl;\n                    stack.unshift(new ProgressState(this_1._partDone, portion));\n                    // Handle namespace declarations. Yes, this must happen before we deal\n                    // with the tag name.\n                    this_1._fireAndProcessEvent(walker, ENTER_CONTEXT_EVENT, curEl, 0);\n                    var attrIxLim = curEl.attributes.length;\n                    for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                        var attr = curEl.attributes[attrIx];\n                        if (attr.name === \"xmlns\") {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", \"\", attr.value), curEl, 0);\n                        }\n                        else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n                            this_1._fireAndProcessEvent(walker, new salve_1.Event(\"definePrefix\", attr.name.slice(6), attr.value), curEl, 0);\n                        }\n                    }\n                    var tagName = curEl.tagName;\n                    // tslint:disable-next-line:no-non-null-assertion\n                    var parent_1 = curEl.parentNode;\n                    var curElIndex = _indexOf(parent_1.childNodes, curEl);\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        this_1._processEventResult([new salve_1.ValidationError(\"cannot resolve the name \" + tagName)], parent_1, curElIndex);\n                        // This allows us to move forward. It will certainly cause a\n                        // validation error, and send salve into its recovery mode for unknown\n                        // elements.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    // Check whether this element is going to be allowed only\n                    // due to a wildcard.\n                    this_1._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\", ename.ns, ename.name);\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"enterStartTag\", ename.ns, ename.name), parent_1, curElIndex);\n                    this_1._setNodeProperty(curEl, \"EventIndexBeforeAttributes\", events.length);\n                    this_1._fireAttributeEvents(walker, curEl);\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterAttributes\", events.length);\n                    // Leave the start tag.\n                    this_1._fireAndProcessEvent(walker, LEAVE_START_TAG_EVENT, curEl, 0);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n                    this_1._cycleEntered--;\n                    return { value: true };\n                    // break would be unreachable.\n                }\n                case Stage.CONTENTS: {\n                    var node = (this_1._previousChild === null) ?\n                        // starting from scratch\n                        curEl.firstChild :\n                        // already validation contents\n                        this_1._previousChild.nextSibling;\n                    var textAccumulator_1 = [];\n                    var textAccumulatorNode_1;\n                    var flushText = function () {\n                        if (textAccumulator_1.length !== 0) {\n                            var event_1 = new salve_1.Event(\"text\", textAccumulator_1.join(\"\"));\n                            var eventResult = walker.fireEvent(event_1);\n                            if (eventResult instanceof Array) {\n                                if (textAccumulatorNode_1 === undefined) {\n                                    throw new Error(\"flushText running with undefined node\");\n                                }\n                                // We are never without a parentNode here.\n                                // tslint:disable-next-line:no-non-null-assertion\n                                var parent_2 = textAccumulatorNode_1.parentNode;\n                                _this._processEventResult(eventResult, parent_2, _indexOf(parent_2.childNodes, textAccumulatorNode_1));\n                            }\n                        }\n                        textAccumulator_1 = [];\n                        textAccumulatorNode_1 = undefined;\n                    };\n                    while (node !== null) {\n                        switch (node.nodeType) {\n                            case Node.TEXT_NODE:\n                                // Salve does not allow multiple text events in a row. If text is\n                                // encountered, then all the text must be passed to salve as a\n                                // single event. We record the text and will flush it to salve\n                                // later.\n                                textAccumulator_1.push(node.data);\n                                if (textAccumulatorNode_1 === undefined) {\n                                    textAccumulatorNode_1 = node;\n                                }\n                                break;\n                            case Node.ELEMENT_NODE:\n                                flushText();\n                                portion /= curEl.childElementCount;\n                                this_1._curEl = curEl = node;\n                                stage = this_1._validationStage = Stage.START_TAG;\n                                this_1._previousChild = null;\n                                return \"continue-stage_change\";\n                            case Node.COMMENT_NODE:\n                                break; // We just skip over comment nodes.\n                            default:\n                                throw new Error(\"unexpected node type: \" + node.nodeType);\n                        }\n                        node = node.nextSibling;\n                    }\n                    flushText();\n                    stage = this_1._validationStage = Stage.END_TAG;\n                    break;\n                }\n                case Stage.END_TAG: {\n                    // We've reached the end...\n                    if (curEl === this_1.root) {\n                        var eventResult = walker.end();\n                        if (eventResult instanceof Array) {\n                            this_1._processEventResult(eventResult, curEl, curEl.childNodes.length);\n                        }\n                        this_1._runDocumentValidation();\n                        this_1._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n                        this_1._partDone = 1;\n                        this_1._stop(this_1._errors.length > 0 ? WorkingState.INVALID :\n                            WorkingState.VALID);\n                        this_1._cycleEntered--;\n                        return { value: false };\n                    }\n                    // we need it later\n                    var originalElement = curEl;\n                    var tagName = curEl.tagName;\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        // We just produce the name name we produced when we encountered the\n                        // start tag.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    this_1._fireAndProcessEvent(walker, new salve_1.Event(\"endTag\", ename.ns, ename.name), curEl, curEl.childNodes.length);\n                    this_1._fireAndProcessEvent(walker, LEAVE_CONTEXT_EVENT, curEl, curEl.childNodes.length);\n                    // Go back to the parent\n                    this_1._previousChild = curEl;\n                    // We are never without a parentNode here.\n                    // tslint:disable-next-line:no-non-null-assertion\n                    this_1._curEl = curEl = curEl.parentNode;\n                    var nextDone = this_1._partDone;\n                    if (curEl !== this_1.root) {\n                        stack.shift();\n                        var first = stack[0];\n                        nextDone = first.partDone += portion;\n                        portion = first.portion;\n                    }\n                    this_1._setWorkingState(WorkingState.WORKING, nextDone);\n                    this_1._setNodeProperty(originalElement, \"EventIndexAfter\", this_1._validationEvents.length);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._cycleEntered--;\n                    return { value: true };\n                }\n                // break; would be unreachable\n                default:\n                    throw new Error(\"unexpected state\");\n            }\n        };\n        var this_1 = this;\n        stage_change: while (true) {\n            var state_1 = _loop_1();\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n            switch (state_1) {\n                case \"continue-stage_change\": continue stage_change;\n            }\n        }\n    };\n    /**\n     * Stops background validation.\n     */\n    Validator.prototype.stop = function () {\n        this._stop();\n    };\n    /**\n     * This private method takes an argument that allows setting the working state\n     * to a specific value. This is useful to reduce the number of\n     * ``state-update`` events emitted when some internal operations are\n     * performed. The alternative would be to perform a state change before or\n     * after the call to ``stop``, which would result in more events being\n     * emitted.\n     *\n     * If the parameter is unused, then the logic is that if we were not yet in a\n     * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n     *\n     * @param state The state with which to stop.\n     */\n    Validator.prototype._stop = function (state) {\n        if (this._timeoutId !== undefined) {\n            clearTimeout(this._timeoutId);\n        }\n        this._timeoutId = undefined;\n        if (state === undefined) {\n            // We are stopping prematurely, update the state\n            if (this._workingState === WorkingState.WORKING) {\n                this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n            }\n        }\n        else {\n            this._setWorkingState(state, this._partDone);\n        }\n    };\n    /**\n     * Run document-level validation that cannot be modeled by Relax NG.  The\n     * default implementation does nothing. Deriving classes may override it to\n     * call [[_processError]].\n     */\n    Validator.prototype._runDocumentValidation = function () { }; // tslint:disable-line: no-empty\n    /**\n     * Restarts validation from a specific point. After the call returns, the\n     * background validation will be in effect. (So calling it on a stopped\n     * validator has the side effect of starting it.)\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.restartAt = function (node) {\n        this.resetTo(node);\n        this.start();\n    };\n    /**\n     * Reset validation to continue from a certain point.\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.resetTo = function (node) {\n        // We use `this._resetting` to avoid a costly reinitialization if this\n        // method is called twice in a row before any work has had a chance to be\n        // done.\n        if (!this._resetting) {\n            this._resetting = true;\n            this._resetTo(node);\n        }\n    };\n    Validator.prototype._erase = function (el) {\n        this._clearNodeProperties(el);\n        var child = el.firstElementChild;\n        while (child !== null) {\n            this._erase(child);\n            child = child.nextElementSibling;\n        }\n    };\n    /**\n     * Resets validation to continue from a specific point. Any further work done\n     * by the validator will start from the point specified.\n     *\n     * @param node The element to start validation from.\n     *\n     * @emits module:validator~Validator#reset-errors\n     */\n    Validator.prototype._resetTo = function (node) {\n        // An earlier implementation was trying to be clever and to avoid restarting\n        // much earlier than strictly needed. That ended up being more costly than\n        // doing this primitive restart from 0 no matter what. Eventually, Validator\n        // should be updated so that on large documents, restarting from a location\n        // towards the end does not require revalidating the whole document. For\n        // now, since wed is used for smallish documents, it would be a premature\n        // optimization.\n        this._erase(this.root);\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationWalker = this.schema.newWalker();\n        this._validationEvents = [];\n        this._curEl = this.root;\n        this._partDone = 0;\n        this._errors = [];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        /**\n         * Tells the listener that it must reset its list of errors.\n         *\n         * @event module:validator~Validator#reset-errors\n         * @type {Object}\n         * @property {integer} at The index of the first error that must\n         * be deleted. This error and all those after it must be deleted.\n         */\n        this._events._emit(\"reset-errors\", { at: 0 });\n    };\n    /**\n     * Sets the working state of the validator. Emits a \"state-update\"\n     * event if the state has changed.\n     *\n     * @param newState The new state of the validator.\n     *\n     * @param newDone The new portion of work done.\n     *\n     * @emits module:validator~Validator#state-update\n     */\n    Validator.prototype._setWorkingState = function (newState, newDone) {\n        var changed = false;\n        if (this._workingState !== newState) {\n            this._workingState = newState;\n            changed = true;\n        }\n        if (this._partDone !== newDone) {\n            this._partDone = newDone;\n            changed = true;\n        }\n        if (changed) {\n            /**\n             * Tells the listener that the validator has changed state.\n             *\n             * @event module:validator~Validator#state-update\n             */\n            this._events._emit(\"state-update\", { state: newState, partDone: newDone });\n        }\n    };\n    /**\n     * Gets the validator working state.\n     *\n     * @returns The working state\n     */\n    Validator.prototype.getWorkingState = function () {\n        return {\n            state: this._workingState,\n            partDone: this._partDone,\n        };\n    };\n    Object.defineProperty(Validator.prototype, \"errors\", {\n        /**\n         * The current set of errors.\n         */\n        get: function () {\n            return this._errors.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Processes the result of firing a tag event. It will emit an \"error\"\n     * event for each error.\n     *\n     * @param results The results of the walker's ``fireEvent`` call.\n     *\n     * @param node The data node to which the result belongs.\n     *\n     * @param index The index into ``node`` to which the result belongs.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processEventResult = function (results, node, index) {\n        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n            var result = results_1[_i];\n            this._processError({ error: result, node: node, index: index });\n        }\n    };\n    /**\n     * This method should be called whenever a new error is detected. It\n     * records the error and emits the corresponding event.\n     *\n     * @param error The error found.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processError = function (error) {\n        this._errors.push(error);\n        /**\n         * Tells the listener that an error has occurred.\n         *\n         * @event module:validator~Validator#error\n         * @type {Object}\n         * @property {Object} error The validation error.\n         * @property {Node} node The node where the error occurred.\n         * @property {integer} index The index in this node.\n         */\n        this._events._emit(\"error\", error);\n    };\n    /**\n     * Fires all the attribute events for a given element.\n     */\n    Validator.prototype._fireAttributeEvents = function (walker, el) {\n        // Find all attributes, fire events for them.\n        var attributes = el.attributes;\n        // tslint:disable-next-line:prefer-for-of\n        for (var i = 0; i < attributes.length; ++i) {\n            var attr = attributes[i];\n            // Skip those attributes which are namespace attributes.\n            if ((attr.name === \"xmlns\") ||\n                (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n                continue;\n            }\n            if (this._fireAttributeNameEvent(walker, el, attr)) {\n                this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeValue\", attr.value), attr, 0);\n            }\n        }\n    };\n    /**\n     * Fires an attributeName event. If the attribute name is in a namespace and\n     * cannot be resolved, the event is not fired.\n     *\n     * @returns True if the event was actually fired, false if not.\n     */\n    Validator.prototype._fireAttributeNameEvent = function (walker, el, attr) {\n        var attrName = attr.name;\n        var ename = walker.resolveName(attrName, true);\n        if (ename === undefined) {\n            this._processError({ error: new salve_1.ValidationError(\"cannot resolve attribute name \" + attrName), node: attr, index: 0 });\n            return false;\n        }\n        this._setPossibleDueToWildcard(attr, walker, \"attributeName\", ename.ns, ename.name);\n        this._fireAndProcessEvent(walker, new salve_1.Event(\"attributeName\", ename.ns, ename.name), attr, 0);\n        return true;\n    };\n    /**\n     * Convenience method to fire events.\n     *\n     * @param walker The walker on which to fire events.\n     *\n     * @param event The event to fire.\n     *\n     * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n     * can be undefined for events that have no location associated with them.\n     *\n     * @param ix The index into ``el`` associated with this event, or a ``Node``\n     * which must be a child of ``el``. The index will be computed from the\n     * location of the child passed as this parameter in ``el``.\n     */\n    Validator.prototype._fireAndProcessEvent = function (walker, event, el, ix) {\n        this._validationEvents.push(event);\n        var eventResult = walker.fireEvent(event);\n        if (eventResult instanceof Array) {\n            if (el != null && ix !== undefined && typeof ix !== \"number\") {\n                ix = _indexOf(el.childNodes, ix);\n            }\n            this._processEventResult(eventResult, el, ix);\n        }\n    };\n    /**\n     * Force an immediate validation which is guaranteed to go at least up to the\n     * point specified by ``container, index``, exclusively. These parameters are\n     * interpreted in the same way a DOM caret is.\n     *\n     * If the validation has not yet reached the location specified, validation\n     * will immediately be performed to reach the point. If the validation has\n     * already reached this point, then this call is a no-op.\n     *\n     * There is one exception in the way the ``container, index`` pair is\n     * interpreted. If the container is the ``root`` that was passed when\n     * constructing the Validator, then setting ``index`` to a negative value will\n     * result in the validation validating all elements **and** considering the\n     * document complete. So unclosed tags or missing elements will be\n     * reported. Otherwise, the validation goes up the ``index`` but considers the\n     * document incomplete, and won't report the errors that are normally reported\n     * at the end of a document. For instance, unclosed elements won't be\n     * reported.\n     *\n     * @param container The location up to where to validate.\n     *\n     * @param index The location up to where to validate.\n     *\n     * @param attributes Whether we are interested to validate up to and including\n     * the attribute events of the node pointed to by ``container, index``. The\n     * validation ends before leaving the start tag.\n     *\n     * @throws {Error} If ``container`` is not of element or text type.\n     */\n    Validator.prototype._validateUpTo = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to validate after attributes but before \" +\n                \"the end of the start tag on a \" +\n                \"node which is not an element node\");\n        }\n        // Set these to reasonable defaults. The rest of the code is\n        // dedicated to changing these values to those necessary depending\n        // on specifics of what is passed to the method.\n        var toInspect = container;\n        var dataKey = \"EventIndexAfter\";\n        // This function could be called with container === root if the\n        // document is empty or if the user has the caret before the start\n        // tag of the first element of the actual structure we want to\n        // validate or after the end tag of that element.\n        if (container === this.root && index <= 0) {\n            if (attributes) {\n                dataKey = \"EventIndexAfterAttributes\";\n                toInspect = container.childNodes[index];\n            }\n            else if (index === 0) {\n                // We're before the top element, no events to fire.\n                return;\n            }\n            // default values of toInspect and dataKey are what we want\n        }\n        else {\n            if (isAttr(container)) {\n                toInspect = container.ownerElement;\n                dataKey = \"EventIndexBeforeAttributes\";\n            }\n            else {\n                switch (container.nodeType) {\n                    case Node.TEXT_NODE:\n                        toInspect = container.previousElementSibling;\n                        if (toInspect === null) {\n                            // tslint:disable-next-line:no-non-null-assertion\n                            toInspect = container.parentNode;\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    case Node.ELEMENT_NODE:\n                    case Node.DOCUMENT_FRAGMENT_NODE:\n                    case Node.DOCUMENT_NODE:\n                        var node = container.childNodes[index];\n                        var prev = node === undefined ?\n                            container.lastElementChild :\n                            // It may not be an element, in which case we get \"undefined\".\n                            node.previousElementSibling;\n                        if (attributes) {\n                            dataKey = \"EventIndexAfterAttributes\";\n                            toInspect = node;\n                        }\n                        else if (prev !== null) {\n                            toInspect = prev;\n                        }\n                        else {\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    default:\n                        throw new Error(\"unexpected node type: \" + container.nodeType);\n                }\n            }\n        }\n        while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n            this._cycle();\n        }\n    };\n    /**\n     * Gets the walker which would represent the state of parsing at the point\n     * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n     * of how these parameters are interpreted.\n     *\n     * **The walker returned by this function is not guaranteed to be a new\n     *   instance. Callers should not modify the walker returned but instead clone\n     *   it.**\n     *\n     * @param container\n     *\n     * @param index\n     *\n     * @param attributes Whether we are interested to validate up to but not\n     * including the attribute events of the node pointed to by ``container,\n     * index``. If ``true`` the walker returned will have all events fired on it\n     * up to, and including, those attribute events on the element pointed to by\n     * ``container, index``.\n     *\n     * @returns The walker.\n     *\n     * @throws {EventIndexException} If it runs out of events or computes an event\n     * index that makes no sense.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._getWalkerAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to get a walker for attribute events on a \" +\n                \"node which is not an element node\");\n        }\n        // Make sure we have the data we need.\n        this._validateUpTo(container, index, attributes);\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (!attributes) {\n                // We're before the top element, no events to fire.\n                if (index === 0) {\n                    return this.schema.newWalker();\n                }\n                // _validateUpTo ensures that the current walker held by the validator\n                // is what we want. We can just return it here because it is the\n                // caller's reponsibility to either not modify it or clone it.\n                return this._validationWalker;\n            }\n        }\n        var walker;\n        function fireTextEvent(textNode) {\n            if (walker === undefined) {\n                throw new Error(\"calling fireTextEvent without a walker\");\n            }\n            walker.fireEvent(new salve_1.Event(\"text\", textNode.data));\n        }\n        if (isAttr(container)) {\n            var el = container.ownerElement;\n            walker = this.readyWalker(\n            // tslint:disable-next-line:no-non-null-assertion\n            this.getNodeProperty(el, \"EventIndexBeforeAttributes\"));\n            // Don't fire on namespace attributes.\n            if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n                walker = walker.clone();\n                this._fireAttributeNameEvent(walker, el, container);\n            }\n        }\n        else {\n            switch (container.nodeType) {\n                case Node.TEXT_NODE: {\n                    var prev = container.previousElementSibling;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (prev !== null) {\n                        getFrom = prev;\n                        propName = \"EventIndexAfter\";\n                    }\n                    else {\n                        // tslint:disable-next-line:no-non-null-assertion\n                        getFrom = container.parentNode;\n                        propName = \"EventIndexAfterStart\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    // We will attempt to fire a text event if our location is inside the\n                    // current text node.\n                    //\n                    // A previous version of this code was also checking whether there is a\n                    // text node between this text node and prev but this cannot happen\n                    // because the tree on which validation is performed cannot have two\n                    // adjacent text nodes. It was also checking whether there was a _text\n                    // element between prev and this text node but this also cannot happen.\n                    if (index > 0) {\n                        walker = walker.clone();\n                        fireTextEvent(container);\n                    }\n                    break;\n                }\n                case Node.ELEMENT_NODE:\n                case Node.DOCUMENT_NODE:\n                case Node.DOCUMENT_FRAGMENT_NODE: {\n                    var node = container.childNodes[index];\n                    var prev = void 0;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (!attributes) {\n                        prev = node === undefined ? container.lastElementChild :\n                            node.previousElementSibling;\n                        if (prev !== null) {\n                            getFrom = prev;\n                            propName = \"EventIndexAfter\";\n                        }\n                        else {\n                            getFrom = container;\n                            propName = \"EventIndexAfterStart\";\n                        }\n                    }\n                    else {\n                        getFrom = node;\n                        propName = \"EventIndexAfterAttributes\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    if (!attributes) {\n                        // We will attempt to fire a text event if another text node appeared\n                        // between the node we care about and the element just before it.\n                        var prevSibling = node != null ? node.previousSibling : null;\n                        if (prevSibling !== null &&\n                            // If the previous sibling is the same as the previous *element*\n                            // sibbling, then there is nothing *between* that we need to take\n                            // care of.\n                            prevSibling !== prev) {\n                            if (prevSibling.nodeType === Node.TEXT_NODE) {\n                                walker = walker.clone();\n                                fireTextEvent(prevSibling);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(\"unexpected node type: \" + container.nodeType);\n            }\n        }\n        return walker;\n    };\n    Validator.prototype.readyWalker = function (eventIndex) {\n        //\n        // Perceptive readers will notice that the caching being done here could be\n        // more aggressive. It turns out that the cases where we have to clone the\n        // walker after getting it from the cache are not that frequently used, so\n        // there is little to gain from being more aggressive. Furthermore, it is\n        // likely that the caching system will change when we implement a saner way\n        // to reset validation and segment large documents into smaller chunks.\n        //\n        if (eventIndex === undefined) {\n            throw new EventIndexException();\n        }\n        var cache = this._walkerCache;\n        var max = this._walkerCacheMax;\n        var walker = cache[eventIndex];\n        if (walker) {\n            return walker;\n        }\n        //\n        // Scan the cache for a walker we could use... rather than start from zero.\n        //\n        // There is no point in trying to be clever by using this._walkerCacheGap to\n        // start our search. If _getWalkerAt is called with decreasing positions in\n        // the document, then the gap is meaningless for our search. (Such scenario\n        // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n        // cannot assume that it won't happen.)\n        //\n        // Also, the following approach is a bit crude but trying to be clever with\n        // Object.keys() and then searching through a sorted list does not yield an\n        // appreciable improvement. Maybe on very large documents it would but this\n        // module will have to be redesigned to tackle that so there's no point now\n        // to be cleverer than this. We also tested using a sparse Array for the\n        // cache and got visibly worse performance. And we tested to see if a flag\n        // indicating if the cache has anything in it would help avoid doing a long\n        // search but it maked things worse. Basically, it seems that the typical\n        // usage pattern of _getWalkerAt is such that it will usually be called in\n        // increasing order of position in the document.\n        //\n        var searchIx = eventIndex;\n        if (searchIx >= max) {\n            searchIx = max;\n            walker = cache[searchIx];\n        }\n        else {\n            while (!walker && --searchIx >= 0) {\n                walker = cache[searchIx];\n            }\n        }\n        if (walker) {\n            walker = walker.clone();\n        }\n        else {\n            walker = this.schema.newWalker();\n            searchIx = 0;\n        }\n        for (var ix = searchIx; ix < eventIndex; ++ix) {\n            walker.fireEvent(this._validationEvents[ix]);\n        }\n        // This is a bit arbitrary to find a balance between caching too much\n        // information and spending too much time computing walkers.\n        if (eventIndex - searchIx >= this._walkerCacheGap) {\n            cache[eventIndex] = walker;\n            this._walkerCacheMax = Math.max(eventIndex, max);\n        }\n        return walker;\n    };\n    /**\n     * Returns the set of possible events for the location specified by the\n     * parameters.\n     *\n     * @param container Together with ``index`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param index Together with ``container`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param attributes\n     *\n     * @returns A set of possible events.\n     */\n    Validator.prototype.possibleAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        var walker = this._getWalkerAt(container, index, attributes);\n        // Calling possible does not *modify* the walker.\n        return walker.possible();\n    };\n    /**\n     * Finds the locations in a node where a certain validation event is\n     * possible.\n     *\n     * @param container A node.\n     *\n     * @param event The event to search for. The event should be presented in the\n     * same format used for ``fireEvent``.\n     *\n     * @returns The locations in ``container`` where the event is possible.\n     */\n    Validator.prototype.possibleWhere = function (container, event) {\n        var ret = [];\n        for (var index = 0; index <= container.childNodes.length; ++index) {\n            var possible = this.possibleAt(container, index);\n            if (possible.has(event)) {\n                ret.push(index);\n            }\n            else if (event.params[0] === \"enterStartTag\" ||\n                event.params[0] === \"attributeName\") {\n                // In the case where we have a name pattern as the 2nd parameter, and\n                // this pattern can be complex or have wildcards, then we have to check\n                // all events one by one for a name pattern match. (While enterStartTag,\n                // endTag and attributeName all have name patterns, endTag cannot be\n                // complex or allow wildcards because what it allows much match the tag\n                // that started the current element.\n                for (var _i = 0, _a = possible.toArray(); _i < _a.length; _i++) {\n                    var candidate = _a[_i];\n                    if (candidate.params[0] === event.params[0] &&\n                        candidate.params[1].match(event.params[1], event.params[2])) {\n                        ret.push(index);\n                        break;\n                    }\n                }\n            }\n        }\n        return ret;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidate = function (container, index, toParse) {\n        var clone;\n        if (toParse instanceof Array) {\n            clone = container.ownerDocument.createDocumentFragment();\n            for (var _i = 0, toParse_1 = toParse; _i < toParse_1.length; _i++) {\n                var child = toParse_1[_i];\n                clone.insertBefore(child.cloneNode(true), null);\n            }\n        }\n        else {\n            clone = toParse.cloneNode(true);\n        }\n        var root = container.ownerDocument.createElement(\"div\");\n        root.insertBefore(clone, null);\n        return this.speculativelyValidateFragment(container, index, root);\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse. See above.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidateFragment = function (container, index, toParse) {\n        // This is useful for pure-JS code that may be calling this.\n        if (toParse.nodeType !== Node.ELEMENT_NODE) {\n            throw new Error(\"toParse is not an element\");\n        }\n        // We create a new validator with the proper state to parse the fragment\n        // we've been given.\n        var dup = new Validator(this.schema, toParse);\n        // We have to clone the walker to prevent messing up the internal cache.\n        dup._validationWalker = this._getWalkerAt(container, index).clone();\n        // This forces validating the whole fragment\n        dup._validateUpTo(toParse, toParse.childNodes.length);\n        if (dup._errors.length !== 0) {\n            return dup._errors;\n        }\n        return false;\n    };\n    /**\n     * Obtain the validation errors that belong to a specific node.\n     *\n     * The term \"that belong to\" has a specific meaning here:\n     *\n     * - An error in the contents of an element belongs to the element whose\n     *   contents are incorrect. For instance if in the sequence\n     *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n     *   error belongs to the node for the element ``foo``, not the node for the\n     *   element ``blip``.\n     *\n     * - Attribute errors belong to the element node to which the attributes\n     *   belong.\n     *\n     * @param node The node whose errors we want to get.\n     *\n     * @returns The errors.\n     */\n    Validator.prototype.getErrorsFor = function (node) {\n        var parent = node.parentNode;\n        if (parent === null) {\n            throw new Error(\"node without a parent!\");\n        }\n        // Validate to after the closing tag of the node.\n        this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n        var ret = [];\n        for (var _i = 0, _a = this._errors; _i < _a.length; _i++) {\n            var errorData = _a[_i];\n            if (errorData.node === node) {\n                ret.push(errorData);\n            }\n        }\n        return ret;\n    };\n    /**\n     * Sets a flag indicating whether a node is possible only due to a name\n     * pattern wildcard, and emits an event if setting the flag is a change from\n     * the previous value of the flag. It does this by inspecting the event that\n     * would be fired when ``node`` is validated. The parameters ``eventName``,\n     * ``ns`` and ``name`` are used to determine what we are looking for among\n     * possible events.\n     *\n     * @param node The node we want to check.\n     *\n     * @param walker A walker whose last fired event is the one just before the\n     * event that would be fired when validating ``node``.\n     *\n     * @param eventName The event name we are interested in.\n     *\n     * @param ns The namespace to use with the event.\n     *\n     * @param name The name to use with the event.\n     *\n     * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n     *\n     */\n    Validator.prototype._setPossibleDueToWildcard = function (node, walker, eventName, ns, name) {\n        var previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n        var possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n        this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n        if (previous === undefined || previous !== possible) {\n            /**\n             * Tells the listener that a node's flag indicating whether it is possible\n             * only due to a wildcard has changed.\n             *\n             * @event module:validator~Validator#possible-due-to-wildcard-change\n             *\n             * @type {Node} The node whose flag has changed.\n             */\n            this._events._emit(\"possible-due-to-wildcard-change\", node);\n        }\n    };\n    /**\n     * Resolve a qualified name to an expanded name. See\n     * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n     * takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param name The name to rresolve.\n     *\n     * @param attributes Whether the name is an attribute's name.\n     *\n     * @return The resolved name.\n     */\n    Validator.prototype.resolveNameAt = function (container, index, name, attribute) {\n        if (attribute === void 0) { attribute = false; }\n        // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n        // its ``attribute`` parameter ``false``.\n        return this._getWalkerAt(container, index).resolveName(name, attribute);\n    };\n    /**\n     * Unresolve an expanded name to a qualified name. See\n     * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n     * method takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param uri The URI to unresolve.\n     *\n     * @param name The name to unresolve.\n     *\n     * @return The unresolved name.\n     */\n    Validator.prototype.unresolveNameAt = function (container, index, uri, name) {\n        return this._getWalkerAt(container, index).unresolveName(uri, name);\n    };\n    return Validator;\n}());\nexports.Validator = Validator;\n\n//# sourceMappingURL=main.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/main.js\n// module id = 3\n// module chunks = 0 1"],"sourceRoot":""}