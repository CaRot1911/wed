{"version":3,"sources":["../../../wed/labelman.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;;;;;;;;;;;IAEH;;;;;OAKG;IACH;QAUE;;;WAGG;QACH,sBAA4B,IAAY;YAAZ,SAAI,GAAJ,IAAI,CAAQ;YAbxC,kDAAkD;YACxC,eAAU,GAA2B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAEnE;;;eAGG;YACO,eAAU,GAAW,CAAC,CAAC;QAMU,CAAC;QAc5C;;;;;;;;;;WAUG;QACH,gCAAS,GAAT,UAAU,EAAU;YAClB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;QAC7B,CAAC;QAED;;;WAGG;QACH,oCAAa,GAAb;YACE,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACtC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;YACpB,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC9B,CAAC;QAQD;;;;;WAKG;QACH,iCAAU,GAAV;YACE,MAAM,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC;QAC3B,CAAC;QACH,mBAAC;IAAD,CApEA,AAoEC,IAAA;IApEqB,oCAAY;IAsElC,IAAM,QAAQ,GAAG,4BAA4B,CAAC;IAE9C;;;;;;;OAOG;IACH;QAA4C,0CAAY;QAAxD;;QAkBA,CAAC;QAhBC,8CAAa,GAAb,UAAc,EAAU;YACtB,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;YAChC,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;gBACxB,0DAA0D;gBAC1D,IAAM,EAAE,GAAG,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;gBACjC,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;gBACtC,IAAM,MAAM,GAAG,EAAE,GAAG,EAAE,CAAC;gBACvB,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC;YAC9B,CAAC;YAED,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAED,oCAAoC;QACpC,qDAAoB,GAApB,cAA8B,CAAC;QACjC,6BAAC;IAAD,CAlBA,AAkBC,CAlB2C,YAAY,GAkBvD;IAlBY,wDAAsB;;AAoBnC,gEAAgE;AAChE,6CAA6C","file":"labelman.js","sourcesContent":["/**\n * Label manager.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\n/**\n * Maintains a mapping from HTML element id to labels meaningful to humans. Also\n * keeps a counter that can be used for assigning new ids to elements that don't\n * already have one.\n *\n */\nexport abstract class LabelManager {\n  /** A mapping of element id to allocated label. */\n  protected _idToLabel: Record<string, string> = Object.create(null);\n\n  /**\n   * A counter that must be incremented with each new label allocation. This\n   * allows the allocation algorithm to know what the next label should be.\n   */\n  protected labelIndex: number = 0;\n\n  /**\n   * @param name The name of this label manager. This is a convenience that can\n   * be used to produce distinctive error messages, for instance.\n   */\n  constructor(public readonly name: string) {}\n\n  /**\n   * Allocate a label for an id. The relation between id and label remains\n   * constant until [[deallocateAll]] is called.\n   *\n   * @param id The id of the element.\n   *\n   * @returns The allocated label. If the method is called multiple times with\n   * the same ``id``, the return value must be the same. It may change only if\n   * [[deallocateAll]] has been called between the calls to this method.\n   */\n  abstract allocateLabel(id: string): string;\n\n  /**\n   * Gets the label associated with an id.\n   *\n   * @param id The id.\n   *\n   * @returns The label. The value returned by this method obeys the same rules\n   * as that of [[allocateLabel]] with the exception that if a call returned\n   * ``undefined`` it may return another value on a subsequent call. (That is,\n   * an ``id`` that did not have a label allocated to it may acquire such\n   * label.)\n   */\n  idToLabel(id: string): string | undefined {\n    return this._idToLabel[id];\n  }\n\n  /**\n   * Deallocate all mappings between ids and labels. This will reset\n   * [[_idToLabel]] to an empty map and [[labelIndex]] to 0.\n   */\n  deallocateAll(): void {\n    this._idToLabel = Object.create(null);\n    this.labelIndex = 0;\n    this._deallocateAllLabels();\n  }\n\n  /**\n   * Clear out the labels that were allocated. This method is called by\n   * [[deallocateAll]] to perform class-specific cleanup.\n   */\n  protected abstract _deallocateAllLabels(): void;\n\n  /**\n   * Gets the next number in the number sequence. This increments\n   * [[labelIndex]].\n   *\n   * @returns The number.\n   */\n  nextNumber(): number {\n    return ++this.labelIndex;\n  }\n}\n\nconst alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n/**\n * A label manager that associates alphabetical labels to each id given to\n * it. It will associate labels \"a\", \"b\", \"c\", ... up to \"z\" and then will\n * associate \"aa\", \"bb\", \"cc\", ... up to \"zz\", and continues repeating\n * characters each time it cycles over the alphabet.\n *\n * @param {string} name The name of this label manager.\n */\nexport class AlphabeticLabelManager extends LabelManager {\n\n  allocateLabel(id: string): string {\n    let label = this._idToLabel[id];\n    if (label === undefined) {\n      // nextNumber() will start with 1, so we have to subtract.\n      const ix = this.nextNumber() - 1;\n      const round = Math.floor(ix / 26) + 1;\n      const charIx = ix % 26;\n      label = alphabet[charIx].repeat(round);\n      this._idToLabel[id] = label;\n    }\n\n    return label;\n  }\n\n  // tslint:disable-next-line:no-empty\n  _deallocateAllLabels(): void {}\n}\n\n//  LocalWords:  LabelManager jshint MPL overriden allocateLabel\n//  LocalWords:  oop Mangalam Dubeau labelman\n"]}