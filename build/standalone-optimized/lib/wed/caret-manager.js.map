{"version":3,"file":"caret-manager.js","sourceRoot":"","sources":["../../../../lib/wed/caret-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Caret management.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport * as $ from \"jquery\";\nimport { Observable } from \"rxjs/Observable\";\nimport { Subject } from \"rxjs/Subject\";\n\nimport * as browsers from \"./browsers\";\nimport { CaretMark } from \"./caret-mark\";\nimport * as caretMovement from \"./caret-movement\";\nimport { DLoc, DLocRange, DLocRoot } from \"./dloc\";\nimport { isAttr, isElement, isText } from \"./domtypeguards\";\nimport { childByClass, closestByClass, contains, dumpRange,\n         focusNode as focusTheNode, getSelectionRange, indexOf,\n         RangeInfo } from \"./domutil\";\nimport { GUIUpdater } from \"./gui-updater\";\nimport { Layer } from \"./gui/layer\";\nimport { Scroller } from \"./gui/scroller\";\nimport { Mode } from \"./mode\";\nimport { ModeTree } from \"./mode-tree\";\nimport * as objectCheck from \"./object-check\";\nimport { GUIToDataConverter, WedSelection } from \"./wed-selection\";\nimport { getAttrValueNode } from \"./wed-util\";\n\n/**\n * This is the template use with objectCheck to check whether the options passed\n * are correct. Changes to [[SetCaretOptions]] must be reflected here.\n */\nconst caretOptionTemplate = {\n  textEdit: false,\n  focus: false,\n};\n\n/** Options affecting how a caret gets set. */\nexport interface SetCaretOptions {\n  /**\n   * When ``true`` indicates that the caret movement is due to a text editing\n   * operation. This matters for managing undo steps. Text edits are gathered\n   * into an single text undo step unless they are interrupted by some other\n   * operation (or reach a maximum size). Caret movements also interrupt the\n   * text undo steps, unless this flag is ``true``. The default is ``false``.\n   */\n  textEdit?: boolean;\n\n  /**\n   * Indicates whether the caret change should set the focus. The default is\n   * ``true``.\n   */\n  focus?: boolean;\n}\n\n/** These are options that wed passes to itself. */\nexport interface CaretChangeOptions extends SetCaretOptions {\n  /** Indicates whether the caret is being changed due to a gain in focus. */\n  gainingFocus?: boolean;\n}\n\n/**\n * An event generated when the caret changes.\n */\nexport interface CaretChange {\n  /** The manager from which the event originates. */\n  manager: CaretManager;\n\n  /** The new caret. */\n  caret: DLoc | undefined;\n\n  /** The previous caret value before the change. */\n  prevCaret: DLoc | undefined;\n\n  /** The mode at which the current caret is located. */\n  mode: Mode | undefined;\n\n  /** The previous mode in effect before the change. */\n  prevMode: Mode | undefined;\n\n  /** The change options. */\n  options: CaretChangeOptions;\n}\n\n/**\n * Find a previous sibling which is either a text node or a node with the class\n * ``_real``.\n *\n * @param node The element whose sibling we are looking for.\n *\n * @param cl The class to use for matches.\n *\n * @returns The first sibling (searing in reverse document order from ``node``)\n * that matches the class, or ``null`` if nothing matches.\n */\nfunction previousTextOrReal(node: Node): Text | Element | null {\n  if (!isElement(node)) {\n    return null;\n  }\n\n  let child = node.previousSibling;\n  while (child !== null &&\n         !(isText(child) ||\n          (isElement(child) && child.classList.contains(\"_real\")))) {\n    child = child.previousSibling;\n  }\n  return child;\n}\n\n/**\n * A caret manager maintains and modifies caret and selection positions. It also\n * manages associated GUI elements like the input field. It is also responsible\n * for converting positions in the GUI tree to positions in the data tree and\n * vice-versa.\n *\n * Given wed's notion of parallel data and GUI trees. A caret can either point\n * into the GUI tree or into the data tree. In the following documentation, if\n * the caret is not qualified, then it is a GUI caret.\n *\n * Similarly, a selection can either span a range in the GUI tree or in the data\n * tree. Again, \"selection\" without qualifier is a GUI selection.\n */\nexport class CaretManager implements GUIToDataConverter {\n  private _sel: WedSelection | undefined;\n  private selAtBlur: WedSelection | undefined;\n  private readonly guiRootEl: Document | Element;\n  private readonly dataRootEl: Document | Element;\n  private readonly $inputField: JQuery;\n  private readonly doc: Document;\n  private readonly win: Window;\n  private readonly selectionStack: (WedSelection | undefined)[] = [];\n  private prevCaret: DLoc | undefined;\n  private prevMode: Mode | undefined;\n\n  private readonly _events: Subject<CaretChange>;\n\n  /** This is where you can listen to caret change events. */\n  readonly events: Observable<CaretChange>;\n\n  /** The caret mark that represents the caret managed by this manager. */\n  readonly mark: CaretMark;\n\n  /**\n   * @param guiRoot The object representing the root of the gui tree.\n   *\n   * @param dataRoot The object representing the root of the data tree.\n   *\n   * @param inputField The HTML element that is the input field.\n   *\n   * @param guiUpdater The GUI updater that is responsible for updating the\n   * tree whose root is ``guiRoot``.\n   *\n   * @param layer The layer that holds the caret.\n   *\n   * @param scroller The element that scrolls ``guiRoot``.\n   *\n   * @param modeTree The mode tree from which to get modes.\n   */\n  constructor(private readonly guiRoot: DLocRoot,\n              private readonly dataRoot: DLocRoot,\n              private readonly inputField: HTMLElement,\n              private readonly guiUpdater: GUIUpdater,\n              private readonly layer: Layer,\n              private readonly scroller: Scroller,\n              private readonly modeTree: ModeTree) {\n    this.mark = new CaretMark(this, guiRoot.node.ownerDocument, layer,\n                              inputField, scroller);\n    const guiRootEl = this.guiRootEl = guiRoot.node;\n    this.dataRootEl = dataRoot.node;\n    this.doc = guiRootEl.ownerDocument;\n    this.win = this.doc.defaultView;\n    this.$inputField = $(this.inputField);\n    this._events = new Subject();\n    this.events = this._events.asObservable();\n\n    $(this.guiRootEl).on(\"focus\", (ev) => {\n      this.focusInputField();\n      ev.preventDefault();\n      ev.stopPropagation();\n    });\n\n    $(this.win).on(\"blur.wed\", this.onBlur.bind(this));\n    $(this.win).on(\"focus.wed\", this.onFocus.bind(this));\n  }\n\n  /**\n   * The raw caret. Use [[getNormalizedCaret]] if you need it normalized.\n   *\n   * This is synonymous with the focus of the current selection. (`foo.caret ===\n   * foo.focus === foo.sel.focus`).\n   */\n  get caret(): DLoc | undefined {\n    return this.focus;\n  }\n\n  /**\n   * The current selection.\n   */\n  get sel(): WedSelection | undefined {\n    return this._sel;\n  }\n\n  /**\n   * The focus of the current selection.\n   */\n  get focus(): DLoc | undefined {\n    if (this._sel === undefined) {\n      return undefined;\n    }\n\n    return this._sel.focus;\n  }\n\n  /**\n   * The anchor of the current selection.\n   */\n  get anchor(): DLoc | undefined {\n    if (this._sel === undefined) {\n      return undefined;\n    }\n\n    return this._sel.anchor;\n  }\n\n  /**\n   * The range formed by the current selection.\n   */\n  get range(): Range | undefined {\n    const info = this.rangeInfo;\n    return info !== undefined ? info.range : undefined;\n  }\n\n  /**\n   * A range info object describing the current selection.\n   */\n  get rangeInfo(): RangeInfo | undefined {\n    const sel = this._sel;\n\n    if (sel === undefined) {\n      return undefined;\n    }\n\n    return sel.rangeInfo;\n  }\n\n  get minCaret(): DLoc {\n    return DLoc.mustMakeDLoc(this.guiRoot, this.guiRootEl, 0);\n  }\n\n  get maxCaret(): DLoc {\n    return  DLoc.mustMakeDLoc(this.guiRoot, this.guiRootEl,\n                              this.guiRootEl.childNodes.length);\n  }\n\n  get docDLocRange(): DLocRange {\n    return new DLocRange(this.minCaret, this.maxCaret);\n  }\n\n  /**\n   * Get a normalized caret.\n   *\n   * @returns A normalized caret, or ``undefined`` if there is no caret.\n   */\n  getNormalizedCaret(): DLoc | undefined {\n    let caret = this.caret;\n    if (caret === undefined) {\n      return caret;\n    }\n\n    // The node is not in the root. This could be due to a stale location.\n    if (!this.guiRootEl.contains(caret.node)) {\n      return undefined;\n    }\n\n    if (!caret.isValid()) {\n      const newSel =  new WedSelection(this,\n                                       this.anchor!, caret.normalizeOffset());\n      this._sel = newSel;\n      caret = newSel.focus;\n    }\n\n    const normalized = this._normalizeCaret(caret);\n    return normalized == null ? undefined : normalized;\n  }\n\n  /**\n   * Same as [[getNormalizedCaret]] but must return a location.\n   *\n   * @throws {Error} If it cannot return a location.\n   */\n  mustGetNormalizedCaret(): DLoc {\n    const ret = this.getNormalizedCaret();\n    if (ret === undefined) {\n      throw new Error(\"cannot get a normalized caret\");\n    }\n\n    return ret;\n  }\n\n  normalizeToEditableRange(loc: DLoc): DLoc {\n    if (loc.root !== this.guiRootEl) {\n      throw new Error(\"DLoc object must be for the GUI tree\");\n    }\n\n    let offset = loc.offset;\n    const node = loc.node;\n\n    if (isElement(node)) {\n      // Normalize to a range within the editable nodes. We could be outside of\n      // them in an element which is empty, for instance.\n      const mode = this.modeTree.getMode(node);\n      const [first, second] = mode.nodesAroundEditableContents(node);\n      const firstIndex = first !== null ? indexOf(node.childNodes, first) : -1;\n      if (offset <= firstIndex) {\n        offset = firstIndex + 1;\n      }\n      else {\n        const secondIndex = second !== null ?\n          indexOf(node.childNodes, second) : node.childNodes.length;\n        if (offset >= secondIndex) {\n          offset = secondIndex;\n        }\n      }\n\n      return loc.makeWithOffset(offset);\n    }\n\n    return loc;\n  }\n\n  /**\n   * Get the current caret position in the data tree.\n   *\n   * @param approximate Some GUI locations do not correspond to data\n   * locations. Like if the location is in a gui element or phantom text. By\n   * default, this method will return undefined in such case. If this parameter\n   * is true, then this method will return the closest position.\n   *\n   * @returns A caret position in the data tree, or ``undefined`` if no such\n   * position exists.\n   */\n  getDataCaret(approximate?: boolean): DLoc | undefined {\n    const caret = this.getNormalizedCaret();\n    if (caret === undefined) {\n      return undefined;\n    }\n\n    return this.toDataLocation(caret, approximate);\n  }\n\n  /**\n   * Convert a caret location in the data tree into one in the GUI tree.\n   *\n   * @param loc A location in the data tree.\n   *\n   * @param node A node in the data tree, if ``loc`` is not used.\n   *\n   * @param offset An offset into ``node`` if ``loc`` is not used.\n   *\n   * @returns A location in the GUI tree, or ``undefined`` if no such location\n   * exists.\n   */\n  fromDataLocation(loc: DLoc): DLoc | undefined;\n  fromDataLocation(node: Node, offset: number): DLoc | undefined;\n  fromDataLocation(node: Node | DLoc, offset?: number): DLoc | undefined {\n    if (node instanceof DLoc) {\n      offset = node.offset;\n      node = node.node;\n    }\n\n    if (offset === undefined) {\n      throw new Error(\"offset is undefined\");\n    }\n\n    const ret = this.guiUpdater.fromDataLocation(node, offset);\n    if (ret === null) {\n      return undefined;\n    }\n\n    let newOffset = ret.offset;\n    node = ret.node;\n    if (isElement(node)) {\n      // Normalize to a range within the editable nodes. We could be outside of\n      // them in an element which is empty, for instance.\n      const mode = this.modeTree.getMode(node);\n      const [first, second] = mode.nodesAroundEditableContents(node);\n      const firstIndex = (first !== null) ? indexOf(node.childNodes, first) :\n        -1;\n\n      if (newOffset <= firstIndex) {\n        newOffset = firstIndex + 1;\n      }\n      else {\n        const secondIndex = second !== null ? indexOf(node.childNodes, second) :\n              node.childNodes.length;\n        if (newOffset >= secondIndex) {\n          newOffset = secondIndex;\n        }\n      }\n\n      return ret.makeWithOffset(newOffset);\n    }\n\n    return ret;\n  }\n\n  /**\n   * Does the same thing as [[fromDataLocation]] but must return a defined\n   * location.\n   *\n   * @throws {Error} If it cannot return a location.\n   */\n  mustFromDataLocation(loc: DLoc): DLoc;\n  mustFromDataLocation(node: Node, offset: number): DLoc;\n  mustFromDataLocation(node: Node | DLoc, offset?: number): DLoc {\n    const ret = this.fromDataLocation.apply(this, arguments);\n    if (ret === undefined) {\n      throw new Error(\"cannot convert to a data location\");\n    }\n\n    return ret;\n  }\n\n  /**\n   * Converts a gui location to a data location.\n   *\n   * @param loc A location in the GUI tree.\n   *\n   * @param node A node which, with the next parameter, represents a position.\n   *\n   * @param offset The offset in the node in the first parameter.\n   *\n   * @param approximate Some GUI locations do not correspond to data\n   * locations. Like if the location is in a gui element or phantom text. By\n   * default, this method will return undefined in such case. If this parameter\n   * is true, then this method will return the closest position.\n   *\n   * @returns The data location that corresponds to the location passed. This\n   * could be ``undefined`` if the location does not correspond to a location in\n   * the data tree.\n   */\n  toDataLocation(loc: DLoc, approximate?: boolean): DLoc | undefined;\n  toDataLocation(node: Node, offset: number,\n                 approximate?: boolean): DLoc | undefined;\n  // tslint:disable-next-line:cyclomatic-complexity\n  toDataLocation(loc: DLoc | Node, offset: number | boolean = false,\n                 approximate: boolean = false): DLoc | undefined {\n    let node;\n    let root;\n    if (loc instanceof DLoc) {\n      if (typeof offset !== \"boolean\") {\n        throw new Error(\"2nd argument must be a boolean\");\n      }\n      approximate = offset;\n      ({ offset, node, root } = loc);\n    }\n    else {\n      node = loc;\n    }\n\n    if (typeof offset !== \"number\") {\n      throw new Error(\"offset must be a number\");\n    }\n\n    let initialCaret = this.makeCaret(node, offset);\n    if (closestByClass(node, \"_attribute_value\", root) === null) {\n      const wrap = closestByClass(node, \"_phantom_wrap\", root);\n      if (wrap !== null) {\n        // We are in a phantom wrap. Set position to the real element being\n        // wrapped. This is not considered to be an \"approximation\" because\n        // _phantom_wrap elements are considered visual parts of the real\n        // element.\n        initialCaret = this.makeCaret(wrap.getElementsByClassName(\"_real\")[0]);\n      }\n      else {\n        let topPg;\n        let check = (isText(node) ? node.parentNode : node) as Element;\n        while (check !== null && check !== this.guiRootEl) {\n          if ((check.classList.contains(\"_phantom\") ||\n               check.classList.contains(\"_gui\"))) {\n            // We already know that the caller does not want an approximation.\n            // No point in going on.\n            if (!approximate) {\n              return undefined;\n            }\n            topPg = check;\n          }\n\n          check = check.parentNode as Element;\n        }\n\n        if (topPg !== undefined) {\n          initialCaret = this.makeCaret(topPg);\n        }\n      }\n    }\n\n    const normalized = this._normalizeCaret(initialCaret);\n    if (normalized == null) {\n      return undefined;\n    }\n    ({ node, offset } = normalized);\n\n    let dataNode = this.dataRoot.pathToNode(this.guiRoot.nodeToPath(node));\n    if (isText(node)) {\n      return this.makeCaret(dataNode, offset, true);\n    }\n\n    if (offset >= node.childNodes.length) {\n      return dataNode === null ? undefined :\n        this.makeCaret(dataNode, dataNode.childNodes.length);\n    }\n\n    // If pointing to a node that is not a text node or a real element, we must\n    // find the previous text node or real element and return a position which\n    // points after it.\n    const child = node.childNodes[offset];\n    if (isElement(child) && !child.classList.contains(\"_real\")) {\n      const found = previousTextOrReal(child);\n      if (found === null) {\n        return this.makeCaret(dataNode, 0);\n      }\n\n      dataNode = this.dataRoot.pathToNode(this.guiRoot.nodeToPath(found));\n\n      if (dataNode === null) {\n        return undefined;\n      }\n\n      const parent = dataNode.parentNode!;\n      return this.makeCaret(parent, indexOf(parent.childNodes, dataNode) + 1);\n    }\n\n    dataNode = this.dataRoot.pathToNode(this.guiRoot.nodeToPath(child));\n    return this.makeCaret(dataNode, isAttr(dataNode) ? offset : undefined);\n  }\n\n  /**\n   * Modify the passed position so that it if appears inside of a placeholder\n   * node, the resulting position is moved out of it.\n   *\n   * @param loc The location to normalize.\n   *\n   * @returns The normalized position. If ``undefined`` or ``null`` was passed,\n   * then the return value is the same as what was passed.\n   */\n  private _normalizeCaret(loc: DLoc | undefined | null):\n  DLoc | undefined | null {\n    if (loc == null) {\n      return loc;\n    }\n\n    const pg = closestByClass(loc.node, \"_placeholder\", loc.root);\n    // If we are in a placeholder: make the caret be the parent of the this\n    // node.\n    return (pg !== null) ? loc.make(pg) : loc;\n  }\n\n  /**\n   * Make a caret from a node and offset pair.\n   *\n   * @param node The node from which to make the caret. The node may be in the\n   * GUI tree or the data tree. If ``offset`` is omitted, the resulting location\n   * will point to this node (rather than point to some offset *inside* the\n   * node.)\n   *\n   * @param offset The offset into the node.\n   *\n   * @param normalize Whether to normalize the location. (Note that this is\n   * normalization in the [[DLoc]] sense of the term.)\n   *\n   * @returns A new caret. This will be ``undefined`` if the value passed for\n   * ``node`` was undefined or if the node is not in the GUI or data trees.\n   */\n  makeCaret(node: Node | null | undefined, offset?: number,\n            normalize: boolean = false): DLoc | undefined {\n    if (node == null) {\n      return undefined;\n    }\n\n    let root;\n    if (this.guiRootEl.contains(node)) {\n      root = this.guiRoot;\n    }\n    else if (contains(this.dataRootEl, node)) {\n      root = this.dataRoot;\n    }\n\n    if (root === undefined) {\n      return undefined;\n    }\n\n    return DLoc.mustMakeDLoc(root, node, offset, normalize);\n  }\n\n  /**\n   * Set the range to a new value.\n   *\n   * @param anchor The range's anchor.\n   *\n   * @param anchorNode The anchor's node.\n   *\n   * @param anchorOffset The anchor's offset.\n   *\n   * @param focus The range's focus.\n   *\n   * @param focusNode The focus' node.\n   *\n   * @param focusOffset The focus's offset.\n   */\n  setRange(anchorNode: Node, anchorOffset: number, focusNode: Node,\n           focusOffset: number): void;\n  setRange(anchor: DLoc, focus: DLoc): void;\n  setRange(anchorNode: DLoc | Node, anchorOffset: DLoc | number,\n           focusNode?: Node, focusOffset?: number): void {\n    let anchor;\n    let focus;\n    if (anchorNode instanceof DLoc && anchorOffset instanceof DLoc) {\n      anchor = anchorNode;\n      focus = anchorOffset;\n    }\n    else {\n      anchor = this.makeCaret(anchorNode as Node, anchorOffset as number);\n      focus = this.makeCaret(focusNode, focusOffset);\n    }\n\n    if (anchor === undefined || focus === undefined) {\n      throw new Error(\"must provide both anchor and focus\");\n    }\n\n    if (anchor.root === this.dataRootEl) {\n      anchor = this.fromDataLocation(anchor);\n      focus = this.fromDataLocation(focus);\n\n      if (anchor === undefined || focus === undefined) {\n        throw new Error(\"cannot find GUI anchor and focus\");\n      }\n    }\n\n    const sel = this._sel = new WedSelection(this, anchor, focus);\n\n    // This check reduces selection fiddling by an order of magnitude when just\n    // straightforwardly selecting one character.\n    if (this.prevCaret === undefined || !this.prevCaret.equals(focus)) {\n      this.mark.refresh();\n      const range = sel.range;\n      if (range === undefined) {\n        throw new Error(\"unable to make a range\");\n      }\n\n      this._setDOMSelectionRange(range);\n    }\n\n    this._caretChange();\n  }\n\n  /**\n   * Compute a position derived from an arbitrary position. Note that\n   * this method is meant to be used for positions in the GUI tree. Computing\n   * positions in the data tree requires no special algorithm.\n   *\n   * This method does not allow movement outside of the GUI tree.\n   *\n   * @param pos The starting position in the GUI tree.\n   *\n   * @param direction The direction in which to move.\n   *\n   * @return The position to the right of the starting position. Or\n   * ``undefined`` if the starting position was undefined or if there is no\n   * valid position to compute.\n   */\n  newPosition(pos: DLoc | undefined,\n              direction: caretMovement.Direction): DLoc | undefined {\n    return caretMovement.newPosition(pos, direction,\n                                     this.guiRootEl,\n                                     this.modeTree);\n  }\n\n  /**\n   * Compute the position of the current caret if it were moved according to\n   * some direction.\n   *\n   * @param direction The direction in which the caret would be moved.\n   *\n   * @return The position to the right of the caret position. Or ``undefined``\n   * if there is no valid position to compute.\n   */\n  newCaretPosition(direction: caretMovement.Direction): DLoc | undefined {\n    return this.newPosition(this.caret, direction);\n\n  }\n\n  /**\n   * Move the caret in a specific direction. The caret may not move if it is\n   * not possible to move in the specified direction.\n   *\n   * @param direction The direction in which to move.\n   */\n  move(direction: caretMovement.Direction, extend: boolean = false): void {\n    const pos = this.newCaretPosition(direction);\n    if (pos === undefined) {\n      return;\n    }\n\n    if (!extend) {\n      this.setCaret(pos);\n    }\n    else {\n      const anchor = this.anchor;\n      if (anchor !== undefined) {\n        this.setRange(anchor, pos);\n      }\n    }\n  }\n\n  /**\n   * Set the caret to a new position.\n   *\n   * @param loc The new position for the caret.\n   *\n   * @param node The new position for the caret. This may be ``undefined`` or\n   * ``null``, in which case the method does not do anything.\n   *\n   * @param offset The offset in ``node``.\n   *\n   * @param options The options for moving the caret.\n   */\n  setCaret(loc: DLoc, options?: SetCaretOptions): void;\n  setCaret(node: Node | null | undefined,\n           offset?: number, options?: SetCaretOptions): void;\n  setCaret(node: Node | DLoc | null | undefined,\n           offset?: number | SetCaretOptions,\n           options?: SetCaretOptions): void {\n    let loc: DLoc;\n    if (node instanceof DLoc) {\n      loc = node;\n      if (typeof offset === \"number\") {\n        throw new Error(\"2nd argument must be options\");\n      }\n      options = offset;\n      offset = undefined;\n    }\n    else {\n      if (offset !== undefined && typeof offset !== \"number\") {\n        throw new Error(\"2nd argument must be number\");\n      }\n      const newLoc = this.makeCaret(node, offset);\n\n      if (newLoc === undefined) {\n        return;\n      }\n\n      loc = newLoc;\n    }\n\n    if (options !== undefined) {\n      objectCheck.assertSummarily(caretOptionTemplate, options);\n    }\n    else {\n      options = {};\n    }\n\n    this._setGUICaret(loc.root === this.guiRootEl ?\n                      loc : this.fromDataLocation(loc)!, options);\n  }\n\n  /**\n   * Set the caret into a normalized label position. There are only some\n   * locations in which it is valid to put the caret inside a label:\n   *\n   * - The element name.\n   *\n   * - Inside attribute values.\n   *\n   * This method is used by DOM event handlers (usually mouse events handlers)\n   * to normalize the location of the caret to one of the valid locations listed\n   * above.\n   *\n   * @param target The target of the DOM event that requires moving the caret.\n   *\n   * @param label The label element that contains ``target``.\n   *\n   * @param location The location of the event, which is what is normalized by\n   * this method.\n   */\n  setCaretToLabelPosition(target: Node, label: Element, location: DLoc): void {\n    let node;\n    let offset = 0;\n    // Note that in the code that follows, the choice between testing against\n    // ``target`` or against ``location.node`` is not arbitrary.\n    const attr = closestByClass(target, \"_attribute\", label);\n    if (attr !== null) {\n      if (closestByClass(location.node, \"_attribute_value\", label) !== null) {\n        ({ node, offset } = location);\n      }\n      else {\n        node = getAttrValueNode(\n          attr.getElementsByClassName(\"_attribute_value\")[0]);\n      }\n    }\n    else {\n      // Find the element name and put it there.\n      node = label.getElementsByClassName(\"_element_name\")[0];\n    }\n\n    this.setCaret(node, offset);\n  }\n\n  /**\n   * Save the current selection (and caret) on an internal selection stack.\n   */\n  pushSelection(): void {\n    this.selectionStack.push(this._sel);\n  }\n\n  /**\n   * Pop the last selection that was pushed with ``pushSelection`` and restore\n   * the current caret and selection on the basis of the popped value.\n   */\n  popSelection(): void {\n    this._sel = this.selectionStack.pop();\n    this._restoreCaretAndSelection(false);\n  }\n\n  /**\n   * Pop the last selection that was pushed with ``pushSelection`` but do not\n   * restore the current caret and selection from the popped value.\n   */\n  popSelectionAndDiscard(): void {\n    this.selectionStack.pop();\n  }\n\n  /**\n   * Restores the caret and selection from the current selection. This is used\n   * to deal with situations in which the caret and range may have been\n   * \"damaged\" due to browser operations, changes of state, etc.\n   *\n   * @param gainingFocus Whether the restoration of the caret and selection is\n   * due to regaining focus or not.\n   */\n  private _restoreCaretAndSelection(gainingFocus: boolean):\n  void {\n    if (this.caret !== undefined && this.anchor !== undefined &&\n        // It is possible that the anchor has been removed after focus was lost\n        // so check for it.\n        this.guiRootEl.contains(this.anchor.node)) {\n      const range = this.range;\n      if (range === undefined) {\n        throw new Error(\"could not make a range\");\n      }\n\n      this._setDOMSelectionRange(range);\n\n      // We're not selecting anything...\n      if (range.collapsed) {\n        this.focusInputField();\n      }\n      this.mark.refresh();\n      this._caretChange({ gainingFocus });\n    }\n    else {\n      this.clearSelection();\n    }\n  }\n\n  /**\n   * Clear the selection and caret.\n   */\n  clearSelection(): void {\n    this._sel = undefined;\n    this.mark.refresh();\n    const sel = this._getDOMSelection();\n    if (sel.rangeCount > 0 && this.guiRootEl.contains(sel.focusNode)) {\n      sel.removeAllRanges();\n    }\n    this._caretChange();\n  }\n\n  /**\n   * Get the current selection from the DOM tree.\n   */\n  private _getDOMSelectionRange(): Range | undefined {\n    const range = getSelectionRange(this.win);\n\n    if (range === undefined) {\n      return undefined;\n    }\n\n    // Don't return a range outside our editing framework.\n    if (!this.guiRootEl.contains(range.startContainer) ||\n        !this.guiRootEl.contains(range.endContainer)) {\n      return undefined;\n    }\n\n    return range;\n  }\n\n  /**\n   * This function is meant to be used internally to manipulate the DOM\n   * selection directly.\n   */\n  private _setDOMSelectionRange(range: Range): void {\n    if (range.collapsed) {\n      this._clearDOMSelection();\n      return;\n    }\n\n    // tslint:disable-next-line:no-suspicious-comment\n    // The focusTheNode call is required to work around bug:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=921444\n    if (browsers.FIREFOX) {\n      focusTheNode(range.endContainer);\n    }\n\n    const sel = this._getDOMSelection();\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  /**\n   * Sets the caret position in the GUI tree.\n   *\n   * @param loc The new position.\n   *\n   * @param options Set of options governing the caret movement.\n   */\n  private _setGUICaret(loc: DLoc, options: SetCaretOptions): void {\n    let offset = loc.offset;\n    let node = loc.node;\n\n    // We accept a location which has for ``node`` a node which is an\n    // _attribute_value with an offset. However, this is not an actually valid\n    // caret location. So we normalize the location to point inside the text\n    // node that contains the data.\n    if (isElement(node)) {\n      if (node.classList.contains(\"_attribute_value\")) {\n        const attr = getAttrValueNode(node);\n        if (node !== attr) {\n          node = attr;\n          loc = loc.make(node, offset);\n        }\n      }\n\n      // Placeholders attract adjacent carets into them.\n      const ph = childByClass(node, \"_placeholder\");\n      if (ph !== null && !ph.classList.contains(\"_dying\")) {\n        node = ph;\n        offset = 0;\n        loc = loc.make(node, offset);\n      }\n    }\n\n    // Don't update if noop.\n    if (this.caret !== undefined &&\n        this.anchor === this.caret &&\n        this.caret.node === node &&\n        this.caret.offset === offset) {\n      return;\n    }\n\n    // If we do not want to gain focus, we also don't want to take it away\n    // from somewhere else, so don't change the DOM.\n    if (options.focus !== false) {\n      this._clearDOMSelection(true);\n    }\n    this._sel = new WedSelection(this, loc);\n    this.mark.refresh();\n    if (options.focus !== false) {\n      this.focusInputField();\n    }\n    this._caretChange(options);\n  }\n\n  /**\n   * Emit a caret change event.\n   */\n  private _caretChange(options: CaretChangeOptions = {}): void {\n    const prevCaret = this.prevCaret;\n    const caret = this.caret;\n    const mode = caret !== undefined ?\n      this.modeTree.getMode(caret.node) : undefined;\n    if (prevCaret === undefined || !prevCaret.equals(caret)) {\n      this._events.next({\n        manager: this,\n        caret,\n        mode,\n        prevCaret,\n        prevMode: this.prevMode,\n        options,\n      });\n      this.prevCaret = caret;\n      this.prevMode = mode;\n    }\n  }\n\n  private _clearDOMSelection(dontFocus: boolean = false): void {\n    this._getDOMSelection().removeAllRanges();\n    // Make sure the focus goes back there.\n    if (!dontFocus) {\n      this.focusInputField();\n    }\n  }\n\n  private _getDOMSelection(): Selection {\n    return this.win.getSelection();\n  }\n\n  /**\n   * Focus the field use for input events.  It is used by wed on some occasions\n   * where it is needed. Mode authors should never need to call this. If they do\n   * find that calling this helps solve a problem they ran into, they probably\n   * should file an issue report.\n   */\n  focusInputField(): void {\n    // The following call was added to satisfy IE 11. The symptom is that when\n    // clicking on an element's label **on a fresh window that has never\n    // received focus**, it is not possible to move off the label using the\n    // keyboard. This issue happens only with IE 11.\n    this.win.focus();\n    // The call to blur here is here ***only*** to satisfy Chrome 29!\n    this.$inputField.blur();\n    this.$inputField.focus();\n  }\n\n  /**\n   * This is called when the editing area is blurred. This is not something you\n   * should be calling in a mode's implementation. It is public because other\n   * parts of wed need to call it.\n   */\n  onBlur(): void {\n    if (this.caret === undefined) {\n      return;\n    }\n\n    this.selAtBlur = this._sel;\n    this.$inputField.blur();\n    this._sel = undefined;\n    this.mark.refresh();\n  }\n\n  private onFocus(): void {\n    if (this.selAtBlur !== undefined) {\n      this._sel = this.selAtBlur;\n      this._restoreCaretAndSelection(true);\n      this.selAtBlur = undefined;\n    }\n  }\n\n  highlightRange(range: DLocRange): Element {\n    const domRange = range.mustMakeDOMRange();\n\n    const grPosition = this.scroller.getBoundingClientRect();\n    const topOffset = this.scroller.scrollTop - grPosition.top;\n    const leftOffset = this.scroller.scrollLeft - grPosition.left;\n\n    const highlight = this.doc.createElement(\"div\");\n    for (const rect of Array.from(domRange.getClientRects())) {\n      const highlightPart = this.doc.createElement(\"div\");\n      highlightPart.className = \"_wed_highlight\";\n      highlightPart.style.top = `${rect.top + topOffset}px`;\n      highlightPart.style.left = `${rect.left + leftOffset}px`;\n      highlightPart.style.height = `${rect.height}px`;\n      highlightPart.style.width = `${rect.width}px`;\n      highlight.appendChild(highlightPart);\n    }\n\n    this.layer.append(highlight);\n    return highlight;\n  }\n\n  /**\n   * Dump to the console caret-specific information.\n   */\n  dumpCaretInfo(): void {\n    const dataCaret = this.getDataCaret();\n\n    /* tslint:disable:no-console */\n    if (dataCaret !== undefined) {\n      console.log(\"data caret\", dataCaret.node, dataCaret.offset);\n    }\n    else {\n      console.log(\"no data caret\");\n    }\n\n    if (this.anchor !== undefined) {\n      console.log(\"selection anchor\",\n                  this.anchor.node, this.anchor.offset);\n    }\n    else {\n      console.log(\"no selection anchor\");\n    }\n\n    const caret = this.caret;\n    if (caret !== undefined) {\n      const { node, offset } = caret;\n      console.log(\"selection focus\", node, offset);\n      console.log(\"selection focus closest real\",\n                  closestByClass(node, \"_real\", this.guiRootEl));\n      if (isText(node)) {\n        if (offset < node.data.length) {\n          const range = this.doc.createRange();\n          range.setStart(node, offset);\n          range.setEnd(node, offset + 1);\n          const rect = range.getBoundingClientRect();\n          console.log(\"rectangle around character at caret:\", rect);\n        }\n      }\n    }\n    else {\n      console.log(\"no selection focus\");\n    }\n\n    dumpRange(\"DOM range: \", this._getDOMSelectionRange());\n    console.log(\"input field location\", this.inputField.style.top,\n                this.inputField.style.left);\n    console.log(\"document.activeElement\", document.activeElement);\n    /* tslint:enable:no-console */\n  }\n}\n\n//  LocalWords:  MPL wed's DLoc sel setCaret clearDOMSelection rst focusTheNode\n//  LocalWords:  bugzilla nd noop activeElement px rect grPosition topOffset\n//  LocalWords:  leftOffset\n"]}