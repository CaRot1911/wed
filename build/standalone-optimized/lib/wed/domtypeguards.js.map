{"version":3,"file":"domtypeguards.js","sourceRoot":"","sources":["../../../../lib/wed/domtypeguards.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;IAEH,kCAAkC;IAClC,gBAAuB,KAAU;QAC/B,MAAM,CAAC,KAAK,IAAI,IAAI,IAAI,OAAO,KAAK,CAAC,QAAQ,KAAK,QAAQ,CAAC;IAC7D,CAAC;IAFD,wBAEC;IAED,mBAA0B,IAAkB;QAC1C,MAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,YAAY,CAAC;IAC7D,CAAC;IAFD,8BAEC;IAED,gBAAuB,IAAkB;QACvC,MAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,SAAS,CAAC;IAC1D,CAAC;IAFD,wBAEC;IAED,IAAM,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC;IACzC,yDAAyD;IACzD,wBAAwB,EAAe;QACrC,MAAM,CAAC,EAAE,YAAY,IAAI,IAAI,CAAC,EAAE,CAAC,QAAQ,KAAK,YAAY,CAAC,CAAC;IAC9D,CAAC;IAED,qEAAqE;IACrE,sBAAsB,EAAe;QACnC,MAAM,CAAC,EAAE,YAAY,IAAI,CAAC;IAC5B,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,IAAM,MAAM;IACV,qEAAqE;IACrE,8EAA8E;IAC9E,yEAAyE;IACzE,2EAA2E;IAC3E,uCAAuC;IACvC,CAAC,YAAY,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,cAAc,CAAC;IAEtD,wBAAM;IAEf,4BAAmC,IAAkB;QAEnD,MAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,sBAAsB,CAAC;IACvE,CAAC;IAHD,gDAGC;IAED,oBAA2B,IAAkB;QAC3C,MAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,aAAa,CAAC;IAC9D,CAAC;IAFD,gCAEC;;AAED,wDAAwD","sourcesContent":["/**\n * Typeguards to facilitate working with TypeScript and the DOM.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\n// tslint:disable-next-line:no-any\nexport function isNode(thing: any): thing is Node {\n  return thing != null && typeof thing.nodeType === \"number\";\n}\n\nexport function isElement(node?: Node | null): node is Element {\n  return node != null && node.nodeType === Node.ELEMENT_NODE;\n}\n\nexport function isText(node?: Node | null): node is Text {\n  return node != null && node.nodeType === Node.TEXT_NODE;\n}\n\nconst attrNodeType = Node.ATTRIBUTE_NODE;\n// Specialized for when Node.ATTRIBUTE_NODE still exists.\nfunction isAttrWithType(it: Attr | Node): it is Attr {\n  return it instanceof Attr || (it.nodeType === attrNodeType);\n}\n\n// Specialized for when the platform has removed Node.ATTRIBUTE_NODE.\nfunction isAttrNoType(it: Attr | Node): it is Attr {\n  return it instanceof Attr;\n}\n\n/**\n * Determines whether the thing passed is an attribute. This function does not\n * try to be strict about what is passed to it. Pass anything that has a\n * ``nodeType`` field with a value equal to ``Node.ATTRIBUTE_NODE`` and it will\n * return ``true``, even if the thing is not actually an attribute.\n *\n * This is needed because wed works with HTML and XML DOM trees and\n * unfortunately, things have gotten murky. Once upon a time, an attribute was\n * determined by checking the ``nodeType`` field. This worked both for HTML and\n * XML nodes. This worked because attributes inherited from ``Node``, which is\n * the DOM interface that defines ``nodeType``. It was paradise.\n *\n * Then the luminaries that drive the implementation of DOM in actual browsers\n * decided that attributes were no longer really nodes. So they decided to make\n * attribute objects inherit from the ``Attr`` interface **only**. This means\n * that ``nodeType`` no longer exists for attributes. The new way to test\n * whether something is an attribute is to test with ``instanceof Attr``.\n * However, as usual, the DOM implementation for XML lags behind the HTML side\n * and on Chrome 49 (to name just one case), ``instanceof Attr`` does not work\n * on XML attributes whereas testing ``nodeType`` does.\n *\n * This function performs a test that works on HTML attributes and XML\n * attributes.\n *\n * @param it The thing to test.\n *\n * @returns ``true`` if an attribute, ``false`` if not.\n */\nconst isAttr: (it: Attr | Node | null | undefined) => it is Attr =\n  // We check that ``attrNodeType`` is not undefined because eventually\n  // ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n  // could be testing ``undefined === undefined`` for objects which are not\n  // attributes, which would return ``true``. The function is not very strict\n  // but it should not be too lax either.\n  (attrNodeType === undefined) ? isAttrNoType : isAttrWithType;\n\nexport { isAttr };\n\nexport function isDocumentFragment(node?: Node | null):\nnode is DocumentFragment {\n  return node != null && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n\nexport function isDocument(node?: Node | null): node is Document {\n  return node != null && node.nodeType === Node.DOCUMENT_NODE;\n}\n\n//  LocalWords:  Typeguards MPL isAttribute attrNodeType\n"]}