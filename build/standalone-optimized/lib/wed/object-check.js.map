{"version":3,"file":"object-check.js","sourceRoot":"","sources":["../../../../lib/wed/object-check.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Checks whether an object conforms to a template.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nexport interface Template {\n  [key: string]: Template | boolean;\n}\n\n// tslint:disable-next-line:class-name\nexport interface _CheckResults {\n  missing: string[];\n  extra: string[];\n}\n\nexport type CheckResults = Partial<_CheckResults>;\n\nexport interface CheckedObject {\n  // tslint:disable-next-line:no-any\n  [key: string]: CheckedObject | boolean | number | string | any[];\n}\n\n/**\n * Checks whether a field is required.\n *\n * @param template The template to check.\n *\n * @param name The name of the field.\n *\n * @returns Whether the field is required or not.\n */\nfunction _required(template: Template, name: string): boolean {\n  const val = template[name];\n  if (typeof val === \"object\") {\n    for (const subname in val) {\n      if (_required(val, subname)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return val;\n}\n\nfunction _check(template: Template, toCheck: {},\n                prefix: string | undefined, ret: _CheckResults): void {\n  for (const name in template) {\n    if (_required(template, name)) {\n      const prefixed = prefix !== undefined ? [prefix, name].join(\".\") : name;\n      if (!(name in toCheck)) {\n        ret.missing.push(prefixed);\n      }\n      else {\n        const val = (toCheck as CheckedObject)[name];\n        const templateVal = template[name];\n        if (!(val instanceof Array) && typeof val === \"object\" &&\n            typeof templateVal === \"object\") {\n          _check(templateVal, val, prefixed, ret);\n        }\n      }\n    }\n  }\n\n  for (const name in toCheck) {\n    if (!(name in template)) {\n      const prefixed = prefix !== undefined ? [prefix, name].join(\".\") : name;\n      ret.extra.push(prefixed);\n    }\n  }\n}\n\n/**\n * Checks whether an object conforms to a template. The template must be an\n * object which specifies the known fields and which among them are required. A\n * field is known if it appears in the template. A field is considered\n * *required* if:\n *\n *  + it is an object which has any field which is required, or\n *\n *  + it is not an object but evaluates to a true value.\n *\n * A required field which does not appear in the object being checked will\n * appear in the ``missing`` field in the returned value.\n *\n * A field which appears on the object being checked but which is not known will\n * appear in the ``extra`` field in the returned value.\n *\n * The fields mentioned above exist only if there is something to report. The\n * names returned in the lists are fully qualified names.\n *\n * For instance, given this template:\n *\n *     {\n *         foo: false,\n *         bar: {\n *             baz: true,\n *             bin: false,\n *         },\n *         bip: {\n *             baz: false,\n *             bin: false,\n *         }\n *     }\n *\n * The names \"foo\", \"bar\", \"bar.baz\", \"bar.bin\", \"bip\", \"bip.baz\", bip.bin\" are\n * known. The names \"bar\" and \"bar.baz\" are required. The name \"bar\" is required\n * because \"bar.baz\" is required. The other names correspond to objects whose\n * fields are not required or are non-object values that evaluate to false.\n *\n * @param template The template to use for the check.\n *\n * @param toCheck The object to check\n *\n * @returns The results.\n */\nexport function check(template: Template, toCheck: {}): CheckResults {\n  const initial: _CheckResults = { missing: [], extra: [] };\n  _check(template, toCheck, undefined, initial);\n\n  // clean up\n  // tslint:disable-next-line:no-any\n  const ret = initial as any;\n  for (const name in ret) {\n    if (ret[name].length === 0) {\n      delete ret[name];\n    }\n  }\n  return ret;\n}\n\n/**\n * Check whether the object fits the template, and throw at the first sign of\n * trouble. The thrown object contains information about the first error\n * encountered.\n *\n * @param template The template to use for the check.\n *\n * @param toCheck The object to check\n *\n * @throws {Error} If there is any error.\n */\nexport function assertSummarily(template: Template, toCheck: {}): void {\n  const result = check(template, toCheck);\n\n  if (result.missing !== undefined) {\n    throw new Error(`missing option: ${result.missing[0]}`);\n  }\n\n  if (result.extra !== undefined) {\n    throw new Error(`extra option: ${result.extra[0]}`);\n  }\n}\n\n/**\n * Check whether the object fits the template, and throw an error that reports\n * all issues.\n *\n * @param template The template to use for the check.\n *\n * @param toCheck The object to check\n *\n * @throws {Error} If there is any error.\n */\nexport function assertExtensively(template: Template, toCheck: {}): void {\n  const result = check(template, toCheck);\n\n  const errors: string[] = [];\n  if (result.missing !== undefined) {\n    for (const name of result.missing) {\n      errors.push(`missing option: ${name}`);\n    }\n  }\n\n  if (result.extra !== undefined) {\n    for (const name of result.extra) {\n      errors.push(`extra option: ${name}`);\n    }\n  }\n\n  if (errors.length !== 0) {\n    throw new Error(errors.join(\", \"));\n  }\n}\n\n//  LocalWords:  MPL baz bip\n"]}