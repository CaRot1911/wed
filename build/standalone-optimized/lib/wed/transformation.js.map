{"version":3,"sources":["../../../wed/transformation.ts"],"names":[],"mappings":"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","file":"transformation.js","sourcesContent":["/**\n * Transformation framework.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport * as _ from \"lodash\";\n\nimport { Action } from \"./action\";\nimport { DLoc } from \"./dloc\";\nimport { isDocument, isText } from \"./domtypeguards\";\nimport { Caret, firstDescendantOrSelf, indexOf,\n         isWellFormedRange } from \"./domutil\";\nimport * as icon from \"./gui/icon\";\nimport { TreeUpdater } from \"./tree-updater\";\n\n// tslint:disable:no-any\nexport type Editor = any;\n// tslint:enable:no-any\n\nconst TYPE_TO_KIND = _.extend(Object.create(null), {\n  // These are not actually type names. It is possible to use a kind name as a\n  // type name if the transformation is not more specific. In this case the kind\n  // === type.\n  add: \"add\",\n  delete: \"delete\",\n  transform: \"transform\",\n\n  insert: \"add\",\n  \"delete-element\": \"delete\",\n  \"delete-parent\": \"delete\",\n  wrap: \"wrap\",\n  \"wrap-content\": \"wrap\",\n  \"merge-with-next\": \"transform\",\n  \"merge-with-previous\": \"transform\",\n  \"swap-with-next\": \"transform\",\n  \"swap-with-previous\": \"transform\",\n  split: \"transform\",\n  append: \"add\",\n  prepend: \"add\",\n  unwrap: \"unwrap\",\n  \"add-attribute\": \"add\",\n  \"delete-attribute\": \"delete\",\n});\n\nconst TYPE_TO_NODE_TYPE = _.extend(Object.create(null), {\n  // These are not actually type names. These are here to handle the\n  // case where the type is actually a kind name. Since they are not\n  // more specific, the node type is set to \"other\". Note that\n  // \"wrap\" and \"unwrap\" are always about elements so there is no\n  // way to have a \"wrap/unwrap\" which has \"other\" for the node\n  // type.\n  add: \"other\",\n  delete: \"other\",\n  transform: \"other\",\n\n  insert: \"element\",\n  \"delete-element\": \"element\",\n  \"delete-parent\": \"element\",\n  wrap: \"element\",\n  \"wrap-content\": \"element\",\n  \"merge-with-next\": \"element\",\n  \"merge-with-previous\": \"element\",\n  \"swap-with-next\": \"element\",\n  \"swap-with-previous\": \"element\",\n  split: \"element\",\n  append: \"element\",\n  prepend: \"element\",\n  unwrap: \"element\",\n  \"add-attribute\": \"attribute\",\n  \"delete-attribute\": \"attribute\",\n});\n\n/**\n * Data passed to the transformation handler. The transformation types expect\n * the following values for the parameters passed to a handler.\n *\n * Transformation Type | `node` is | `name` is the name of the:\n * --------------------|-----------|---------------------------\n * insert | undefined (we insert at caret position) | element to insert\n * delete-element | element to delete | element to delete\n * delete-parent | element to delete | element to delete\n * wrap | undefined (we wrap the current selection) | wrapping element\n * merge-with-next | element to merge | element to merge\n * merge-with-previous | element to merge | element to merge\n * swap-with-next | element to swap | element to swap\n * swap-with-previous | element to swap | element to swap\n * append | element after which to append | element after which to append\n * prepend | element before which to prepend | element before which to append\n * unwrap | node to unwrap | node to unwrap\n * add-attribute | node to which an attribute is added | attribute to add\n * delete-attribute | attribute to delete | attribute to delete\n * insert-text | node to which text is added | text to add\n */\nexport interface TransformationData {\n  /**\n   * The JavaScript event that triggered the transformation, if any.\n   */\n  readonly e?: Event;\n\n  /**\n   * The node to operate on. Should be set by the code that invokes the\n   * transformation. This may be undefined if the transformation should rely on\n   * the caret position.\n   */\n  node?: Node;\n\n  /**\n   * The name of the node to add, remove, etc. Should be set by the code that\n   * invokes the transformation.\n   */\n  name: string;\n\n  /**\n   * A position to which the caret is moved before the transformation is fired.\n   * **Wed performs the move.** Should be set by the code that invokes the\n   * transformation.\n   */\n  moveCaretTo?: DLoc;\n}\n\n/**\n * @param editor The editor.\n *\n * @param data Data for the transformation.\n */\nexport type TransformationHandler =\n  (editor: Editor, data: TransformationData) => void;\n\nfunction computeIconHtml(iconHtml: string | undefined,\n                         transformationType: string): string | undefined {\n  if (iconHtml !== undefined) {\n    return iconHtml;\n  }\n\n  const kind = TYPE_TO_KIND[transformationType];\n  if (kind !== undefined) {\n    return icon.makeHTML(kind);\n  }\n\n  return undefined;\n}\n\n/**\n * An operation that transforms the data tree.\n */\nexport class Transformation<Data extends TransformationData>\n  extends Action<Data> {\n  public readonly handler: TransformationHandler;\n  public readonly transformationType: string;\n  public readonly kind: string;\n  public readonly nodeType: string;\n\n  /**\n   * @param editor The editor for which this transformation is created.\n   *\n   * @param transformationType The type of transformation.\n   *\n   * @param desc The description of this transformation. A transformation's\n   * [[getDescriptionFor]] method will replace ``<name>`` with the name of the\n   * node actually being processed. So a string like ``Remove <name>`` would\n   * become ``Remove foo`` when the transformation is called for the element\n   * ``foo``.\n   *\n   * @param abbreviatedDesc An abbreviated description of this transformation.\n   *\n   * @param iconHtml An HTML representation of the icon associated with this\n   * transformation.\n   *\n   * @param needsInput Defaults to ``false`` for signatures that do not contain\n   * this parameter. Indicates whether this action needs input from the\n   * user. For instance, an action which brings up a modal dialog to ask\n   * something of the user must have this parameter set to ``true``. It is\n   * important to record whether an action needs input because, to take one\n   * example, the ``autoinsert`` logic will try to insert automatically any\n   * element it can. However, doing this for elements that need user input will\n   * just confuse the user (or could cause a crash). Therefore, it is important\n   * that the insertion operations for such elements be marked with\n   * ``needsInput`` set to ``true`` so that the ``autoinsert`` logic backs off\n   * from trying to insert these elements.\n   *\n   * @param handler The handler to call when this transformation is executed.\n   */\n  constructor(editor: Editor, transformationType: string, desc: string,\n              handler: TransformationHandler);\n  constructor(editor: Editor, transformationType: string, desc: string,\n              abbreviatedDesc: string | undefined,\n              handler: TransformationHandler);\n  constructor(editor: Editor, transformationType: string, desc: string,\n              abbreviatedDesc: string | undefined,\n              iconHtml: string | undefined,\n              handler: TransformationHandler);\n  constructor(editor: Editor, transformationType: string, desc: string,\n              abbreviatedDesc: string | undefined, iconHtml: string | undefined,\n              needsInput: boolean, handler: TransformationHandler);\n  constructor(editor: Editor, transformationType: string, desc: string,\n              abbreviatedDesc: string | TransformationHandler | undefined,\n              iconHtml?: string | TransformationHandler | undefined,\n              needsInput?: boolean | TransformationHandler,\n              handler?: TransformationHandler) {\n    if (typeof abbreviatedDesc === \"function\") {\n      handler = abbreviatedDesc;\n      super(editor, desc, undefined,\n            computeIconHtml(undefined, transformationType), false);\n    }\n    else if (typeof iconHtml === \"function\") {\n      handler = iconHtml;\n      super(editor, desc, abbreviatedDesc,\n            computeIconHtml(undefined, transformationType), false);\n    }\n    else if (typeof needsInput === \"function\") {\n      handler = needsInput;\n      super(editor, desc, abbreviatedDesc,\n            computeIconHtml(iconHtml, transformationType), false);\n    }\n    else {\n      super(editor, desc, abbreviatedDesc,\n            computeIconHtml(iconHtml, transformationType), needsInput);\n    }\n\n    if (handler === undefined) {\n      throw new Error(\"did not specify a handler\");\n    }\n\n    this.handler = handler;\n    this.transformationType = transformationType;\n    this.kind = TYPE_TO_KIND[transformationType];\n    this.nodeType = TYPE_TO_NODE_TYPE[transformationType];\n  }\n\n  getDescriptionFor(data: Data): string {\n    return this.desc.replace(/<name>/, data.name);\n  }\n\n  /**\n   * Calls the ``fireTransformation`` method on this transformation's editor.\n   *\n   * @param data The data object to pass.\n   */\n  execute(data: Data): void {\n    // Removed this during conversion to TypeScript. Did it ever make sense??\n    // data = data || {};\n    this.editor.fireTransformation(this, data);\n  }\n}\n\nexport type AttributeTable = Record<string, string>;\n\n/**\n * Makes an element appropriate for a wed data tree.\n *\n * @param doc The document for which to make the element.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name Name of the new element.\n *\n * @param attrs An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n */\nexport function makeElement(doc: Document, ns: string, name: string,\n                            attrs?: AttributeTable): Element {\n  const e = doc.createElementNS(ns, name);\n  if (attrs !== undefined) {\n    // Create attributes\n    const keys = Object.keys(attrs).sort();\n    for (const key of keys) {\n      e.setAttribute(key, attrs[key]);\n    }\n  }\n  return e;\n}\n\n/**\n * Insert an element in a wed data tree.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param parent Parent of the new node.\n *\n * @param index Offset in the parent where to insert the new node.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name Name of the new element.\n *\n * @param attrs An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n */\nexport function insertElement(dataUpdater: TreeUpdater,\n                              parent: Node, index: number, ns: string,\n                              name: string,\n                              attrs?: AttributeTable): Element {\n  const ownerDocument = isDocument(parent) ? parent : parent.ownerDocument;\n  const el = makeElement(ownerDocument, ns, name, attrs);\n  dataUpdater.insertAt(parent, index, el);\n  return el;\n}\n\n/**\n * Wraps a span of text in a new element.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param node The DOM node where to wrap. Must be a text node.\n *\n * @param offset Offset in the node. This parameter specifies where to start\n * wrapping.\n *\n * @param endOffset Offset in the node. This parameter specifies where to end\n * wrapping.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name Name of the wrapping element.\n *\n * @param attrs An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n */\nexport function wrapTextInElement(dataUpdater: TreeUpdater, node: Text,\n                                  offset: number, endOffset: number,\n                                  ns: string, name: string,\n                                  attrs?: AttributeTable): Element {\n  const textToWrap = node.data.slice(offset, endOffset);\n\n  const parent = node.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n  const nodeOffset = indexOf(parent.childNodes, node);\n\n  dataUpdater.deleteText(node, offset, textToWrap.length);\n  const newElement = makeElement(node.ownerDocument, ns, name, attrs);\n\n  if (textToWrap !== \"\") {\n    // It is okay to manipulate the DOM directly as long as the DOM tree being\n    // manipulated is not *yet* inserted into the data tree. That is the case\n    // here.\n    newElement.appendChild(node.ownerDocument.createTextNode(textToWrap));\n  }\n\n  if (node.parentNode === null) {\n    // The entire node was removed.\n    dataUpdater.insertAt(parent, nodeOffset, newElement);\n  }\n  else {\n    dataUpdater.insertAt(node, offset, newElement);\n  }\n\n  return newElement;\n}\n\n/**\n * Utility function for [[wrapInElement]].\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param container The text node to split.\n *\n * @param offset Where to split the node\n *\n * @returns Returns a caret location marking where the split occurred.\n */\nfunction _wie_splitTextNode(dataUpdater: TreeUpdater, container: Text,\n                            offset: number): Caret {\n  const parent = container.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n  const containerOffset = indexOf(parent.childNodes, container);\n  // The first two cases here just return a caret outside of the text node\n  // rather than make a split that will create a useless empty text node.\n  if (offset === 0) {\n    offset = containerOffset;\n  }\n  else if (offset >= container.length) {\n    offset = containerOffset + 1;\n  }\n  else {\n    const text = container.data.slice(offset);\n    dataUpdater.setTextNode(container, container.data.slice(0, offset));\n    dataUpdater.insertNodeAt(parent, containerOffset + 1,\n                             container.ownerDocument.createTextNode(text));\n\n    offset = containerOffset + 1;\n  }\n  return [parent, offset];\n}\n\n/**\n * Wraps a well-formed span in a new element. This span can contain text and\n * element nodes.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param startContainer The node where to start wrapping.\n *\n * @param startOffset The offset where to start wrapping.\n *\n * @param endContainer The node where to end wrapping.\n *\n * @param endOffset The offset where to end wrapping.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name The name of the new element.\n *\n * @param [attrs] An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n *\n * @throws {Error} If the range is malformed or if there is an internal error.\n */\nexport function wrapInElement(dataUpdater: TreeUpdater, startContainer: Node,\n                              startOffset: number, endContainer: Node,\n                              endOffset: number, ns: string, name: string,\n                              attrs?: AttributeTable): Element {\n  if (!isWellFormedRange({ startContainer, startOffset, endContainer,\n                           endOffset })) {\n    throw new Error(\"malformed range\");\n  }\n\n  if (isText(startContainer)) {\n    // We already have an algorithm for this case.\n    if (startContainer === endContainer) {\n      return wrapTextInElement(dataUpdater, startContainer, startOffset,\n                               endOffset, ns, name, attrs);\n    }\n\n    [startContainer, startOffset] =\n      _wie_splitTextNode(dataUpdater, startContainer, startOffset);\n  }\n\n  if (isText(endContainer)) {\n    [endContainer, endOffset] =\n      _wie_splitTextNode(dataUpdater, endContainer, endOffset);\n  }\n\n  if (startContainer !== endContainer) {\n    throw new Error(\"startContainer and endContainer are not the same;\" +\n                    \"probably due to an algorithmic mistake\");\n  }\n\n  const newElement = makeElement(startContainer.ownerDocument, ns, name, attrs);\n  while (--endOffset >= startOffset) {\n    const endNode = endContainer.childNodes[endOffset];\n    dataUpdater.deleteNode(endNode);\n    // Okay to change a tree which is not yet connected to the data tree.\n    newElement.insertBefore(endNode, newElement.firstChild);\n  }\n\n  dataUpdater.insertAt(startContainer, startOffset, newElement);\n\n  return newElement;\n}\n\n/**\n * Replaces an element with its contents.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param node The element to unwrap.\n *\n * @returns The contents of the element.\n */\nexport function unwrap(dataUpdater: TreeUpdater, node: Element): Node[] {\n  const parent = node.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n\n  const children = Array.prototype.slice.call(node.childNodes);\n  const prev = node.previousSibling;\n  const next = node.nextSibling;\n  // This does not merge text nodes, which is what we want. We also want to\n  // remove it first so that we don't generate so many update events.\n  dataUpdater.deleteNode(node);\n\n  // We want to calculate this index *after* removal.\n  let nextIx = (next !== null) ? indexOf(parent.childNodes, next) :\n    parent.childNodes.length;\n\n  const lastChild = node.lastChild;\n\n  // This also does not merge text nodes.\n  while (node.firstChild != null) {\n    dataUpdater.insertNodeAt(parent, nextIx++, node.firstChild);\n  }\n\n  // The order of the next two calls is important. We start at the end because\n  // going the other way around could cause lastChild to leave the DOM tree.\n\n  // Merge possible adjacent text nodes: the last child of the node that was\n  // removed in the unwrapping and the node that was after the node that was\n  // removed in the unwrapping.\n  if (lastChild !== null) {\n    dataUpdater.mergeTextNodes(lastChild);\n  }\n\n  // Merge the possible adjacent text nodes: the one before the start of the\n  // children we unwrapped and the first child that was unwrapped. There may not\n  // be a prev so we use the NF form of the call.\n  dataUpdater.mergeTextNodesNF(prev);\n\n  return children;\n}\n\n/**\n * This function splits a node at the position of the caret. If the caret is not\n * inside the node or its descendants, an exception is raised.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The node to split.\n *\n * @throws {Error} If the caret is not inside the node or its descendants.\n */\nexport function splitNode(editor: Editor, node: Node): void {\n  const caret = editor.caretManager.getDataCaret();\n\n  if (!node.contains(caret.node)) {\n    throw new Error(\"caret outside node\");\n  }\n\n  const pair = editor.data_updater.splitAt(node, caret);\n  // Find the deepest location at the start of the 2nd element.\n  editor.caretManager.setCaret(firstDescendantOrSelf(pair[1]), 0);\n}\n\n/**\n * This function merges an element with a previous element of the same name. For\n * the operation to go forward, the element must have a previous sibling and\n * this sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to merge with previous.\n */\nexport function mergeWithPreviousHomogeneousSibling(editor: Editor,\n                                                    node: Element): void {\n  const prev = node.previousElementSibling;\n  if (prev === null) {\n    return;\n  }\n\n  if (prev.localName !== node.localName ||\n      prev.namespaceURI !== node.namespaceURI) {\n    return;\n  }\n\n  // We need to record these to set the caret to a good position.\n  const caretPos = prev.childNodes.length;\n  const lastChild = prev.lastChild;\n  const wasText = isText(lastChild);\n  // We need to record this *now* for future use, because it is possible that\n  // the next loop could modify lastChild in place.\n  const textLen = wasText ? (lastChild as Text).length : 0;\n\n  const insertionPoint = prev.childNodes.length;\n  // Reverse order\n  for (let i = node.childNodes.length - 1; i >= 0; --i) {\n    editor.data_updater.insertAt(prev, insertionPoint,\n                                 node.childNodes[i].cloneNode(true));\n  }\n\n  if (wasText) {\n    editor.data_updater.mergeTextNodes(lastChild);\n    editor.caretManager.setCaret(prev.childNodes[caretPos - 1], textLen);\n  }\n  else {\n    editor.caretManager.setCaret(prev, caretPos);\n  }\n  editor.data_updater.removeNode(node);\n}\n\n/**\n * This function merges an element with a next element of the same name. For the\n * operation to go forward, the element must have a next sibling and this\n * sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to merge with next.\n */\nexport function mergeWithNextHomogeneousSibling(editor: Editor,\n                                                node: Element): void {\n  const next = node.nextElementSibling;\n  if (next === null) {\n    return;\n  }\n\n  mergeWithPreviousHomogeneousSibling(editor, next);\n}\n\n/**\n * This function swaps an element with a previous element of the same name. For\n * the operation to go forward, the element must have a previous sibling and\n * this sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to swap with previous.\n */\nexport function swapWithPreviousHomogeneousSibling(editor: Editor,\n                                                   node: Element): void {\n  const prev = node.previousElementSibling;\n  if (prev === null) {\n    return;\n  }\n\n  if (prev.localName !== node.localName ||\n      prev.namespaceURI !== node.namespaceURI) {\n    return;\n  }\n\n  const parent = prev.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n\n  editor.data_updater.removeNode(node);\n  editor.data_updater.insertBefore(parent, node, prev);\n  editor.caretManager.setCaret(node);\n}\n\n/**\n * This function swaps an element with a next element of the same name. For the\n * operation to go forward, the element must have a next sibling and this\n * sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to swap with next.\n */\nexport function swapWithNextHomogeneousSibling(editor: Editor,\n                                               node: Element): void {\n  const next = node.nextElementSibling;\n  if (next === null) {\n    return;\n  }\n\n  swapWithPreviousHomogeneousSibling(editor, next);\n}\n\n//  LocalWords:  concat prepend refman endOffset endContainer DOM oop\n//  LocalWords:  startOffset startContainer html Mangalam MPL Dubeau\n//  LocalWords:  previousSibling nextSibling insertNodeAt deleteNode\n//  LocalWords:  mergeTextNodes lastChild prev deleteText Prepend lt\n//  LocalWords:  domutil util\n"]}