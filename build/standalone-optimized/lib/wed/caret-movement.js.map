{"version":3,"sources":["../../../wed/caret-movement.ts"],"names":[],"mappings":"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","file":"caret-movement.js","sourcesContent":["/**\n * Library of caret movement computations.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { DLoc } from \"./dloc\";\nimport { isElement, isText } from \"./domtypeguards\";\nimport { Caret, childByClass, closest, closestByClass, indexOf,\n         nextCaretPosition, prevCaretPosition } from \"./domutil\";\nimport { ModeTree } from \"./mode-tree\";\nimport { boundaryXY, getAttrValueNode } from \"./wed-util\";\n\nfunction moveInAttributes(node: Node, modeTree: ModeTree): boolean {\n  return modeTree.getAttributeHandling(node) === \"edit\";\n}\n\n/**\n * @param pos The position form which we start.\n *\n * @param root The root of the DOM tree within which we move.\n *\n * @param after Whether we are to move after the placeholder (``true``) or not\n * (``false``).\n *\n * @returns If called with a position inside a placeholder, return a position\n * outside of the placeholder. Otherwise, return the position unchanged.\n */\nfunction moveOutOfPlaceholder(pos: DLoc, root: Element | Document,\n                              after: boolean): DLoc {\n  // If we are in a placeholder node, immediately move out of it.\n  const closestPh = closestByClass(pos.node, \"_placeholder\", root);\n  if (closestPh !== null) {\n    const parent = closestPh.parentNode!;\n    let index = indexOf(parent.childNodes, closestPh);\n    if (after) {\n      index++;\n    }\n\n    pos = pos.make(parent, index);\n  }\n\n  return pos;\n}\n\n/**\n * Determines what should be used as the \"container\" for caret movement\n * purposes. The \"container\" is the element within which caret movements are\n * constrained. (The caret cannot move out of it.)\n *\n * @param docRoot The root element of the document being edited by wed.\n *\n * @returns A container that can be used by the caret movement functions.\n */\nfunction determineContainer(docRoot: Document | Element): Element {\n  let container = docRoot.firstChild;\n\n  if (!isElement(container)) {\n    throw new Error(\"docRoot does not contain an element\");\n  }\n\n  // This takes care of the special case where we have an empty document that\n  // contains only a placeholder. In such case, setting the container to\n  // docRoot.firstChild will have a perverse effect of setting the container to\n  // be **inside** the current pos.\n  if (container.classList.contains(\"_placeholder\")) {\n    container = docRoot;\n  }\n\n  return container as Element;\n}\n\n/**\n * Determine whether a position is within the editable content of an element or\n * outside of it. Modes often decorate elements by adding decorations before and\n * after the content of the element. These are not editable, and should be\n * skipped by caret movement.\n *\n * @param element The element in which the caret is appearing.\n *\n * @param offset The offset into the element at which the caret is positioned.\n *\n * @param modeTree The mode tree from which to get a mode.\n *\n * @returns ``true`` if we are inside editable content, ``false`` otherwise.\n */\nfunction insideEditableContent(element: Element, offset: number,\n                               modeTree: ModeTree): boolean {\n  const mode = modeTree.getMode(element);\n  const [before, after] = mode.nodesAroundEditableContents(element);\n\n  // If the element has nodes before editable contents and the caret would\n  // be before or among such nodes, then ...\n  if (before !== null && indexOf(element.childNodes, before) >= offset) {\n    return false;\n  }\n\n  // If the element has nodes after editable contents and the caret would be\n  // after or among such nodes, then ...\n  if (after !== null && indexOf(element.childNodes, after) < offset) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @returns ``true`` if ``prev`` and ``next`` are both decorated; ``false``\n * otherwise.\n */\nfunction bothDecorated(prev: Node | undefined,\n                       next: Node | undefined): boolean {\n  if (next === undefined || prev === undefined) {\n    return false;\n  }\n\n  const nextFirst = next.firstChild;\n  const prevLast = prev.lastChild;\n\n  return isElement(nextFirst) &&\n    nextFirst.classList.contains(\"_gui\") &&\n    !nextFirst.classList.contains(\"_invisible\") &&\n    isElement(prevLast) &&\n    prevLast.classList.contains(\"_gui\") &&\n    !prevLast.classList.contains(\"_invisible\");\n}\n\n/**\n * Find the first node in a set of nodes which is such that the reference node\n * **precedes** it.\n *\n * @param haystack The nodes to search.\n *\n * @param ref The reference node.\n *\n * @returns The first node in ``haystack`` which does not precede ``ref``.\n */\nfunction findNext(haystack: NodeList, ref: Node): Node | undefined {\n  const arr: Element[] = Array.prototype.slice.call(haystack);\n  for (const x of arr) {\n    // tslint:disable-next-line:no-bitwise\n    if ((x.compareDocumentPosition(ref) &\n         Node.DOCUMENT_POSITION_PRECEDING) !== 0) {\n      return x;\n    }\n  }\n\n  return undefined;\n}\n\nexport type Direction = \"right\" | \"left\" | \"up\" | \"down\";\n\nconst directionToFunction = {\n  right: positionRight,\n  left: positionLeft,\n  up: positionUp,\n  down: positionDown,\n};\n\nexport function newPosition(pos: DLoc | undefined | null,\n                            direction: Direction,\n                            docRoot: Document | Element,\n                            modeTree: ModeTree): DLoc | undefined {\n  const fn = directionToFunction[direction];\n  if (fn === undefined) {\n    throw new Error(`cannot resolve direction: ${direction}`);\n  }\n\n  return fn(pos, docRoot, modeTree);\n}\n\n/**\n * Compute the position to the right of a starting position. This function takes\n * into account wed-specific needs. For instance, it knows how start and end\n * labels are structured.\n *\n * @param pos The position at which we start.\n *\n * @param docRoot The element within which caret movement is to be constrained.\n *\n * @param modeTree The mode tree from which to get a mode.\n *\n * @returns The new position, or ``undefined`` if there is no such position.\n */\n// tslint:disable-next-line:cyclomatic-complexity max-func-body-length\nexport function positionRight(pos: DLoc | undefined | null,\n                              docRoot: Document | Element,\n                              modeTree: ModeTree): DLoc | undefined {\n  if (pos == null) {\n    return undefined;\n  }\n\n  const root = pos.root;\n  // If we are in a placeholder node, immediately move out of it.\n  pos = moveOutOfPlaceholder(pos, root, true);\n\n  const container = determineContainer(docRoot);\n\n  // tslint:disable-next-line:strict-boolean-expressions no-constant-condition\n  while (true) {\n    const guiBefore: Element | null = closestByClass(pos.node, \"_gui\", root);\n\n    const nextCaret: Caret | null =\n      nextCaretPosition(pos.toArray(), container, false);\n    if (nextCaret === null) {\n      pos = null;\n      break;\n    }\n\n    pos = pos.make(nextCaret);\n    const { node, offset }: { node: Node, offset: number } = pos;\n    const closestGUI = closest(node, \"._gui:not(._invisible)\", root);\n    if (closestGUI !== null) {\n      const startLabel = closestGUI.classList.contains(\"__start_label\");\n      if (startLabel &&\n          moveInAttributes(closestByClass(closestGUI, \"_real\", root)!,\n                           modeTree)) {\n        if (closestByClass(node, \"_attribute_value\", root) !== null) {\n          // We're in an attribute value, stop here.\n          break;\n        }\n\n        // Already in the element name, or in a previous attribute, move from\n        // attribute to attribute.\n        if (closest(node, \"._element_name, ._attribute\", root) !== null) {\n          // Search for the next attribute.\n          const nextAttr = findNext(\n            closestGUI.getElementsByClassName(\"_attribute\"), node);\n\n          if (nextAttr !== undefined) {\n            // There is a next attribute: move to it.\n            const val = getAttrValueNode(childByClass(nextAttr,\n                                                      \"_attribute_value\")!);\n            pos = pos.make(val, 0);\n            break;\n          }\n        }\n        // else fall through and move to end of gui element.\n      }\n\n      if (guiBefore === closestGUI) {\n        // Move to the end of the gui element ...\n        pos = pos.make(closestGUI, closestGUI.childNodes.length);\n        // ... and then out of it.\n        continue;\n      }\n      pos = pos.make(\n        // If in a label, normalize to element name. If in another kind of gui\n        // element, normalize to start of the element.\n        (startLabel || closestByClass(node, \"_label\", closestGUI) !== null) ?\n          (node as Element).getElementsByClassName(\"_element_name\")[0] :\n          closestGUI, 0);\n      // ... stop here.\n      break;\n    }\n\n    // Can't stop inside a phantom node.\n    const closestPhantom = closestByClass(node, \"_phantom\", root);\n    if (closestPhantom !== null) {\n      // This ensures the next loop will move after the phantom.\n      pos = pos.make(closestPhantom, closestPhantom.childNodes.length);\n      continue;\n    }\n\n    // Or beyond the first position in a placeholder node.\n    const closestPh = closestByClass(node, \"_placeholder\", root);\n    if (closestPh !== null && offset > 0) {\n      // This ensures the next loop will move after the placeholder.\n      pos = pos.make(closestPh, closestPh.childNodes.length);\n      continue;\n    }\n\n    // Make sure the position makes sense from an editing standpoint.\n    if (isElement(node)) {\n      const nextNode = node.childNodes[offset];\n\n      // Always move into text\n      if (isText(nextNode)) {\n        continue;\n      }\n\n      const prevNode = node.childNodes[offset - 1];\n      // Stop between two decorated elements.\n      if (bothDecorated(prevNode, nextNode)) {\n        break;\n      }\n\n      if (isElement(prevNode) &&\n          // We do not stop in front of element nodes.\n          ((isElement(nextNode) &&\n            !nextNode.classList.contains(\"_end_wrapper\") &&\n            !prevNode.classList.contains(\"_start_wrapper\")) ||\n           prevNode.matches(\"._wed-validation-error, ._gui.__end_label\"))) {\n        // can't stop here\n        continue;\n      }\n\n      // If the offset is not inside the editable content of the node, then...\n      if (!insideEditableContent(node, offset, modeTree)) {\n        // ... can't stop here.\n        continue;\n      }\n    }\n\n    // If we get here, the position is good!\n    break;\n  }\n\n  return pos !== null ? pos : undefined;\n}\n\n/**\n * Compute the position to the left of a starting position. This function takes\n * into account wed-specific needs. For instance, it knows how start and end\n * labels are structured.\n *\n * @param pos The position at which we start.\n *\n * @param docRoot The element within which caret movement is to be constrained.\n *\n * @param modeTree The mode tree from which to get a mode.\n *\n * @returns The new position, or ``undefined`` if there is no such position.\n */\n// tslint:disable-next-line:cyclomatic-complexity max-func-body-length\nexport function positionLeft(pos: DLoc | undefined | null,\n                             docRoot: Document | Element,\n                             modeTree: ModeTree): DLoc | undefined {\n  if (pos == null) {\n    return undefined;\n  }\n\n  const root = pos.root;\n  // If we are in a placeholder node, immediately move out of it.\n  pos = moveOutOfPlaceholder(pos, root, false);\n\n  const container = determineContainer(docRoot);\n\n  // tslint:disable-next-line:strict-boolean-expressions no-constant-condition\n  while (true) {\n    let elName = closestByClass(pos.node, \"_element_name\", root);\n    const wasInName = (pos.node === elName) && (pos.offset === 0);\n    const prevCaret: Caret | null = prevCaretPosition(pos.toArray(), container,\n                                                      false);\n    if (prevCaret === null) {\n      pos = null;\n      break;\n    }\n\n    pos = pos.make(prevCaret);\n    const node: Node = pos.node;\n    let offset = pos.offset;\n    const closestGUI: Element | null = closest(node, \"._gui:not(._invisible)\",\n                                               root);\n    if (closestGUI !== null) {\n      const startLabel = closestGUI.classList.contains(\"__start_label\");\n      if (startLabel && !wasInName &&\n          moveInAttributes(closestByClass(closestGUI, \"_real\", root)!,\n                           modeTree)) {\n        if (closestByClass(node, \"_attribute_value\", closestGUI) !== null) {\n          // We're in an attribute value, stop here.\n          break;\n        }\n\n        let attr = closestByClass(node, \"_attribute\", closestGUI);\n        if (attr === null &&\n            isElement(node) &&\n            node.nextElementSibling !== null &&\n            node.nextElementSibling.classList.contains(\"_attribute\")) {\n          attr = node.nextElementSibling;\n        }\n\n        if (attr === null) {\n          elName = closestByClass(node, \"_element_name\", closestGUI);\n          attr = elName !== null ? elName.nextElementSibling : null;\n        }\n\n        let prevAttr = attr !== null ? attr.previousElementSibling : null;\n\n        // If we have not yet found anything, then the\n        // previous attribute is the last one.\n        if (prevAttr === null) {\n          const all = closestGUI.getElementsByClassName(\"_attribute\");\n          if (all.length > 0) {\n            prevAttr = all[all.length - 1];\n          }\n        }\n\n        // Eliminate those elements which are not attributes.\n        if (prevAttr !== null && !prevAttr.classList.contains(\"_attribute\")) {\n          prevAttr = null;\n        }\n\n        if (prevAttr !== null) {\n          // There is a previous attribute: move to it.\n          let val: Node = childByClass(prevAttr, \"_attribute_value\")!;\n          offset = 0;\n          if (val.lastChild !== null) {\n            val = val.lastChild;\n            if (isElement(val) && val.classList.contains(\"_placeholder\")) {\n              offset = 0;\n            }\n            else if (isText(val)) {\n              offset = val.length;\n            }\n            else {\n              throw new Error(\"unexpected content in attribute value\");\n            }\n          }\n          pos = pos.make(val, offset);\n          break;\n        }\n      }\n\n      if (!wasInName) {\n        pos = pos.make(\n          // If we are in any label, normalize to the element name, otherwise\n          // normalize to the first position in the gui element.\n          (startLabel ||\n           closestByClass(node, \"_label\", closestGUI) !== null) ?\n              closestGUI.getElementsByClassName(\"_element_name\")[0]\n            : closestGUI,\n          0);\n        break;\n      }\n\n      // ... move to start of gui element ...\n      pos = pos.make(closestGUI, 0);\n      // ... and then out of it.\n      continue;\n    }\n\n    const closestPh = closestByClass(node, \"_placeholder\", root);\n    if (closestPh !== null) {\n      // Stopping in a placeholder is fine, but normalize the position to the\n      // start of the text.\n      pos = pos.make(closestPh.firstChild!, 0);\n      break;\n    }\n\n    // Can't stop inside a phantom node.\n    const closestPhantom = closestByClass(node, \"_phantom\", root);\n    if (closestPhantom !== null) {\n      // Setting the position to this will ensure that on the next loop we move\n      // to the left of the phantom node.\n      pos = pos.make(closestPhantom, 0);\n      continue;\n    }\n\n    // Make sure the position makes sense from an editing standpoint.\n    if (isElement(node)) {\n      const prevNode = node.childNodes[offset - 1];\n\n      // Always move into text\n      if (isText(prevNode)) {\n        continue;\n      }\n\n      const nextNode = node.childNodes[offset];\n      // Stop between two decorated elements.\n      if (bothDecorated(prevNode, nextNode)) {\n        break;\n      }\n\n      if (isElement(nextNode) &&\n          // We do not stop just before a start tag button.\n          ((isElement(prevNode) &&\n            !prevNode.classList.contains(\"_start_wrapper\") &&\n            !nextNode.classList.contains(\"_end_wrapper\")) ||\n           // Can't stop right before a validation error.\n           nextNode.matches(\"._gui.__start_label, .wed-validation-error\"))) {\n        continue;\n      } // can't stop here\n\n      // If the offset is not inside the editable content of the node, then...\n      if (!insideEditableContent(node, offset, modeTree)) {\n        // ... can't stop here.\n        continue;\n      }\n    }\n\n    // If we get here, the position is good!\n    break;\n  }\n\n  return pos !== null ? pos : undefined;\n}\n\n/**\n * Compute the position under a starting position. This function takes into\n * account wed-specific needs. For instance, it knows how start and end labels\n * are structured.\n *\n * @param pos The position at which we start.\n *\n * @param docRoot The element within which caret movement is to be constrained.\n *\n * @param modeTree The mode tree from which to get a mode.\n *\n * @returns The new position, or ``undefined`` if there is no such position.\n */\nexport function positionDown(pos: DLoc | undefined | null,\n                             docRoot: Document | Element,\n                             modeTree: ModeTree): DLoc | undefined {\n  if (pos == null) {\n    return undefined;\n  }\n\n  // Search for the next line.\n  const initialCaret = boundaryXY(pos);\n  let next = initialCaret;\n  while (initialCaret.bottom > next.top) {\n    pos = positionRight(pos, docRoot, modeTree);\n    if (pos === undefined) {\n      return undefined;\n    }\n    next = boundaryXY(pos);\n  }\n\n  // pos is now at the start of the next line. We need to find the position that\n  // is closest horizontally.\n\n  const nextBottom = next.bottom;\n  let minDist = Infinity;\n  let minPosition;\n  while (pos !== undefined) {\n    const dist = Math.abs(next.left - initialCaret.left);\n    // We've started moving away from the minimum distance.\n    if (dist > minDist) {\n      break;\n    }\n\n    // We've moved to yet another line. The minimum we have so far is *it*.\n    if (nextBottom <= next.top) {\n      break;\n    }\n\n    minDist = dist;\n    minPosition = pos;\n    pos = positionRight(pos, docRoot, modeTree);\n    if (pos !== undefined) {\n      next = boundaryXY(pos);\n    }\n  }\n\n  return minPosition;\n}\n\n/**\n * Compute the position above a starting position. This function takes into\n * account wed-specific needs. For instance, it knows how start and end labels\n * are structured.\n *\n * @param pos The position at which we start.\n *\n * @param docRoot The element within which caret movement is to be constrained.\n *\n * @param modeTree The mode tree from which to get a mode.\n *\n * @returns The new position, or ``undefined`` if there is no such position.\n */\nexport function positionUp(pos: DLoc | undefined | null,\n                           docRoot: Document | Element,\n                           modeTree: ModeTree): DLoc | undefined {\n  if (pos == null) {\n    return undefined;\n  }\n\n  // Search for the previous line.\n  const initialBoundary = boundaryXY(pos);\n  let prev = initialBoundary;\n  while (initialBoundary.top < prev.bottom) {\n    pos = positionLeft(pos, docRoot, modeTree);\n    if (pos === undefined) {\n      return undefined;\n    }\n    prev = boundaryXY(pos);\n  }\n\n  // pos is now at the end of the previous line. We need to find the position\n  // that is closest horizontally.\n\n  const prevTop = prev.top;\n  let minDist = Infinity;\n  let minPosition;\n  while (pos !== undefined) {\n    const dist = Math.abs(prev.left - initialBoundary.left);\n    // We've started moving away from the minimum distance.\n    if (dist > minDist) {\n      break;\n    }\n\n    // We've moved to yet another line. The minimum we have so far is *it*.\n    if (prev.bottom <= prevTop) {\n      break;\n    }\n\n    minDist = dist;\n    minPosition = pos;\n    pos = positionLeft(pos, docRoot, modeTree);\n    if (pos !== undefined) {\n      prev = boundaryXY(pos);\n    }\n  }\n\n  return minPosition;\n}\n\n//  LocalWords:  docRoot firstChild pos\n"]}