{"version":3,"sources":["../../../wed/wed-util.ts"],"names":[],"mappings":"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","file":"wed-util.js","sourcesContent":["/**\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\n//\n// We already have domutil and util so why this module? It combines those\n// functions that are really part of wed but are not meant to be used outside\n// the Editor class itself. domutil is meant to encompass those functions that\n// could be used in other contexts and are about the DOM. util is meant to\n// encompass those functions that do not depend on having a browser available.\n//\n\nimport { DLoc } from \"./dloc\";\nimport { isAttr, isElement, isText } from \"./domtypeguards\";\nimport { closestByClass, indexOf } from \"./domutil\";\nimport { AttributeNotFound } from \"./guiroot\";\n\nexport interface BoundaryCoordinates {\n  left: number;\n  top: number;\n  bottom: number;\n}\n\n// Utility function for boundaryXY.\nfunction parentBoundary(node: Node,\n                        root: Document | Element): BoundaryCoordinates {\n  const parent = node.parentNode!;\n\n  // Cannot find a sensible boundary\n  if (!root.contains(parent)) {\n    return { left: 0, top: 0, bottom: 0 };\n  }\n\n  return boundaryXY(DLoc.mustMakeDLoc(root, node));\n}\n\n// tslint:disable-next-line:max-func-body-length\nexport function boundaryXY(boundary: DLoc): BoundaryCoordinates {\n  const node = boundary.node;\n  let offset = boundary.offset;\n\n  const nodeIsElement = isElement(node);\n  const nodeIsText = isText(node);\n  let nodeLen;\n  if (nodeIsElement) {\n    nodeLen = node.childNodes.length;\n  }\n  else if (nodeIsText) {\n    nodeLen = (node as Text).length;\n  }\n  else {\n    throw new Error(`unexpected node type: ${node.nodeType}`);\n  }\n\n  // The node is empty ...\n  if (nodeLen === 0) {\n    return parentBoundary(node, boundary.root);\n  }\n\n  const range = node.ownerDocument.createRange();\n  let rect;\n\n  let child;\n  while (offset < nodeLen) {\n    // The array is empty if the node is a text node, and child will be\n    // undefined.\n    child = node.childNodes[offset];\n\n    // We use getClientRects()[0] so that when we are working with an inline\n    // node, we get only the first rect of the node. If the node is a block,\n    // then there should be only one rect anyway.\n    if (isElement(child)) {\n      rect = child.getClientRects()[0];\n    }\n    else {\n      range.setStart(node, offset);\n      range.setEnd(node, offset + 1);\n\n      rect = range.getClientRects()[0];\n    }\n\n    // If the element that covers the range is invisible, then getClientRects\n    // can return undefined. A 0, 0, 0, 0 rect is also theoretically possible.\n    if (rect != null &&\n        (rect.left !== 0 || rect.right !== 0 || rect.top !== 0 ||\n         rect.bottom !== 0)) {\n      return { left: rect.left, top: rect.top, bottom: rect.bottom };\n    }\n\n    offset++;\n  }\n\n  // We failed to find something after our offset from which to get\n  // coordinates. Try again.\n  offset = boundary.offset;\n\n  const win = node.ownerDocument.defaultView;\n  while (offset !== 0) {\n    offset--;\n    child = undefined;\n\n    // We check whether the thing we are going to cover with the range is\n    // inline.\n    let inline;\n    if (nodeIsText) {\n      inline = true;\n    }\n    else if (nodeIsElement) {\n      child = node.childNodes[offset];\n      if (isText(child)) {\n        inline = true;\n      }\n      else if (isElement(child)) {\n        const display = win.getComputedStyle(child).getPropertyValue(\"display\");\n        inline = (display === \"inline\" || display === \"inline-block\");\n      }\n      else {\n        throw new Error(`unexpected node type: ${child.nodeType}`);\n      }\n    }\n    else {\n      throw new Error(`unexpected node type: ${node.nodeType}`);\n    }\n\n    // If it is not empty, and offset is at the end of the contents, then there\n    // must be something *before* the point indicated by offset. Get a rectangle\n    // around that and return the right side as the left value.\n    let rects;\n    if (isElement(child)) {\n      rects = child.getClientRects();\n    }\n    else {\n      range.setStart(node, offset);\n      range.setEnd(node, offset + 1);\n      rects = range.getClientRects();\n    }\n    rect = rects[rects.length - 1];\n    if (rect != null) {\n      return (inline ?\n              // Yep, we use the right side when it is inline.\n              { left: rect.right, top: rect.top, bottom: rect.bottom } :\n              { left: rect.left, top: rect.top, bottom: rect.bottom });\n    }\n  }\n\n  // We can get here with an offset of 0. In this case, we have to move to the\n  // parent.\n  return parentBoundary(node, boundary.root);\n}\n\nexport function getAttrValueNode(attrVal: Element): Node {\n  if (!attrVal.classList.contains(\"_attribute_value\")) {\n    throw new Error(\"getAttrValueNode operates only on attribute values\");\n  }\n\n  let ret: Node = attrVal;\n\n  let child = attrVal.firstChild;\n  if (child !== null) {\n    while (child !== null && !isText(child)) {\n      child = child.nextSibling;\n    }\n\n    if (child !== null) {\n      ret = child;\n    }\n  }\n\n  return ret;\n}\n\n// tslint:disable-next-line:no-any\nexport type Editor = any;\n\nexport function cut(editor: Editor): void {\n  const caretManager = editor.caretManager;\n  const sel = caretManager.sel;\n  if (!(sel.wellFormed as boolean)) {\n    throw new Error(\"malformed range\");\n  }\n\n  const [startCaret, endCaret] = sel.asDataCarets();\n  while (editor._cut_buffer.firstChild !== null) {\n    editor._cut_buffer.removeChild(editor._cut_buffer.firstChild);\n  }\n  if (isAttr(startCaret.node)) {\n    const attr = startCaret.node;\n    if (attr !== endCaret.node) {\n      throw new Error(\"attribute selection that does not start \" +\n                      \"and end in the same attribute\");\n    }\n    const removedText = attr.value.slice(startCaret.offset, endCaret.offset);\n    editor._spliceAttribute(\n      closestByClass(caretManager.fromDataLocation(startCaret).node,\n                     \"_attribute_value\"),\n      startCaret.offset,\n      endCaret.offset - startCaret.offset, \"\");\n    editor._cut_buffer.textContent = removedText;\n  }\n  else {\n    const cutRet = editor.data_updater.cut(startCaret, endCaret);\n    const nodes = cutRet[1];\n    const parser = new editor.my_window.DOMParser();\n    const doc = parser.parseFromString(\"<div></div>\", \"text/xml\");\n    for (const node of nodes) {\n      doc.firstChild.appendChild(doc.adoptNode(node));\n    }\n    editor._cut_buffer.textContent = doc.firstChild.innerHTML;\n    editor.caretManager.setCaret(cutRet[0]);\n  }\n\n  const range = editor.doc.createRange();\n  const container = editor._cut_buffer;\n  range.setStart(container, 0);\n  range.setEnd(container, container.childNodes.length);\n  const domSel = editor.my_window.getSelection();\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n\n  // We've set the range to the cut buffer, which is what we want for the cut\n  // operation to work. However, the focus is also set to the cut buffer but\n  // once the cut is done we want the focus to be back to our caret, so...\n  setTimeout(() => {\n    caretManager.focusInputField();\n  }, 0);\n}\n\n// tslint:disable-next-line:no-any\nexport function paste(editor: Editor, data: any): void {\n  const toPaste = data.to_paste;\n  const dataClone = toPaste.cloneNode(true);\n  let caret = editor.caretManager.getDataCaret();\n  let newCaret;\n  let ret;\n\n  // Handle the case where we are pasting only text.\n  if (toPaste.childNodes.length === 1 && isText(toPaste.firstChild)) {\n    if (isAttr(caret.node)) {\n      const guiCaret = editor.caretManager.getNormalizedCaret();\n      editor._spliceAttribute(closestByClass(guiCaret.node, \"_attribute_value\",\n                                             guiCaret.node),\n                              guiCaret.offset, 0, toPaste.firstChild.data);\n    }\n    else {\n      ret = editor.data_updater.insertText(caret, toPaste.firstChild.data);\n      // In the first case, the node that contained the caret was modified to\n      // contain the text. In the 2nd case, a new node was created **or** the\n      // text that contains the text is a child of the original node.\n      newCaret = ((ret[0] === ret[1]) && (ret[1] === caret.node)) ?\n        // tslint:disable-next-line:restrict-plus-operands\n        caret.make(caret.node, caret.offset + toPaste.firstChild.length) :\n        caret.make(ret[1], ret[1].length);\n    }\n  }\n  else {\n    const frag = document.createDocumentFragment();\n    while (toPaste.firstChild !== null) {\n      frag.appendChild(toPaste.firstChild);\n    }\n    switch (caret.node.nodeType) {\n    case Node.TEXT_NODE:\n      ret = editor.data_updater.insertIntoText(caret, frag);\n      newCaret = ret[1];\n      break;\n    case Node.ELEMENT_NODE:\n      const child = caret.node.childNodes[caret.offset];\n      const after = child != null ? child.nextSibling : null;\n      editor.data_updater.insertBefore(caret.node, frag, child);\n      newCaret = caret.makeWithOffset(after !== null ?\n                                      indexOf(caret.node.childNodes, after) :\n                                      caret.node.childNodes.length);\n      break;\n    default:\n      throw new Error(`unexpected node type: ${caret.node.nodeType}`);\n    }\n  }\n  if (newCaret != null) {\n    editor.caretManager.setCaret(newCaret);\n    caret = newCaret;\n  }\n  editor.$gui_root.trigger(\"wed-post-paste\", [data.e, caret, dataClone]);\n}\n\nexport function getGUINodeIfExists(editor: Editor,\n                                   node: Node | null | undefined):\nNode | undefined {\n  if (node == null) {\n    return undefined;\n  }\n\n  try {\n    const caret = editor.caretManager.fromDataLocation(node, 0);\n    return caret != null ? caret.node : undefined;\n  }\n  catch (ex) {\n    if (ex instanceof AttributeNotFound) {\n      return undefined;\n    }\n\n    throw ex;\n  }\n}\n"]}