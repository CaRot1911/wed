{"version":3,"sources":["../../../wed/saver.ts"],"names":[],"mappings":"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","file":"saver.js","sourcesContent":["/**\n * Base class for savers.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { Observable, Subject } from \"rxjs\";\n\nimport * as browsers from \"./browsers\";\nimport { Runtime } from \"./runtime\";\nimport * as serializer from \"./serializer\";\nimport { TreeUpdater } from \"./tree-updater\";\n\nexport enum SaveKind {\n  AUTO = 1,\n  MANUAL,\n}\n\nfunction deltaToString(delta: number): string {\n  delta = Math.round(delta / 1000);\n  let timeDesc = \"moments ago\";\n  if (delta > 0) {\n    timeDesc = \" â‰ˆ \";\n    // To get a single digit after the decimal point, we divide by (factor /\n    // 10), round the result, and then divide by 10. Note that this is imprecise\n    // due to rounding errors in floating point arithmetic but we don't care.\n    if (delta > 60 * 60 * 24) {\n      timeDesc += `${Math.round(delta / (6 * 60 * 24)) / 10}d`;\n    }\n    else if (delta > 60 * 60) {\n      timeDesc += `${Math.round(delta / (6 * 60)) / 10}h`;\n    }\n    else if (delta > 60) {\n      timeDesc += `${Math.round(delta / 6) / 10}m`;\n    }\n    else {\n      timeDesc += `${delta}s`;\n    }\n    timeDesc += \" ago\";\n  }\n  return timeDesc;\n}\n\nexport interface SaveError {\n  /**\n   * The possible values for ``type`` are:\n   *\n   * - ``save_edited`` when the file to be saved has changed in the save\n   *   media. (For instance, if someone else edited a file that is stored on a\n   *   server.)\n   *\n   * - ``save_disconnected`` when the saver has lost contact with the media that\n   *   holds the data to be saved.\n   *\n   * - ``save_transient_error`` when an recoverable error happened while\n   *   saving. These are errors that a user should be able to recover from. For\n   *   instance, if the document must contain a specific piece of information\n   *   before being saved, this kind of error may be used to notify the user.\n   */\n  // tslint:disable-next-line:no-reserved-keywords\n  type: string | undefined;\n  msg: string;\n}\n\n/**\n * Emitted upon a failure during operations.\n */\nexport interface FailedEvent {\n  name: \"Failed\";\n  error: SaveError;\n}\n\n/**\n * This event is emitted when the saver detects that the document it is\n * responsible for saving has changed in a way that makes it stale from the\n * point of view of saving.\n *\n * Suppose that the document has been saved. Then a change is made. Upon this\n * first change, this event is emitted. Then a change is made again. Since the\n * document was *already* stale, this event is not emitted again.\n */\nexport interface ChangedEvent {\n  name: \"Changed\";\n}\n\n/**\n * This event is emitted after a document has been successfully saved.\n */\n\nexport interface Saved {\n  name: \"Saved\";\n}\n\n/**\n * This event is emitted after a document has been successfully autosaved.\n */\nexport interface Autosaved {\n  name: \"Autosaved\";\n}\n\nexport type SaveEvents = Saved | Autosaved | ChangedEvent | FailedEvent;\n\nexport interface SaverOptions {\n  /** The time between autosaves in seconds. */\n  autosave?: number;\n}\n\n/**\n * A saver is responsible for saving a document's data. This class cannot be\n * instantiated as-is, but only through subclasses.\n */\nexport abstract class Saver {\n  /**\n   * Subclasses must set this variable to true once they have finished with\n   * their initialization.\n   */\n  protected initialized: boolean = false;\n\n  /**\n   * Subclasses must set this variable to true if the saver is in a failed\n   * state. Note that the \"failed\" state is for cases where it makes no sense to\n   * attempt a recovery operation.\n   *\n   * One effect of being in a \"failed\" state is that the saver won't perform a\n   * recover operation if it is in a \"failed\" state.\n   */\n  protected failed: boolean;\n\n  /**\n   * The generation that is currently being edited.  It is mutable. Derived\n   * classes can read it but not modify it.\n   */\n  protected currentGeneration: number = 0;\n\n  /**\n   * The generation that has last been saved. Derived classes can read it but\n   * not modify it.\n   */\n  protected savedGeneration: number = 0;\n\n  /**\n   * The date of last modification.\n   */\n  private lastModification: number;\n\n  /**\n   * The date of last save.\n   */\n  private lastSave: number;\n\n  /**\n   * The last kind of save.\n   */\n  private lastSaveKind: SaveKind;\n\n  /**\n   * The interval at which to autosave, in milliseconds.\n   */\n  private autosaveInterval: number;\n\n  /**\n   * The current timeout object which will trigger an autosave. It has the value\n   * ``undefined`` if there is no current timeout.\n   */\n  private autosaveTimeout: number | undefined;\n\n  /**\n   * The object on which this class and subclasses may push new events.\n   */\n  protected readonly _events: Subject<SaveEvents>;\n\n  /**\n   * The observable on which clients can listen for events.\n   */\n  public readonly events: Observable<SaveEvents>;\n\n  private _boundAutosave: Function;\n\n  /**\n   * @param runtime The runtime under which this saver is created.\n   *\n   * @param version The version of wed for which this object is created.\n   *\n   * @param dataUpdater The updater that the editor created for its data tree.\n   *\n   * @param {Node} dataTree The editor's data tree.\n   */\n  constructor(protected readonly runtime: Runtime,\n              protected readonly version: string,\n              protected readonly dataUpdater: TreeUpdater,\n              protected readonly dataTree: Node,\n              protected readonly options: SaverOptions) {\n    dataUpdater.events.subscribe((ev) => {\n      if (ev.name !== \"Changed\") {\n        return;\n      }\n\n      this.lastModification = Date.now();\n      if (this.savedGeneration === this.currentGeneration) {\n        this.currentGeneration++;\n        this._events.next({ name: \"Changed\" });\n      }\n    });\n\n    /**\n     * The _autosave method, pre-bound to ``this``.\n     * @private\n     */\n    this._boundAutosave = this._autosave.bind(this);\n\n    this._events = new Subject();\n\n    this.events = this._events.asObservable();\n\n    if (options.autosave !== undefined) {\n      this.setAutosaveInterval(options.autosave * 1000);\n    }\n  }\n\n  /**\n   * This method must be called before using the saver. **MUST BE CALLED ONLY\n   * ONCE.**\n   *\n   * @returns A promise that is resolved when the saver is initialized.\n   */\n  abstract init(): Promise<void>;\n\n  /**\n   * This method must be called when the user manually initiates a save.\n   *\n   * @returns A promise which resolves if the save was successful.\n   */\n  save(): Promise<void> {\n    return this._save(false);\n  }\n\n  /**\n   * This method is called when saving or autosaving. This is the method\n   * responsible for the implementation-specific details.\n   *\n   * @param autosave ``true`` if called by an autosave, ``false`` if not.\n   */\n  protected abstract _save(autosave: boolean): Promise<void>;\n\n  /**\n   * This method returns the data to be saved in a save operation. Derived\n   * classes **must** call this method rather than get the data directly from\n   * the data tree.\n   */\n  getData(): string {\n    const child = this.dataTree.firstChild as Element;\n\n    if (browsers.MSIE) {\n      return serializer.serialize(child);\n    }\n\n    return child.outerHTML;\n  }\n\n  /**\n   * Must be called by derived class upon a successful save.\n   *\n   * @param autosave ``true`` if called for an autosave operation, ``false`` if\n   * not.\n   *\n   * @param savingGeneration The generation being saved. It is necessary to pass\n   * this value due to the asynchronous nature of some saving operations.\n   */\n  protected _saveSuccess(autosave: boolean, savingGeneration: number): void {\n    // If we get here, we've been successful.\n    this.savedGeneration = savingGeneration;\n    this.lastSave = Date.now();\n    this.lastSaveKind = autosave ? SaveKind.AUTO : SaveKind.MANUAL;\n    this._events.next(autosave ? { name: \"Autosaved\" } : { name: \"Saved\" });\n    // This resets the countdown to now.\n    this.setAutosaveInterval(this.autosaveInterval);\n  }\n\n  /**\n   * Must be called by derived classes when they fail to perform their task.\n   *\n   * @param The error message associated with the failure. If the error message\n   * is specified a ``failed`` event will be emitted. If not, no event is\n   * emitted.\n   */\n  protected _fail(error?: SaveError): void {\n    this.failed = true;\n    if (error !== undefined) {\n      this._events.next({ name: \"Failed\", error });\n    }\n  }\n\n  /**\n   * This is the function called internally when an autosave is needed.\n   */\n  private _autosave(): void {\n    this.autosaveTimeout = undefined;\n    const done = () => {\n      // Calling ``setAutosaveInterval`` effectively starts a new timeout, and\n      // takes care of possible race conditions. For instance, a call to\n      // ``setAutosaveInterval`` could happen after the current timeout has\n      // started saving but before ``done`` is called. This would launch a new\n      // timeout. If the code here called ``setTimeout`` instead of\n      // ``setAutosaveInterval`` then two timeouts would be running.\n      this.setAutosaveInterval(this.autosaveInterval);\n    };\n\n    if (this.currentGeneration !== this.savedGeneration) {\n      // We have something to save!\n      // tslint:disable-next-line:no-floating-promises\n      this._save(true).then(done);\n    }\n    else {\n      done();\n    }\n  }\n\n  /**\n   * Changes the interval at which autosaves are performed. Note that calling\n   * this function will stop the current countdown and restart it from zero. If,\n   * for instance, the previous interval was 5 minutes, and 4 minutes had\n   * elapsed since the last save, the next autosave should happen one minute\n   * from now. However, if I now call this function with a new interval of 4\n   * minutes, this will cause the next autosave to happen 4 minutes after the\n   * call, rather than one minute.\n   *\n   * @param interval The interval between autosaves in milliseconds. 0 turns off\n   * autosaves.\n   */\n  setAutosaveInterval(interval: number): void {\n    this.autosaveInterval = interval;\n    const oldTimeout = this.autosaveTimeout;\n\n    if (oldTimeout !== undefined) {\n      clearTimeout(oldTimeout);\n    }\n\n    this.autosaveTimeout = interval !== 0 ?\n      setTimeout(this._boundAutosave, interval) : undefined;\n  }\n\n  /**\n   * This method is to be used by wed upon encountering a fatal error. It will\n   * attempt to record the last state of the data tree before wed dies.\n   *\n   * @returns A promise which resolves to ``undefined`` if the method did not do\n   * anything because the Saver object is in an unintialized state or has\n   * already failed. It resolves to ``true`` if the recovery operation was\n   * successful, and ``false`` if not.\n   */\n  recover(): Promise<boolean | undefined> {\n    return Promise.resolve().then(() => {\n      if (!this.initialized || this.failed) {\n        return Promise.resolve(undefined);\n      }\n\n      return this._recover();\n    });\n  }\n\n  /**\n   * This method is called when recovering. This is the method responsible for\n   * the implementation-specific details.\n   *\n   * @returns A promise that resolves to ``true`` if the recovery operation was\n   * successful, and ``false`` if not.\n   */\n  protected abstract _recover(): Promise<boolean>;\n\n  /**\n   * Returns information regarding whether the saver sees the data tree as\n   * having been modified since the last save occurred.\n   *\n   * @returns ``false`` if the tree has not been modified. Otherwise, returns a\n   * string that describes how long ago the modification happened.\n   */\n  getModifiedWhen(): false | string {\n    if (this.savedGeneration === this.currentGeneration) {\n      return false;\n    }\n\n    return deltaToString(Date.now() - this.lastModification);\n  }\n\n  /**\n   * Produces a string that indicates in human readable format when the last\n   * save occurred.\n   *\n   * @returns The string. The value ``undefined`` is returned if no save has\n   * occurred yet.\n   */\n  getSavedWhen(): undefined | string {\n    if (this.lastSaveKind === undefined) {\n      return undefined;\n    }\n\n    return deltaToString(Date.now() - this.lastSave);\n  }\n\n  /**\n   * Returns the last kind of save that occurred.\n   *\n   * @returns {number|undefined} The kind. The value will be\n   * ``undefined`` if there has not been any save yet.\n   */\n  getLastSaveKind(): number | undefined {\n    return this.lastSaveKind;\n  }\n}\n\nexport interface SaverConstructor {\n  new (runtime: Runtime, version: string, dataUpdater: TreeUpdater,\n       dataTree: Node, options: SaverOptions): Saver;\n}\n\n//  LocalWords:  param unintialized Mangalam MPL Dubeau autosaved autosaves pre\n//  LocalWords:  autosave runtime autosaving setAutosaveInterval setTimeout\n"]}