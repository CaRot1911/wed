{"version":3,"file":"search.js","sourceRoot":"","sources":["../../../../lib/wed/search.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Facilities for searching through a document.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport * as rangy from \"rangy\";\n\nimport { CaretManager } from \"./caret-manager\";\nimport { DLoc, DLocRange, DLocRoot, getRoot } from \"./dloc\";\nimport { isElement } from \"./domtypeguards\";\nimport { closestByClass } from \"./domutil\";\n\n/** The direction of searches. */\nexport enum Direction {\n  FORWARD,\n  BACKWARDS,\n}\n\n/** The context for searches. */\nexport enum Context {\n  /** Everywhere in a document, including non-editable graphical elements. */\n  EVERYWHERE,\n\n  /** Only element text. */\n  TEXT,\n\n  /** Only attribute values. */\n  ATTRIBUTE_VALUES,\n}\n\nfunction unknownDirection(d: never): never {\n  throw new Error(`unknown direction: ${d}`);\n}\n\nfunction directionToRangyDirection(direction: Direction): rangy.Direction {\n  // There does not seem to be a way currently to declare this map in a way\n  // that will enforce that all directions have a value. :-/\n  // tslint:disable-next-line:no-object-literal-type-assertion\n  const ret = ({\n    [Direction.FORWARD]: \"forward\",\n    [Direction.BACKWARDS]: \"backward\",\n  } as Record<string, rangy.Direction>)[direction];\n\n  if (ret === undefined) {\n    // We have to cast to never since we're not using the switch exhaustion.\n    return unknownDirection(direction as never);\n  }\n\n  return ret;\n}\n\nfunction nodeInScope(doc: Document, node: Node, scope: Range): boolean {\n  const vrange = doc.createRange();\n  vrange.selectNode(node);\n\n  // The range that encompasses the node, must be completely within scope.\n  return (vrange.compareBoundaryPoints(Range.START_TO_START, scope) >= 0) &&\n    (vrange.compareBoundaryPoints(Range.END_TO_END, scope) <= 0);\n}\n\n/**\n * This is a utility class that holds a position among a list of elements\n * (representing attributes, in our usage).\n */\nclass AttributeValueCursor {\n  private current!: number;\n\n  /**\n   * @param values The values to iterate over.\n   *\n   * @param direction The direction to iterate over.\n   */\n  constructor(private readonly values: Element[],\n              private readonly direction: Direction) {\n    this.resetToStart();\n  }\n\n  /**\n   * @param value The index to reset this iterator to.\n   */\n  reset(value: number): void {\n    this.current = value;\n  }\n\n  /**\n   * @param value Reset to the start of [[values]]. This will be position 0 for\n   * an iterator moving forward. Or the end of [[values]] for an iterator moving\n   * backwards.\n   */\n  resetToStart(): void {\n    switch (this.direction) {\n    case Direction.FORWARD:\n      this.current = 0;\n      break;\n    case Direction.BACKWARDS:\n      this.current = this.values.length - 1;\n      break;\n    default:\n      return unknownDirection(this.direction);\n    }\n  }\n\n  /**\n   * @returns ``true`` if we have not reached the end of the array.\n   */\n  get hasNext(): boolean {\n    switch (this.direction) {\n    case Direction.FORWARD:\n      return this.current < this.values.length;\n    case Direction.BACKWARDS:\n      return this.current >= 0;\n    default:\n      return unknownDirection(this.direction);\n    }\n  }\n\n  /**\n   * This is the next element in iteration order. Moves the iterator in the\n   * direction of travel.\n   */\n  get next(): Element {\n    const ret = this.values[this.current];\n    this.inc();\n    return ret;\n  }\n\n  /**\n   * Moves the iterator in the direction of travel.\n   */\n  inc(): void {\n    switch (this.direction) {\n    case Direction.FORWARD:\n      this.current++;\n      break;\n    case Direction.BACKWARDS:\n      this.current--;\n      break;\n    default:\n      return unknownDirection(this.direction);\n    }\n  }\n\n}\n\n/**\n * This models a search on the GUI tree. Performing searches directly on the\n * data tree is theoretically possible but fraught with problems. For instance,\n * some data may not be visible to users and so the search in the data tree\n * would have to constantly refer to the GUI tree to determine whether a hit\n * should be shown. Additionally, the order of the data shown in the GUI tree\n * may differ from the order in the data tree.\n */\nexport class Search {\n  private readonly root: DLocRoot;\n  private _pattern: string = \"\";\n  private _scope: DLocRange | undefined;\n\n  private prevEnd: DLoc | undefined;\n\n  /**\n   * The current match. This is ``undefined`` if we have not searched yet.  It\n   * is ``null`` if nothing matches.\n   */\n  current: DLocRange | null | undefined;\n\n  /** The direction in which the search moves. */\n  direction: Direction = Direction.FORWARD;\n\n  /** The context for the search. */\n  context: Context = Context.EVERYWHERE;\n\n  constructor(public readonly caretManager: CaretManager,\n              public readonly guiRoot: Document | Element,\n              private start: DLoc,\n              scope: DLocRange | undefined) {\n    this.root = getRoot(guiRoot);\n    this.setScope(scope);\n    const realScope = this.scope;\n    if (realScope.start.compare(start) > 0 ||\n        realScope.end.compare(start) < 0) {\n      throw new Error(\"the scope does not contain the start position\");\n    }\n\n    this.start = start;\n  }\n\n  set pattern(value: string) {\n    this._pattern = value;\n  }\n\n  get pattern(): string {\n    return this._pattern;\n  }\n\n  /**\n   * Set the search scope. No result will be returned outside the scope. Setting\n   * the scope to ``undefined`` means \"search the whole document\".\n   */\n  private setScope(range: DLocRange | undefined): void {\n    if (range === undefined) {\n      this._scope = undefined;\n      return;\n    }\n\n    if (!range.isValid()) {\n      throw new Error(\"passed an invalid range\");\n    }\n\n    const { start, end } = range;\n    if (start.root !== this.root.node) {\n      throw new Error(\"the range does not use the search's root\");\n    }\n\n    // Since the start and end of a range must share the same root, we don't\n    // have to test the end of the range.\n\n    this._scope = start.compare(end) > 0 ?\n      // Start is after end, flip them.\n      new DLocRange(end, start) :\n      // Regular order\n      new DLocRange(start, end);\n  }\n\n  private get scope(): DLocRange {\n    if (this._scope === undefined) {\n      this._scope = new DLocRange(\n        DLoc.mustMakeDLoc(this.root, this.guiRoot, 0),\n        DLoc.mustMakeDLoc(this.root, this.guiRoot,\n                          this.guiRoot.childNodes.length));\n    }\n\n    return this._scope;\n  }\n\n  updateCurrent(): void {\n    this._next(true);\n  }\n\n  next(): void {\n    this._next(false);\n  }\n\n  private _next(includeCurrent: boolean): void {\n    let ret: DLocRange | null = null;\n    if (this.pattern !== \"\") {\n      let rollPosition: DLoc;\n      let start: DLoc;\n      switch (this.direction) {\n      case Direction.FORWARD: {\n        start = this.getForwardSearchStart(includeCurrent);\n        rollPosition = this.scope.start;\n        break;\n      }\n      case Direction.BACKWARDS: {\n        start = this.getBackwardSearchStart(includeCurrent);\n        rollPosition = this.scope.end;\n        break;\n      }\n      default:\n        return unknownDirection(this.direction);\n      }\n\n      const hit = this.find(start, this.direction);\n      if (hit !== null) {\n        ret = new DLocRange(\n          DLoc.mustMakeDLoc(this.root, hit.startContainer, hit.startOffset),\n          DLoc.mustMakeDLoc(this.root, hit.endContainer, hit.endOffset));\n      }\n      else {\n        // If we did not get a hit, we roll over on the next search.\n        this.start = rollPosition;\n      }\n    }\n\n    this.current = ret;\n  }\n\n  private find(start: DLoc, direction: Direction): Range | null {\n    if (this.context === Context.ATTRIBUTE_VALUES) {\n      return this.findAttributeValue(start, direction);\n    }\n\n    return this.findText(start, directionToRangyDirection(direction));\n  }\n\n  private findText(start: DLoc, direction: rangy.Direction): Range | null {\n    // tslint:disable-next-line:no-any\n    const config = (rangy as any).config;\n    const range = new rangy.WrappedRange(start.makeRange()!);\n    if (this.context === Context.TEXT) {\n      config.customIsCollapsedNode = (node: Node) => {\n        return isElement(node) && node.closest(\"._phantom\") !== null;\n      };\n    }\n\n    let found = range.findText(this.pattern, {\n      withinRange: this.scope.mustMakeDOMRange(),\n      direction,\n    });\n\n    // There is a bug in Rangy that makes it so that it may sometimes return\n    // hits outside the scope. Test for it.\n    if (found) {\n      const hitStart = DLoc.mustMakeDLoc(this.guiRoot, range.startContainer,\n                                         range.startOffset);\n      if (!this.scope.contains(hitStart)) {\n        found = false;\n      }\n    }\n\n    config.customIsCollapsedNode = undefined;\n    return found ? range.nativeRange : null;\n  }\n\n  private findAttributeValue(start: DLoc, direction: Direction): Range | null {\n    // Implement our own logic instead of relying on rangy. We can just move\n    // from attribute value to attribute value and checks the values.\n    const guiRoot = this.guiRoot;\n    const allValues =\n      Array.from(guiRoot.getElementsByClassName(\"_attribute_value\"));\n    const caretManager = this.caretManager;\n\n    const valueCursor = new AttributeValueCursor(allValues, direction);\n    const attrValue = closestByClass(start.node, \"_attribute_value\", guiRoot);\n    const doc = guiRoot.ownerDocument;\n    const scope = this.scope.mustMakeDOMRange();\n    if (attrValue === null) {\n      // We need to find the next attribute.\n      let found: Node | undefined;\n      while (valueCursor.hasNext) {\n        const value = valueCursor.next;\n        if (nodeInScope(doc, value, scope) &&\n            // tslint:disable-next-line:no-bitwise\n            ((value.compareDocumentPosition(start.node) &\n              Node.DOCUMENT_POSITION_PRECEDING) !== 0)) {\n          found = value;\n          break;\n        }\n      }\n\n      if (found === undefined) {\n        return null;\n      }\n\n      start = start.make(found, 0);\n    }\n    else {\n      const index = allValues.indexOf(attrValue);\n      if (index === -1) {\n        throw new Error(\"internal error: cannot find value in array!\");\n      }\n      valueCursor.reset(index);\n      valueCursor.inc();\n    }\n\n    let dataLoc = caretManager.toDataLocation(start)!;\n    // tslint:disable-next-line:no-constant-condition\n    while (true) {\n      // Going into the data tree simplifies some of the work here.\n      const node = dataLoc.node as Attr;\n      let index: number;\n      switch (direction) {\n      case Direction.FORWARD:\n        index = node.value.indexOf(this.pattern, dataLoc.offset);\n        break;\n      case Direction.BACKWARDS:\n        // For a backward search, the hit is not allowed to cross the start\n        // position. (This, by the way, is the same way Emacs operates.)\n        const startOffset = dataLoc.offset - this.pattern.length;\n        index = (startOffset < 0) ?\n          -1 : node.value.lastIndexOf(this.pattern, startOffset);\n        break;\n      default:\n        return unknownDirection(direction);\n      }\n\n      if (index !== -1) {\n        const rangeStart =\n          caretManager.mustFromDataLocation(dataLoc.makeWithOffset(index));\n        const rangeEnd =\n          caretManager.mustFromDataLocation(\n            dataLoc.makeWithOffset(index + this.pattern.length));\n        if (this.scope.contains(rangeStart) && this.scope.contains(rangeEnd)) {\n          return new DLocRange(rangeStart, rangeEnd).mustMakeDOMRange();\n        }\n      }\n\n      // We did not find a good hit, so continue searching other values.\n      let next: Element | null = null;\n      while (next === null && valueCursor.hasNext) {\n        next = valueCursor.next;\n        if (!nodeInScope(doc, next, scope)) {\n          next = null;\n        }\n      }\n\n      if (next === null) {\n        return null;\n      }\n\n      let dataNext = caretManager.toDataLocation(next, 0)!;\n      switch (direction) {\n      case Direction.FORWARD:\n        break;\n      case Direction.BACKWARDS:\n        dataNext =\n          dataNext.makeWithOffset((dataNext.node as Attr).value.length);\n        break;\n      default:\n        return unknownDirection(direction);\n      }\n\n      dataLoc = dataNext;\n    }\n  }\n\n  private getForwardSearchStart(includeCurrent: boolean): DLoc {\n    if (this.current != null) {\n      return includeCurrent ? this.current.start : this.current.end;\n    }\n\n    return this.start;\n  }\n\n  private getBackwardSearchStart(includeCurrent: boolean): DLoc {\n    let ret: DLoc | undefined;\n    if (this.current != null) {\n      ret = includeCurrent ? this.prevEnd : this.current.start;\n    }\n\n    if (ret === undefined) {\n      ret = this.start;\n    }\n\n    this.prevEnd = ret;\n    return ret;\n  }\n}\n"]}