{"version":3,"file":"decorator.js","sourceRoot":"","sources":["../../../../lib/wed/decorator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Basic decoration facilities.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport $ from \"jquery\";\nimport * as salve from \"salve\";\n\nimport { Action } from \"./action\";\nimport { DLoc } from \"./dloc\";\nimport { DOMListener } from \"./domlistener\";\nimport { isAttr } from \"./domtypeguards\";\nimport * as  domutil from \"./domutil\";\nimport { GUIUpdater } from \"./gui-updater\";\nimport { ActionContextMenu, Item } from \"./gui/action-context-menu\";\nimport { Mode } from \"./mode\";\nimport { DecoratorAPI, EditorAPI } from \"./mode-api\";\nimport { TransformationData } from \"./transformation\";\nimport * as  util from \"./util\";\n\nconst indexOf = domutil.indexOf;\nconst closestByClass = domutil.closestByClass;\n\nfunction tryToSetDataCaret(editor: EditorAPI, dataCaret: DLoc): void {\n  try {\n    editor.caretManager.setCaret(dataCaret, { textEdit: true });\n  }\n  catch (e) {\n    // Do nothing.\n  }\n}\n\nfunction attributeSelectorMatch(selector: string, name: string): boolean {\n  return selector === \"*\" || selector === name;\n}\n\n/**\n * A decorator is responsible for adding decorations to a tree of DOM\n * elements. Decorations are GUI elements.\n */\nexport abstract class Decorator implements DecoratorAPI {\n  protected readonly namespaces: Record<string, string>;\n  protected readonly domlistener: DOMListener;\n  protected readonly guiUpdater: GUIUpdater;\n\n  /**\n   * @param domlistener The listener that the decorator must use to know when\n   * the DOM tree has changed and must be redecorated.\n   *\n   * @param editor The editor instance for which this decorator was created.\n   *\n   * @param guiUpdater The updater to use to modify the GUI tree. All\n   * modifications to the GUI must go through this updater.\n   */\n  constructor(protected readonly mode: Mode,\n              protected readonly editor: EditorAPI) {\n    this.domlistener = editor.domlistener;\n    this.guiUpdater = editor.guiUpdater;\n    this.namespaces = mode.getAbsoluteNamespaceMappings();\n  }\n\n  /**\n   * Request that the decorator add its event handlers to its listener.\n   */\n  abstract addHandlers(): void;\n\n  /**\n   * Start listening to changes to the DOM tree.\n   */\n  startListening(): void {\n    this.domlistener.startListening();\n  }\n\n  listDecorator(el: Element, sep: string | Element): void {\n    if (this.editor.modeTree.getMode(el) !== this.mode) {\n      // The element is not governed by this mode.\n      return;\n    }\n\n    // We expect to work with a homogeneous list. That is, all children the same\n    // element.\n    const nameMap: Record<string, number> = Object.create(null);\n    let child = el.firstElementChild;\n    while (child !== null) {\n      if (child.classList.contains(\"_real\")) {\n        nameMap[util.getOriginalName(child)] = 1;\n      }\n      child = child.nextElementSibling;\n    }\n\n    const tags = Object.keys(nameMap);\n    if (tags.length > 1) {\n      throw new Error(\"calling listDecorator on a non-homogeneous list.\");\n    }\n\n    if (tags.length === 0) {\n      return;\n    } // Nothing to work with\n\n    // First drop all children that are separators\n    child = el.firstElementChild;\n    while (child !== null) {\n      // Grab it before the node is removed.\n      const next = child.nextElementSibling;\n      if (child.hasAttribute(\"data-wed--separator-for\")) {\n        this.guiUpdater.removeNode(child);\n      }\n      child = next;\n    }\n\n    const tagName = tags[0];\n\n    // If sep is a string, create an appropriate div.\n    let sepNode: Element;\n    if (typeof sep === \"string\") {\n      sepNode = el.ownerDocument.createElement(\"div\");\n      sepNode.textContent = sep;\n    }\n    else {\n      sepNode = sep;\n    }\n\n    sepNode.classList.add(\"_text\");\n    sepNode.classList.add(\"_phantom\");\n    sepNode.setAttribute(\"data-wed--separator-for\", tagName);\n\n    let first = true;\n    child = el.firstElementChild;\n    while (child !== null) {\n      if (child.classList.contains(\"_real\")) {\n        if (!first) {\n          this.guiUpdater.insertBefore(el, sepNode.cloneNode(true) as Element,\n                                       child);\n        }\n        else {\n          first = false;\n        }\n      }\n      child = child.nextElementSibling;\n    }\n  }\n\n  elementDecorator(_root: Element, el: Element, level: number,\n                   preContextHandler: ((wedEv: JQueryMouseEventObject,\n                                        ev: Event) => boolean) | undefined,\n                   postContextHandler: ((wedEv: JQueryMouseEventObject,\n                                         ev: Event) => boolean) | undefined):\n  void {\n    if (this.editor.modeTree.getMode(el) !== this.mode) {\n      // The element is not governed by this mode.\n      return;\n    }\n\n    if (level > this.editor.maxLabelLevel) {\n      throw new Error(\n        `level higher than the maximum set by the mode: ${level}`);\n    }\n\n    // Save the caret because the decoration may mess up the GUI caret.\n    let dataCaret: DLoc | undefined = this.editor.caretManager.getDataCaret();\n    if (dataCaret != null &&\n        !(isAttr(dataCaret.node) &&\n          dataCaret.node.ownerElement === $.data(el, \"wed_mirror_node\"))) {\n      dataCaret = undefined;\n    }\n\n    const dataNode = $.data(el, \"wed_mirror_node\");\n    this.setReadOnly(el, Boolean(this.editor.validator.getNodeProperty(\n      dataNode, \"PossibleDueToWildcard\")));\n\n    const origName = util.getOriginalName(el);\n    // _[name]_label is used locally to make the function idempotent.\n    let cls = `_${origName}_label`;\n\n    // We must grab a list of nodes to remove before we start removing them\n    // because an element that has a placeholder in it is going to lose the\n    // placeholder while we are modifying it. This could throw off the scan.\n    const toRemove = domutil.childrenByClass(el, cls);\n    for (const remove of toRemove) {\n      el.removeChild(remove);\n    }\n\n    let attributesHTML = \"\";\n    let hiddenAttributes = false;\n    const attributeHandling = this.editor.modeTree.getAttributeHandling(el);\n    if (attributeHandling === \"show\" || attributeHandling === \"edit\") {\n      // include the attributes\n      const attributes = util.getOriginalAttributes(el);\n      const names = Object.keys(attributes).sort();\n\n      for (const name of names) {\n        const hideAttribute = this.mustHideAttribute(el, name);\n        if (hideAttribute) {\n          hiddenAttributes = true;\n        }\n\n        const extra = hideAttribute ? \" _shown_when_caret_in_label\" : \"\";\n\n        attributesHTML += ` \\\n<span class=\"_phantom _attribute${extra}\">\\\n<span class=\"_phantom _attribute_name\">${name}</span>=\\\n\"<span class=\"_phantom _attribute_value\">\\\n${domutil.textToHTML(attributes[name])}</span>\"</span>`;\n      }\n    }\n\n    const doc = el.ownerDocument;\n    cls += ` _label_level_${level}`;\n\n    // Save the cls of the end label here so that we don't further modify it.\n    const endCls = cls;\n\n    if (hiddenAttributes) {\n      cls += \" _autohidden_attributes\";\n    }\n    const pre = doc.createElement(\"span\");\n    pre.className = `_gui _phantom __start_label _start_wrapper ${cls} _label`;\n    const prePh = doc.createElement(\"span\");\n    prePh.className = \"_phantom\";\n    // tslint:disable-next-line:no-inner-html\n    prePh.innerHTML = `&nbsp;<span class='_phantom _element_name'>${origName}\\\n</span>${attributesHTML}<span class='_phantom _greater_than'> >&nbsp;</span>`;\n    pre.appendChild(prePh);\n    this.guiUpdater.insertNodeAt(el, 0, pre);\n\n    const post = doc.createElement(\"span\");\n    post.className = `_gui _phantom __end_label _end_wrapper ${endCls} _label`;\n    const postPh = doc.createElement(\"span\");\n    postPh.className = \"_phantom\";\n    // tslint:disable-next-line:no-inner-html\n    postPh.innerHTML = `<span class='_phantom _less_than'>&nbsp;&lt; </span>\\\n<span class='_phantom _element_name'>${origName}</span>&nbsp;`;\n    post.appendChild(postPh);\n    this.guiUpdater.insertBefore(el, post, null);\n\n    // Setup a handler so that clicking one label highlights it and the other\n    // label.\n    $(pre).on(\"wed-context-menu\",\n              preContextHandler !== undefined ? preContextHandler : false);\n\n    $(post).on(\"wed-context-menu\",\n               postContextHandler !== undefined ? postContextHandler : false);\n\n    if (dataCaret != null) {\n      tryToSetDataCaret(this.editor, dataCaret);\n    }\n  }\n\n  /**\n   * Determine whether an attribute must be hidden. The default implementation\n   * calls upon the ``attributes.autohide`` section of the \"wed options\" that\n   * were used by the mode in effect to determine whether an attribute should be\n   * hidden or not.\n   *\n   * @param el The element in the GUI tree that we want to test.\n   *\n   * @param name The attribute name in \"prefix:localName\" format where \"prefix\"\n   * is to be understood according to the absolute mapping defined by the mode.\n   *\n   * @returns ``true`` if the attribute must be hidden. ``false`` otherwise.\n   */\n  protected mustHideAttribute(el: Element, name: string): boolean {\n    const specs = this.editor.modeTree.getAttributeHidingSpecs(el);\n    if (specs === null) {\n      return false;\n    }\n\n    for (const element of specs.elements) {\n      if (el.matches(element.selector)) {\n        let matches = false;\n        for (const attribute of element.attributes) {\n          if (typeof attribute === \"string\") {\n            // If we already matched, there's no need to try to match with\n            // another selector.\n            if (!matches) {\n              matches = attributeSelectorMatch(attribute, name);\n            }\n          }\n          else {\n            // If we do not match yet, there's no need to try to exclude the\n            // attribute.\n            if (matches) {\n              for (const exception of attribute.except) {\n                matches = !attributeSelectorMatch(exception, name);\n                // As soon as we stop matching, there's no need to continue\n                // checking other exceptions.\n                if (!matches) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // An element selector that matches is terminal.\n        return matches;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Add or remove the CSS class ``_readonly`` on the basis of the 2nd argument.\n   *\n   * @param el The element to modify. Must be in the GUI tree.\n   *\n   * @param readonly Whether the element is readonly or not.\n   */\n  setReadOnly(el: Element, readonly: boolean): void {\n    const cl = el.classList;\n    (readonly ? cl.add : cl.remove).call(cl, \"_readonly\");\n  }\n\n  /**\n   * Context menu handler for the labels of elements decorated by\n   * [[Decorator.elementDecorator]].\n   *\n   * @param atStart Whether or not this event is for the start label.\n   *\n   * @param wedEv The DOM event that wed generated to trigger this handler.\n   *\n   * @param ev The DOM event that wed received.\n   *\n   * @returns To be interpreted the same way as for all DOM event handlers.\n   */\n  // tslint:disable-next-line:max-func-body-length\n  protected contextMenuHandler(atStart: boolean, wedEv: JQueryMouseEventObject,\n                               ev: JQueryEventObject): boolean {\n    const editor = this.editor;\n    const editingMenuManager = editor.editingMenuManager;\n    let node = wedEv.target;\n    const menuItems: Item[] = [];\n    const mode = editor.modeTree.getMode(node);\n\n    function pushItem(data: TransformationData | null,\n                      tr: Action<TransformationData>,\n                      start?: boolean): void {\n      const li = editingMenuManager.makeMenuItemForAction(tr, data, start);\n      menuItems.push({ action: tr, item: li, data: data });\n    }\n\n    function pushItems(data: TransformationData | null,\n                       trs?: Action<{}>[], start?: boolean): void {\n      if (trs === undefined) {\n        return;\n      }\n\n      for (const tr of trs) {\n        pushItem(data, tr, start);\n      }\n    }\n\n    function processAttributeNameEvent(event: salve.Event,\n                                       element: Element): void {\n      const namePattern = event.params[1] as salve.Name;\n      // The next if line causes tslint to inexplicably raise a failure. I am\n      // able to reproduce it with something as small as:\n      //\n      // import { Name } from \"salve\";\n      //\n      // export function func(p: Name): void {\n      //   if (p.simple()) {\n      //     document.body.textContent = \"1\";\n      //   }\n      // }\n      //\n      // tslint:disable-next-line:strict-boolean-expressions\n      if (namePattern.simple()) {\n        for (const name of namePattern.toArray()) {\n          const unresolved =\n            mode.getAbsoluteResolver().unresolveName(name.ns, name.name);\n          if (unresolved === undefined) {\n            throw new Error(\"cannot unresolve attribute\");\n          }\n\n          if (editor.isAttrProtected(unresolved, element)) {\n            return;\n          }\n\n          pushItems({ name: unresolved, node: element },\n                    mode.getContextualActions(\"add-attribute\", unresolved,\n                                              element));\n        }\n      }\n      else {\n        pushItem(null, editor.complexPatternAction);\n      }\n    }\n\n    const real = closestByClass(node, \"_real\", editor.guiRoot);\n    const readonly = real !== null && real.classList.contains(\"_readonly\");\n\n    const attrVal = closestByClass(node, \"_attribute_value\", editor.guiRoot);\n    if (attrVal !== null) {\n      const dataNode = editor.toDataNode(attrVal) as Attr;\n      const treeCaret =\n        DLoc.mustMakeDLoc(editor.dataRoot, dataNode.ownerElement);\n      const toAddTo = treeCaret.node.childNodes[treeCaret.offset];\n      editor.validator.possibleAt(treeCaret, true).forEach((event) => {\n        if (event.params[0] !== \"attributeName\") {\n          return;\n        }\n        processAttributeNameEvent(event, toAddTo as Element);\n      });\n\n      const name = dataNode.name;\n      if (!editor.isAttrProtected(dataNode)) {\n        pushItems({ name: name, node: dataNode },\n                  mode.getContextualActions(\"delete-attribute\", name,\n                                            dataNode));\n      }\n    }\n    else {\n      // We want the first real parent.\n      const candidate = closestByClass(node, \"_real\", editor.guiRoot);\n      if (candidate === null) {\n        throw new Error(\"cannot find real parent\");\n      }\n\n      node = candidate;\n      const topNode = (node.parentNode === editor.guiRoot);\n\n      menuItems.push(\n        ...editingMenuManager.makeCommonItems(editor.toDataNode(node)!));\n\n      // We first gather the transformations that pertain to the node to which\n      // the label belongs.\n      const orig = util.getOriginalName(node);\n\n      if (!topNode) {\n        pushItems({ node: node, name: orig },\n                  mode.getContextualActions(\n                    [\"unwrap\", \"delete-element\"],\n                    orig, $.data(node, \"wed_mirror_node\"), 0));\n      }\n\n      // Then we check what could be done before the node (if the\n      // user clicked on an start element label) or after the node\n      // (if the user clicked on an end element label).\n      const parent = node.parentNode!;\n      let index = indexOf(parent.childNodes, node);\n\n      // If we're on the end label, we want the events *after* the node.\n      if (!atStart) {\n        index++;\n      }\n      const treeCaret = editor.caretManager.toDataLocation(parent, index);\n      if (treeCaret === undefined) {\n        throw new Error(\"cannot get caret\");\n      }\n\n      if (atStart) {\n        const toAddTo = treeCaret.node.childNodes[treeCaret.offset];\n        const attributeHandling = editor.modeTree.getAttributeHandling(toAddTo);\n        if (attributeHandling === \"edit\") {\n          editor.validator.possibleAt(treeCaret, true).forEach((event) => {\n            if (event.params[0] !== \"attributeName\") {\n              return;\n            }\n            processAttributeNameEvent(event, toAddTo as Element);\n          });\n        }\n      }\n\n      if (!topNode) {\n        for (const tr of editor.getElementTransformationsAt(treeCaret,\n                                                            \"insert\")) {\n          if (tr.name !== undefined) {\n            // Regular case: we have a real transformation.\n            pushItem({ name: tr.name, moveCaretTo: treeCaret }, tr.tr, atStart);\n          }\n          else {\n            // It is an action rather than a transformation.\n            pushItem(null, tr.tr);\n          }\n        }\n\n        if (atStart) {\n          // Move to inside the element and get the get the wrap-content\n          // possibilities.\n          const caretInside =\n            treeCaret.make(treeCaret.node.childNodes[treeCaret.offset], 0);\n          for (const tr of editor.getElementTransformationsAt(caretInside,\n                                                              \"wrap-content\")) {\n            pushItem(tr.name !== undefined ? { name: tr.name, node: node }\n                     : null,\n                     tr.tr);\n          }\n        }\n      }\n    }\n\n    // There's no menu to display, so let the event bubble up.\n    if (menuItems.length === 0) {\n      return true;\n    }\n\n    editingMenuManager.setupContextMenu(ActionContextMenu, menuItems, readonly,\n                                        ev);\n    return false;\n  }\n}\n\n//  LocalWords:  attributeName unresolve func tslint readonly localName endCls\n//  LocalWords:  PossibleDueToWildcard Dubeau MPL Mangalam attributesHTML util\n//  LocalWords:  jquery validator domutil domlistener gui autohidden jQuery cls\n//  LocalWords:  listDecorator origName li nbsp lt el sep\n"]}