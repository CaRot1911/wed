{"version":3,"sources":["../../../wed/domutil.ts"],"names":[],"mappings":"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","file":"domutil.js","sourcesContent":["/**\n * Utilities that manipulate or query the DOM tree.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport * as $ from \"jquery\";\nimport * as rangy from \"rangy\";\nimport { isAttr, isDocument, isDocumentFragment, isElement,\n         isText } from \"./domtypeguards\";\nimport * as util from \"./util\";\n\n/**\n * Search an array.\n *\n * @param a The array to search.\n *\n * @param target The target to find.\n *\n * @return -1 if the target is not found, or its index.\n */\nexport function indexOf(a: NodeList, target: Node): number;\nexport function indexOf<T>(a: T[], target: T): number;\nexport function indexOf<T>(a: T[] | NodeList, target: T | Node): number {\n  const length = a.length;\n  for (let i = 0; i < length; ++i) {\n    if (a[i] === target) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Gets the first range in the selection.\n *\n * @param win The window for which we want the selection.\n *\n * @returns The first range in the selection. Undefined if there is no selection\n * or no range.\n */\nexport function getSelectionRange(win: Window): rangy.RangyRange | undefined {\n  const sel = rangy.getSelection(win);\n\n  if (sel === undefined || sel.rangeCount < 1) {\n    return undefined;\n  }\n\n  return sel.getRangeAt(0);\n}\n\n/**\n * A range and a flag indicating whether it is a reversed range or not. Range\n * objects themselves do not record how they were created. If the range was\n * created from a starting point which is greater than the end point (in\n * document order), then the range is \"reversed\".\n */\nexport type RangeInfo = {range: rangy.RangyRange, reversed: boolean};\n\n/**\n * Creates a range from two points in a document.\n *\n * @returns The range information.\n */\nexport function rangeFromPoints(startContainer: Node,\n                                startOffset: number,\n                                endContainer: Node,\n                                endOffset: number): RangeInfo {\n  const range = rangy.createRange(startContainer.ownerDocument);\n  let reversed = false;\n  if (rangy.dom.comparePoints(startContainer, startOffset,\n                              endContainer, endOffset) <= 0) {\n    range.setStart(startContainer, startOffset);\n    range.setEnd(endContainer, endOffset);\n  }\n  else {\n    range.setStart(endContainer, endOffset);\n    range.setEnd(startContainer, startOffset);\n    reversed = true;\n  }\n\n  return { range: range, reversed: reversed };\n}\n\n/**\n * Focuses the node itself or if the node is a text node, focuses the parent.\n *\n * @param node The node to focus.\n *\n * @throws {Error} If the node is neither a text node nor an element. Trying to\n * focus something other than these is almost certainly an algorithmic bug.\n */\nexport function focusNode(node: Node): void {\n  const nodeType = node != null ? node.nodeType : undefined;\n  switch (nodeType) {\n  case Node.TEXT_NODE:\n    if (node.parentNode == null) {\n      throw new Error(\"detached node\");\n    }\n    (node.parentNode as HTMLElement).focus();\n    break;\n  case Node.ELEMENT_NODE:\n    (node as HTMLElement).focus();\n    break;\n  default:\n    throw new Error(\"tried to focus something other than a text node or \" +\n                    \"an element.\");\n  }\n}\n\n/**\n * A caret position in the form of a pair of values. The caret we are talking\n * about here roughly corresponds to the caret that a \"contenteditable\" element\n * would present to the user. It can index in text nodes and element nodes but\n * not in attributes.\n */\nexport type Caret = [Node, number];\n\n/**\n * This function determines the caret position if the caret was moved forward.\n *\n * This function does not fully emulate how a browser moves the caret. The sole\n * emulation it performs is to check whether whitespace matters or not. It skips\n * whitespace that does not matter.\n *\n * @param caret A caret position where the search starts. This should be an\n * array of length two that has in first position the node where the caret is\n * and in second position the offset in that node. This pair is to be\n * interpreted in the same way node, offset pairs are interpreted in selection\n * or range objects.\n *\n * @param container A DOM node which indicates the container within which caret\n * movements must be contained.\n *\n * @param noText If true, and a text node would be returned, the function will\n * instead return the parent of the text node.\n *\n * @returns The next caret position, or ``null`` if such position does not\n * exist. The ``container`` parameter constrains movements to positions inside\n * it.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nexport function nextCaretPosition(caret: Caret,\n                                  container: Node,\n                                  noText: boolean): Caret | null {\n  let [node, offset] = caret;\n  let found = false;\n\n  if (!container.contains(node)) {\n    return null;\n  }\n\n  const doc = isDocument(node) ? node : node.ownerDocument;\n\n  const window = doc.defaultView;\n  let parent;\n  search_loop:\n  while (!found) {\n    parent = node.parentNode;\n    switch (node.nodeType) {\n    case Node.TEXT_NODE:\n      if (offset >= (node as Text).length ||\n          // If the parent node is set to normal whitespace handling, then\n          // moving the caret forward by one position will skip this whitespace.\n          (parent != null && parent.lastChild === node &&\n           window.getComputedStyle(parent as Element, undefined).whiteSpace ===\n           \"normal\" && /^\\s+$/.test((node as Text).data.slice(offset)))) {\n        // We would move outside the container\n        if (parent == null || node === container) {\n          break search_loop;\n        }\n\n        offset = indexOf(parent.childNodes, node) + 1;\n        node = parent;\n      }\n      else {\n        offset++;\n        found = true;\n      }\n      break;\n    case Node.ELEMENT_NODE:\n      if (offset >= node.childNodes.length) {\n        // If we've hit the end of what we can search, stop.\n        if (parent == null || node === container) {\n          break search_loop;\n        }\n\n        offset = indexOf(parent.childNodes, node) + 1;\n        node = parent;\n        found = true;\n      }\n      else {\n        node = node.childNodes[offset];\n        offset = 0;\n        found = !(node.childNodes.length > 0 &&\n                  isText(node.childNodes[offset]));\n      }\n      break;\n    default:\n      break;\n    }\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  if (noText && isText(node)) {\n    parent = node.parentNode;\n    if (parent == null) {\n      throw new Error(\"detached node\");\n    }\n    offset = indexOf(parent.childNodes, node);\n    node = parent;\n  }\n\n  // We've moved to a position outside the container.\n  if (!container.contains(node) ||\n      (node === container && offset >= node.childNodes.length)) {\n    return null;\n  }\n\n  return [node, offset];\n}\n\n/**\n * This function determines the caret position if the caret was moved backwards.\n *\n * This function does not fully emulate how a browser moves the caret. The sole\n * emulation it performs is to check whether whitespace matters or not. It skips\n * whitespace that does not matter.\n *\n * @param caret A caret position where the search starts. This should be an\n * array of length two that has in first position the node where the caret is\n * and in second position the offset in that node. This pair is to be\n * interpreted in the same way node, offset pairs are interpreted in selection\n * or range objects.\n *\n * @param container A DOM node which indicates the container within which caret\n * movements must be contained.\n *\n * @param noText If true, and a text node would be returned, the function will\n * instead return the parent of the text node.\n *\n * @returns The previous caret position, or ``null`` if such position does not\n * exist. The ``container`` parameter constrains movements to positions inside\n * it.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nexport function prevCaretPosition(caret: Caret,\n                                  container: Node,\n                                  noText: boolean): Caret | null {\n  let [node, offset] = caret;\n  let found = false;\n\n  if (!container.contains(node)) {\n    return null;\n  }\n\n  const doc = isDocument(node) ? node : node.ownerDocument;\n\n  const window = doc.defaultView;\n  let parent;\n  search_loop:\n  while (!found) {\n    offset--;\n\n    // We've moved to a position outside the container.\n    if (node === container && offset < 0) {\n      return null;\n    }\n\n    parent = node.parentNode;\n    switch (node.nodeType) {\n    case Node.TEXT_NODE:\n      if (offset < 0 ||\n          // If the parent node is set to normal whitespace handling, then\n          // moving the caret back by one position will skip this whitespace.\n          (parent != null && parent.firstChild === node &&\n           window.getComputedStyle(parent as Element, undefined).whiteSpace ===\n           \"normal\" && /^\\s+$/.test((node as Text).data.slice(0, offset)))) {\n        // We would move outside the container\n        if (parent === null || node === container) {\n          break search_loop;\n        }\n\n        offset = indexOf(parent.childNodes, node);\n        node = parent;\n      }\n      else {\n        found = true;\n      }\n      break;\n    case Node.ELEMENT_NODE:\n      if (offset < 0 || node.childNodes.length === 0) {\n        // If we've hit the end of what we can search, stop.\n        if (parent == null || node === container) {\n          break search_loop;\n        }\n\n        offset = indexOf(parent.childNodes, node);\n        node = parent;\n        found = true;\n      }\n      // If node.childNodes.length === 0, the first branch would have been\n      // taken. No need to test that offset indexes to something that exists.\n      else {\n        node = node.childNodes[offset];\n        if (isElement(node)) {\n          offset = node.childNodes.length;\n          found = !(node.childNodes.length > 0 &&\n                    isText(node.childNodes[offset - 1]));\n        }\n        else {\n          offset = (node as Text).length + 1;\n        }\n      }\n      break;\n    default:\n      break;\n    }\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  if (noText && isText(node)) {\n    parent = node.parentNode;\n    if (parent == null) {\n      throw new Error(\"detached node\");\n    }\n\n    offset = indexOf(parent.childNodes, node);\n    node = parent;\n  }\n\n  // We've moved to a position outside the container.\n  if (!container.contains(node) || (node === container && offset < 0)) {\n    return null;\n  }\n\n  return [node, offset];\n}\n\n/**\n * Given two trees A and B of DOM nodes, this function finds the node in tree B\n * which corresponds to a node in tree A. The two trees must be structurally\n * identical. If tree B is cloned from tree A, it will satisfy this\n * requirement. This function does not work with attribute nodes.\n *\n * @param treeA The root of the first tree.\n *\n * @param treeB The root of the second tree.\n *\n * @param nodeInA A node in the first tree.\n *\n * @returns The node which corresponds to ``nodeInA`` in ``treeB``.\n *\n * @throws {Error} If ``nodeInA`` is not ``treeA`` or a child of ``treeA``.\n */\nexport function correspondingNode(treeA: Node, treeB: Node,\n                                  nodeInA: Node): Node {\n  const path = [];\n  let current = nodeInA;\n  while (current !== treeA) {\n    const parent = current.parentNode;\n    if (parent == null) {\n      throw new Error(\"nodeInA is not treeA or a child of treeA\");\n    }\n    path.unshift(indexOf(parent.childNodes, current));\n    current = parent;\n  }\n\n  let ret = treeB;\n  while (path.length !== 0) {\n    ret = ret.childNodes[path.shift()!];\n  }\n\n  return ret;\n}\n\n/**\n * Makes a placeholder element\n *\n * @param text The text to put in the placeholder.\n *\n * @returns A node.\n */\nexport function makePlaceholder(text?: string): HTMLElement {\n  const span = document.createElement(\"span\");\n  span.className = \"_placeholder\";\n  span.setAttribute(\"contenteditable\", \"true\");\n  span.textContent = text !== undefined ? text : \" \";\n  return span;\n}\n\nexport type InsertionBoundaries = [Caret, Caret];\n\nexport interface GenericInsertIntoTextContext {\n  insertNodeAt(into: Element, index: number, node: Node): void;\n  deleteNode(node: Node): void;\n  /**\n   * This function performs roughly the same as insertNodeAt but may be\n   * optimized to take care of fragment handling.\n   */\n  insertFragAt?(into: Element, index: number, node: DocumentFragment): void;\n}\n\n/**\n * Inserts an element into text, effectively splitting the text node in\n * two. This function takes care to modify the DOM tree only once.\n *\n * @private\n *\n * @param textNode The text node that will be cut in two by the new element.\n *\n * @param index The offset into the text node where the new element is to be\n * inserted.\n *\n * @param node The node to insert. If undefined, then this function effectively\n * splits the text node into two parts.\n *\n * @param The operation must clean contiguous text nodes so as to merge them and\n * must not create empty nodes. **This code assumes that the text node into\n * which data is added is not preceded or followed by another text node and that\n * it is not empty.** In other words, if the DOM tree on which this code is used\n * does not have consecutive text nodes and no empty nodes, then after the call,\n * it still won't.\n *\n * @returns A pair containing a caret position marking the boundary between what\n * comes before the material inserted and the material inserted, and a caret\n * position marking the boundary between the material inserted and what comes\n * after. If I insert \"foo\" at position 2 in \"abcd\", then the final result would\n * be \"abfoocd\" and the first caret would mark the boundary between \"ab\" and\n * \"foo\" and the second caret the boundary between \"foo\" and \"cd\".\n *\n * @throws {Error} If ``textNode`` is not a text node.\n */\nfunction _genericInsertIntoText(this: GenericInsertIntoTextContext,\n                                textNode: Text,\n                                index: number,\n                                node?: Node,\n                                clean: boolean = true): InsertionBoundaries {\n  // This function is meant to be called with this set to a proper\n  // value.\n  /* jshint validthis:true */\n  if (!isText(textNode)) {\n    throw new Error(\"insertIntoText called on non-text\");\n  }\n\n  let startCaret: Caret;\n  let endCaret: Caret;\n\n  if (clean === undefined) {\n    clean = true;\n  }\n\n  // Normalize\n  if (index < 0) {\n    index = 0;\n  }\n  else if (index > textNode.length) {\n    index = textNode.length;\n  }\n\n  let prev;\n  let next;\n  const isFragment = isDocumentFragment(node);\n\n  // A parent is necessarily an element.\n  const parent = textNode.parentNode as Element;\n  if (parent == null) {\n    throw new Error(\"detached node\");\n  }\n  let textNodeAt = indexOf(parent.childNodes, textNode);\n  if (clean && (node == null || (isFragment && node.childNodes.length === 0))) {\n    startCaret = endCaret = [textNode, index];\n  }\n  else {\n    const frag = document.createDocumentFragment();\n    prev = document.createTextNode(textNode.data.slice(0, index));\n    frag.appendChild(prev);\n    if (node != null) {\n      frag.appendChild(node);\n    }\n    next = document.createTextNode(textNode.data.slice(index));\n    const nextLen = next.length;\n    frag.appendChild(next);\n\n    if (clean) {\n      frag.normalize();\n    }\n\n    if (clean && index === 0) {\n      startCaret = [parent, textNodeAt];\n    }\n    else {\n      startCaret = [frag.firstChild!, index];\n    }\n\n    if (clean && index === textNode.length) {\n      endCaret = [parent, textNodeAt + frag.childNodes.length];\n    }\n    else {\n      endCaret = [frag.lastChild!, (frag.lastChild as Text)!.length - nextLen];\n    }\n\n    // tslint:disable:no-invalid-this\n    this.deleteNode(textNode);\n    if (this.insertFragAt !== undefined) {\n      this.insertFragAt(parent, textNodeAt, frag);\n    }\n    else {\n      while (frag.firstChild != null) {\n        this.insertNodeAt(parent, textNodeAt++, frag.firstChild);\n      }\n    }\n    // tslint:enable:no-invalid-this\n  }\n  return [startCaret, endCaret];\n}\n\n/**\n * Inserts an element into text, effectively splitting the text node in\n * two. This function takes care to modify the DOM tree only once.\n *\n * @param textNode The text node that will be cut in two by the new element.\n *\n * @param index The offset into the text node where the new element is to be\n * inserted.\n *\n * @param node The node to insert.\n *\n * @returns A pair containing a caret position marking the boundary between what\n * comes before the material inserted and the material inserted, and a caret\n * position marking the boundary between the material inserted and what comes\n * after. If I insert \"foo\" at position 2 in \"abcd\", then the final result would\n * be \"abfoocd\" and the first caret would mark the boundary between \"ab\" and\n * \"foo\" and the second caret the boundary between \"foo\" and \"cd\".\n *\n * @throws {Error} If the node to insert is undefined or null.\n */\nexport function genericInsertIntoText(this: GenericInsertIntoTextContext,\n                                      textNode: Text,\n                                      index: number,\n                                      node?: Node): InsertionBoundaries {\n  // This function is meant to be called with this set to a proper\n  // value.\n  if (node == null) {\n    throw new Error(\"must pass an actual node to insert\");\n  }\n  // tslint:disable-next-line:no-invalid-this\n  return _genericInsertIntoText.call(this, textNode, index, node);\n}\n\n/**\n * Records the results of inserting text into the tree.\n */\nexport interface TextInsertionResult {\n  /** The node that contains the added text. */\n  node: Text | undefined;\n\n  /** Whether [[node]] is a new node. If ``false``, it was modified. */\n  isNew: boolean;\n\n  /** The caret position after the insertion. */\n  caret: Caret;\n}\n\nexport interface GenericInsertTextContext {\n  insertNodeAt(into: Element, index: number, node: Node): void;\n  setTextNodeValue(node: Text, value: string): void;\n}\n\n/**\n * Inserts text into a node. This function will use already existing\n * text nodes whenever possible rather than create a new text node.\n *\n * @param node The node where the text is to be inserted.\n *\n * @param index The location in the node where the text is\n * to be inserted.\n *\n * @param text The text to insert.\n *\n * @param caretAtEnd Whether the caret position returned should be placed at the\n * end of the inserted text.\n *\n * @returns The result of inserting the text.\n *\n * @throws {Error} If ``node`` is not an element or text Node type.\n */\nexport function genericInsertText(this: GenericInsertTextContext,\n                                  node: Node,\n                                  index: number,\n                                  text: string,\n                                  caretAtEnd: boolean = true):\nTextInsertionResult {\n  // This function is meant to be called with this set to a proper\n  // value.\n  if (text === \"\") {\n    return {\n      node: undefined,\n      isNew: false,\n      caret: [node, index],\n    };\n  }\n\n  let isNew: boolean = false;\n  let textNode: Text;\n  let caret: Caret;\n  work:\n  // tslint:disable-next-line:no-constant-condition strict-boolean-expressions\n  while (true) {\n    switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      const child = node.childNodes[index];\n      if (isText(child)) {\n        // Prepend to already existing text node.\n        node = child;\n        index = 0;\n        continue work;\n      }\n\n      const prev = node.childNodes[index - 1];\n      if (isText(prev)) {\n        // Append to already existing text node.\n        node = prev;\n        index = prev.length;\n        continue work;\n      }\n\n      // We have to create a text node\n      textNode = document.createTextNode(text);\n      isNew = true;\n      // Node is necessarily an element when we get here.\n      // tslint:disable-next-line:no-invalid-this\n      this.insertNodeAt(node as Element, index, textNode);\n      caret = [textNode, caretAtEnd ? text.length : 0];\n      break work;\n    case Node.TEXT_NODE:\n      textNode = node as Text;\n      const pre = textNode.data.slice(0, index);\n      const post = textNode.data.slice(index);\n      // tslint:disable-next-line:no-invalid-this\n      this.setTextNodeValue(textNode, pre + text + post);\n      caret = [textNode, caretAtEnd ? index + text.length : index];\n      break work;\n    default:\n      throw new Error(`unexpected node type: ${node.nodeType}`);\n    }\n  }\n\n  return {\n    node: textNode,\n    isNew,\n    caret: caret,\n  };\n}\n\n/**\n * Deletes text from a text node. If the text node becomes empty, it is deleted.\n *\n * @param node The text node from which to delete text.\n *\n * @param index The index at which to delete text.\n *\n * @param length The length of text to delete.\n *\n * @throws {Error} If ``node`` is not a text Node type.\n */\nexport function deleteText(node: Text, index: number, length: number): void {\n  if (!isText(node)) {\n    throw new Error(\"deleteText called on non-text\");\n  }\n\n  node.deleteData(index, length);\n  if (node.length === 0) {\n    if (node.parentNode == null) {\n      throw new Error(\"detached node\");\n    }\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * This function recursively links two DOM trees through the jQuery ``.data()``\n * method. For an element in the first tree the data item named\n * \"wed_mirror_node\" points to the corresponding element in the second tree, and\n * vice-versa. It is presumed that the two DOM trees are perfect mirrors of each\n * other, although no test is performed to confirm this.\n */\nexport function linkTrees(rootA: Element, rootB: Element): void {\n  $.data(rootA, \"wed_mirror_node\", rootB);\n  $.data(rootB, \"wed_mirror_node\", rootA);\n  for (let i = 0; i < rootA.children.length; ++i) {\n    const childA = rootA.children[i];\n    const childB = rootB.children[i];\n    linkTrees(childA, childB);\n  }\n}\n\n/**\n * This function recursively unlinks a DOM tree though the jQuery ``.data()``\n * method.\n *\n * @param root A DOM node.\n *\n */\nexport function unlinkTree(root: Element): void {\n  $.removeData(root, \"wed_mirror_node\");\n  for (let i = 0; i < root.children.length; ++i) {\n    unlinkTree(root.children[i]);\n  }\n}\n\n/**\n * Returns the first descendant or the node passed to the function if the node\n * happens to not have a descendant. The function searches in document order.\n *\n * When passed ``<p><b>A</b><b><q>B</q></b></p>`` this code would return the\n * text node \"A\" because it has no children and is first.\n *\n * @param node The node to search.\n *\n * @returns The first node which is both first in its parent and has no\n * children.\n */\nexport function firstDescendantOrSelf(node: Node | null | undefined):\nNode | null {\n  if (node === undefined) {\n    node = null;\n  }\n\n  while (node !== null && node.firstChild !== null) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Returns the last descendant or the node passed to the function if the node\n * happens to not have a descendant. The function searches in reverse document\n * order.\n *\n * When passed ``<p><b>A</b><b><q>B</q></b></p>`` this code would return the\n * text node \"B\" because it has no children and is last.\n *\n * @param node The node to search.\n *\n * @returns The last node which is both last in its parent and has no\n * children.\n */\nexport function lastDescendantOrSelf(node: Node | null | undefined):\nNode | null {\n  if (node === undefined) {\n    node = null;\n  }\n\n  while (node !== null && node.lastChild !== null) {\n    node = node.lastChild;\n  }\n  return node;\n}\n\n/**\n * Removes the node. Mainly for use with the generic functions defined here.\n *\n * @param node The node to remove.\n */\nexport function deleteNode(node: Node): void {\n  if (node.parentNode == null) {\n    // For historical reasons we raise an error rather than make it a noop.\n    throw new Error(\"detached node\");\n  }\n  node.parentNode.removeChild(node);\n}\n\n/**\n * Inserts a node at the position specified. Mainly for use with the generic\n * functions defined here.\n *\n * @param parent The node which will become the parent of the inserted node.\n *\n * @param index The position at which to insert the node into the parent.\n *\n * @param node The node to insert.\n */\nfunction insertNodeAt(parent: Element, index: number, node: Node): void {\n  const child = parent.childNodes[index];\n  parent.insertBefore(node, child != null ? child : null);\n}\n\n/**\n * Inserts text into a node. This function will use already existing text nodes\n * whenever possible rather than create a new text node.\n *\n * @function\n *\n * @param node The node where the text is to be inserted.\n *\n * @param index The location in the node where the text is to be inserted.\n *\n * @param text The text to insert.\n *\n * @param caretAtEnd Whether to return the caret position at the end of the\n * inserted text or at the beginning. Default to ``true``.\n *\n * @returns The result of inserting the text.\n *\n * @throws {Error} If ``node`` is not an element or text Node type.\n */\nexport function insertText(node: Node,\n                           index: number,\n                           text: string,\n                           caretAtEnd?: boolean): TextInsertionResult {\n  return genericInsertText.call({\n    insertNodeAt: insertNodeAt,\n    setTextNodeValue: (textNode: Text, value: string) => {\n      textNode.data = value;\n    },\n    // tslint:disable-next-line:align\n  }, node, index, text, caretAtEnd);\n}\n\nconst plainDOMMockup: GenericInsertIntoTextContext = {\n  insertNodeAt: insertNodeAt,\n  insertFragAt: insertNodeAt,\n  deleteNode: deleteNode,\n};\n\n/**\n * See [[_genericInsertIntoText]].\n *\n * @private\n */\nfunction _insertIntoText(textNode: Text,\n                         index: number,\n                         node?: Node,\n                         clean: boolean = true): InsertionBoundaries {\n  return _genericInsertIntoText.call(plainDOMMockup, textNode, index, node,\n                                     clean);\n}\n\n/**\n * Inserts an element into text, effectively splitting the text node in\n * two. This function takes care to modify the DOM tree only once.\n *\n * @param textNode The text node that will be cut in two by the new element.\n *\n * @param index The offset into the text node where the new element is to be\n * inserted.\n *\n * @param node The node to insert.\n *\n * @returns A pair containing a caret position marking the boundary between what\n * comes before the material inserted and the material inserted, and a caret\n * position marking the boundary between the material inserted and what comes\n * after. If I insert \"foo\" at position 2 in \"abcd\", then the final result would\n * be \"abfoocd\" and the first caret would mark the boundary between \"ab\" and\n * \"foo\" and the second caret the boundary between \"foo\" and \"cd\".\n */\nexport function insertIntoText(textNode: Text,\n                               index: number,\n                               node: Node): InsertionBoundaries {\n  return genericInsertIntoText.call(plainDOMMockup, textNode, index, node);\n}\n\nexport type SplitResult = [Node, Node];\n\n/**\n * Splits a text node into two nodes. This function takes care to modify the DOM\n * tree only once.\n *\n * @param textNode The text node to split into two text nodes.\n *\n * @param index The offset into the text node where to split.\n *\n * @returns The first element is the node before index after split and the\n * second element is the node after the index after split.\n */\nexport function splitTextNode(textNode: Text, index: number): SplitResult {\n  const carets = _insertIntoText(textNode, index, undefined, false);\n  return [carets[0][0], carets[1][0]];\n}\n\n/**\n * Merges a text node with the next text node, if present. When called on\n * something which is not a text node or if the next node is not text, does\n * nothing. Mainly for use with the generic functions defined here.\n *\n * @param node The node to merge with the next node.\n *\n * @returns A caret position between the two parts that were merged, or between\n * the two nodes that were not merged (because they were not both text).\n */\nexport function mergeTextNodes(node: Node): Caret {\n  const next = node.nextSibling;\n  if (isText(node) && isText(next)) {\n    const offset = node.length;\n    node.appendData(next.data);\n    next.parentNode!.removeChild(next);\n    return [node, offset];\n  }\n\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error(\"detached node\");\n  }\n  return [parent, indexOf(parent.childNodes, node) + 1];\n}\n\nexport interface RangeLike {\n  startContainer: Node;\n  startOffset: number;\n  endContainer: Node;\n  endOffset: number;\n}\n\nexport type ElementPair = [Element, Element];\n\n/**\n * Returns the **element** nodes that contain the start and the end of the\n * range. If an end of the range happens to be in a text node, the element node\n * will be that node's parent.\n *\n * @private\n *\n * @param range An object which has the ``startContainer``, ``startOffset``,\n * ``endContainer``, ``endOffset`` attributes set. The interpretation of these\n * values is the same as for DOM ``Range`` objects. Therefore, the object passed\n * can be a DOM range.\n *\n * @returns A pair of nodes.\n *\n * @throws {Error} If a node in ``range`` is not of element or text Node types.\n */\nfunction nodePairFromRange(range: RangeLike): ElementPair {\n  let startNode;\n  switch (range.startContainer.nodeType) {\n  case Node.TEXT_NODE:\n    startNode = range.startContainer.parentNode as Element;\n    if (startNode == null) {\n      throw new Error(\"detached node\");\n    }\n    break;\n  case Node.ELEMENT_NODE:\n    startNode = range.startContainer as Element;\n    break;\n  default:\n    throw new Error(`unexpected node type: ${range.startContainer.nodeType}`);\n\n  }\n\n  let endNode;\n  switch (range.endContainer.nodeType) {\n  case Node.TEXT_NODE:\n    endNode = range.endContainer.parentNode as Element;\n    if (endNode == null) {\n      throw new Error(\"detached node\");\n    }\n    break;\n  case Node.ELEMENT_NODE:\n    endNode = range.endContainer as Element;\n    break;\n  default:\n    throw new Error(`unexpected node type: ${range.endContainer.nodeType}`);\n  }\n  return [startNode, endNode];\n}\n\n/**\n * Determines whether a range is well-formed. A well-formed range is one which\n * starts and ends in the same element.\n *\n * @param range An object which has the ``startContainer``,\n * ``startOffset``, ``endContainer``, ``endOffset`` attributes set. The\n * interpretation of these values is the same as for DOM ``Range``\n * objects. Therefore, the object passed can be a DOM range.\n *\n * @returns ``true`` if the range is well-formed.  ``false`` if not.\n */\nexport function isWellFormedRange(range: RangeLike): boolean {\n  const pair = nodePairFromRange(range);\n  return pair[0] === pair[1];\n}\n\nexport interface GenericCutContext {\n  deleteText(node: Text, index: number, length: number): void;\n  deleteNode(node: Node): void;\n  mergeTextNodes(node: Node): Caret;\n}\n\nexport type CutResult = [Caret, Node[]];\n\n/**\n * Removes the contents between the start and end carets from the DOM tree. If\n * two text nodes become adjacent, they are merged.\n *\n * @param startCaret Start caret position.\n *\n * @param endCaret Ending caret position.\n *\n * @returns The first item is the caret position indicating where the cut\n * happened. The second item is a list of nodes, the cut contents.\n *\n * @throws {Error} If Nodes in the range are not in the same element.\n */\n// tslint:disable-next-line:max-func-body-length\nexport function genericCutFunction(this: GenericCutContext,\n                                   startCaret: Caret,\n                                   endCaret: Caret): CutResult {\n  if (!isWellFormedRange({ startContainer: startCaret[0],\n                           startOffset: startCaret[1],\n                           endContainer: endCaret[0],\n                           endOffset: endCaret[1] })) {\n    throw new Error(\"range is not well-formed\");\n  }\n\n  let [startContainer, startOffset] = startCaret;\n  let [endContainer, endOffset] = endCaret;\n\n  let parent = startContainer.parentNode;\n  if (parent == null) {\n    throw new Error(\"detached node\");\n  }\n  let finalCaret: [Node, number];\n  let startText;\n\n  if (isText(startContainer) && startOffset === 0) {\n    // We are at the start of a text node, move up to the parent.\n    startOffset = indexOf(parent.childNodes, startContainer);\n    startContainer = parent;\n    parent = startContainer.parentNode;\n    if (parent == null) {\n      throw new Error(\"detached node\");\n    }\n  }\n\n  if (isText(startContainer)) {\n    const sameContainer = startContainer === endContainer;\n\n    const startContainerOffset = indexOf(parent.childNodes, startContainer);\n\n    const endTextOffset = sameContainer ? endOffset : startContainer.length;\n\n    startText = parent.ownerDocument.createTextNode(\n      startContainer.data.slice(startOffset, endTextOffset));\n    // tslint:disable-next-line:no-invalid-this\n    this.deleteText(startContainer, startOffset, startText.length);\n\n    finalCaret = (startContainer.parentNode != null) ?\n      [startContainer, startOffset] :\n      // Selection was such that the text node was emptied.\n      [parent, startContainerOffset];\n\n    if (sameContainer) {\n      // Both the start and end were in the same node, so the deleteText\n      // operation above did everything needed.\n      return [finalCaret, [startText]];\n    }\n\n    // Alter our start to take care of the rest\n    startOffset = (startContainer.parentNode != null) ?\n      // Look after the text node we just modified.\n      startContainerOffset + 1 :\n      // Selection was such that the text node was emptied, and thus removed. So\n      // stay at the same place.\n      startContainerOffset;\n    startContainer = parent;\n  }\n  else {\n    finalCaret = [startContainer, startOffset];\n  }\n\n  let endText;\n  if (isText(endContainer)) {\n    parent = endContainer.parentNode;\n    if (parent == null) {\n      throw new Error(\"detached node\");\n    }\n\n    const endContainerOffset = indexOf(parent.childNodes, endContainer);\n\n    endText = parent.ownerDocument.createTextNode(\n      endContainer.data.slice(0, endOffset));\n    // tslint:disable-next-line:no-invalid-this\n    this.deleteText(endContainer, 0, endOffset);\n\n    // Alter our end to take care of the rest\n    endOffset = endContainerOffset;\n    endContainer = parent;\n  }\n\n  // At this point, the following checks must hold\n  if (startContainer !== endContainer) {\n    throw new Error(\"internal error in cut: containers unequal\");\n  }\n  if (!isElement(startContainer)) {\n    throw new Error(\"internal error in cut: not an element\");\n  }\n\n  const returnNodes = [];\n  endOffset--;\n  // Doing it in reverse allows us to not worry about offsets getting out of\n  // whack.\n  while (endOffset >= startOffset) {\n    returnNodes.unshift(endContainer.childNodes[endOffset]);\n    // tslint:disable-next-line:no-invalid-this\n    this.deleteNode(endContainer.childNodes[endOffset]);\n    endOffset--;\n  }\n  if (startText != null) {\n    returnNodes.unshift(startText);\n  }\n  if (endText != null) {\n    returnNodes.push(endText);\n  }\n\n  // At this point, endOffset points to the node that is before the list of\n  // nodes removed.\n  if (endContainer.childNodes[endOffset] != null) {\n    // tslint:disable-next-line:no-invalid-this\n    this.mergeTextNodes(endContainer.childNodes[endOffset]);\n  }\n  return [finalCaret, returnNodes];\n}\n\n/**\n * Dumps a range to the console.\n *\n * @param msg A message to output in front of the range information.\n *\n * @param range The range.\n */\nexport function dumpRange(msg: string, range?: RangeLike): void {\n  if (range == null) {\n    // tslint:disable-next-line:no-console\n    console.log(msg, \"no range\");\n  }\n  else {\n    // tslint:disable-next-line:no-console\n    console.log(msg,\n                range.startContainer,\n                range.startOffset,\n                range.endContainer,\n                range.endOffset);\n  }\n}\n\n/**\n * Dumps the current selection to the console.\n *\n * @param msg A message to output in front of the range information.\n *\n * @param win The window for which to dump selection information.\n */\nexport function dumpCurrentSelection(msg: string, win: Window): void {\n  dumpRange(msg, getSelectionRange(win));\n}\n\n/**\n * Dumps a range to a string.\n *\n * @param msg A message to output in front of the range information.\n *\n * @param range The range.\n */\nexport function dumpRangeToString(msg: string, range?: RangeLike): string {\n  let ret;\n  if (range == null) {\n    ret = [msg, \"no range\"];\n  }\n  else {\n    ret = [msg,\n           (range.startContainer as Element).outerHTML,\n           range.startOffset,\n           (range.endContainer as Element).outerHTML,\n           range.endOffset];\n  }\n\n  return ret.join(\", \");\n}\n\n/**\n * Checks whether a point is in the element's contents. This means inside the\n * element and **not** inside one of the scrollbars that the element may\n * have. The coordinates passed must be **relative to the document.** If the\n * coordinates are taken from an event, this means passing ``pageX`` and\n * ``pageY``.\n *\n * @param element The element to check.\n *\n * @param x The x coordinate **relative to the document.**\n *\n * @param y The y coordinate **relative to the document.**\n *\n * @returns ``true`` if inside, ``false`` if not.\n */\nexport function pointInContents(element: Element,\n                                x: number, y: number): boolean {\n  // Convert the coordinates relative to the document to coordinates relative to\n  // the element.\n  const body = element.ownerDocument.body;\n  // Using clientLeft and clientTop is not equivalent to using the rect.\n  const rect = element.getBoundingClientRect();\n  x -= rect.left + body.scrollLeft;\n  y -= rect.top + body.scrollTop;\n\n  return ((x >= 0) && (y >= 0) &&\n          (x < element.clientWidth) && (y < element.clientHeight));\n}\n\n/**\n * Starting with the node passed, and walking up the node's\n * parents, returns the first node that matches the selector.\n *\n * @param node The node to start with.\n *\n * @param selector The selector to use for matches.\n *\n * @param limit The algorithm will search up to this limit, inclusively.\n *\n * @returns The first element that matches the selector, or ``null`` if nothing\n * matches.\n */\nexport function closest(node: Node | undefined | null,\n                        selector: string,\n                        limit?: Element| Document): Element | null {\n  if (node == null) {\n    return null;\n  }\n\n  // Immediately move out of text nodes.\n  if (isText(node)) {\n    node = node.parentNode;\n  }\n\n  while (node != null) {\n    if (!isElement(node)) {\n      return null;\n    }\n\n    if (node.matches(selector)) {\n      break;\n    }\n\n    if (node === limit) {\n      node = null;\n      break;\n    }\n\n    node = node.parentNode;\n  }\n\n  return node as Element;\n}\n\n/**\n * Starting with the node passed, and walking up the node's parents, returns the\n * first element that matches the class.\n *\n * @param node The node to start with.\n *\n * @param cl The class to use for matches.\n *\n * @param limit The algorithm will search up to this limit, inclusively.\n *\n * @returns The first element that matches the class, or ``null`` if nothing\n * matches.\n */\nexport function closestByClass(node: Node | undefined | null, cl: string,\n                               limit?: Element | Document): Element | null {\n  if (node == null) {\n    return null;\n  }\n\n  // Immediately move out of text nodes.\n  if (isText(node)) {\n    node = node.parentNode;\n  }\n\n  while (node != null) {\n    if (!isElement(node)) {\n      return null;\n    }\n\n    if (node.classList.contains(cl)) {\n      break;\n    }\n\n    if (node === limit) {\n      node = null;\n      break;\n    }\n\n    node = node.parentNode;\n  }\n\n  return node as Element;\n}\n\n/**\n * Find a sibling matching the class.\n *\n * @param node The element whose sibling we are looking for.\n *\n * @param cl The class to use for matches.\n *\n * @returns The first sibling (in document order) that matches the class, or\n * ``null`` if nothing matches.\n */\nexport function siblingByClass(node: Node | null, cl: string): Element | null {\n  if (!isElement(node)) {\n    return null;\n  }\n\n  const parent = node.parentNode as Element;\n  if (parent == null) {\n    return null;\n  }\n\n  let child = parent.firstElementChild;\n  while (child != null && !child.classList.contains(cl)) {\n    child = child.nextElementSibling;\n  }\n  return child;\n}\n\n/**\n * Find children matching the class.\n *\n * @param node The element whose children we are looking for.\n *\n * @param cl The class to use for matches.\n *\n * @returns The children (in document order) that match the class.\n */\nexport function childrenByClass(node: Node | null, cl: string): Element[] {\n  if (!isElement(node)) {\n    return [];\n  }\n\n  const ret = [];\n  let child = node.firstElementChild;\n  while (child != null) {\n    if (child.classList.contains(cl)) {\n      ret.push(child);\n    }\n    child = child.nextElementSibling;\n  }\n\n  return ret;\n}\n\n/**\n * Find child matching the class.\n *\n * @param node The element whose child we are looking for.\n *\n * @param cl The class to use for matches.\n *\n * @returns The first child (in document order) that matches the class, or\n * ``null`` if nothing matches.\n */\nexport function childByClass(node: Node | null, cl: string): Element | null {\n  if (!isElement(node)) {\n    return null;\n  }\n\n  let child = node.firstElementChild;\n  while (child != null && !child.classList.contains(cl)) {\n    child = child.nextElementSibling;\n  }\n  return child;\n}\n\nlet textToHTMLSpan: HTMLSpanElement;\n\n/**\n * Convert a string to HTML encoding. For instance if you want to have the\n * less-than symbol be part of the contents of a ``span`` element, it would have\n * to be escaped to ``<`` otherwise it would be interpreted as the beginning of\n * a tag. This function does this kind of escaping.\n *\n * @param text The text to convert.\n *\n * @returns The converted text.\n */\nexport function textToHTML(text: string): string {\n  if (textToHTMLSpan == null) {\n    textToHTMLSpan = document.createElement(\"span\");\n  }\n  textToHTMLSpan.textContent = text;\n  return textToHTMLSpan.innerHTML;\n}\n\nconst separators = \",>+~ \";\nconst separatorRe = new RegExp(`([${separators}]+)`);\n\n/**\n * Converts a CSS selector written as if it were run against the XML document\n * being edited by wed into a selector that will match the corresponding items\n * in the GUI tree. This implementation is extremely naive and likely to break\n * on complex selectors. Some specific things it cannot do:\n *\n * - Match attributes.\n *\n * - Match pseudo-elements.\n *\n * @param selector The selector to convert.\n *\n * @param namespaces The namespaces that are known. This is used to convert\n * element name prefixes to namespace URIs.\n *\n * @returns The converted selector.\n */\nexport function toGUISelector(selector: string,\n                              namespaces: Record<string, string>): string {\n  if (/[\\]['\"()]/.test(selector)) {\n    throw new Error(\"selector is too complex\");\n  }\n\n  if (/\\\\:/.test(selector)) {\n    throw new Error(\"we do not accept escaped colons for now\");\n  }\n\n  const parts = selector.split(separatorRe);\n  let ret: string[] = [];\n  for (let part of parts) {\n    if (part.length !== 0) {\n      if (separators.indexOf(part) > -1) {\n        ret.push(part);\n      }\n      else if (/[a-zA-Z]/.test(part[0])) {\n        part = part.trim();\n        const nameSplit = part.split(/(.#)/);\n        ret.push(util.classFromOriginalName(nameSplit[0], namespaces));\n        ret = ret.concat(nameSplit.slice(1));\n      }\n      else {\n        ret.push(part);\n      }\n    }\n  }\n  return ret.join(\"\");\n}\n\n/**\n * Allows applying simple CSS selectors on the data tree as if it were an HTML\n * tree. This is necessary because the current browsers are unable to handle tag\n * prefixes or namespaces in selectors passed to ``matches``, ``querySelector``\n * and related functions.\n *\n * The steps are:\n *\n * 1. Convert ``selector`` with [[toGUISelector]] into a selector that can be\n * applied to the GUI tree.\n *\n * 2. Convert ``node`` to a GUI node.\n *\n * 3. Apply the converted selector to the GUI node.\n *\n * 4. Convert the resulting node to a data node.\n *\n * @param node The element to use as the starting point of the query.\n *\n * @param selector The selector to use.\n *\n * @param namespaces The namespaces that are known. This is used to convert\n * element name prefixes to namespace URIs.\n *\n * @returns The resulting data node.\n */\nexport function dataFind(node: Element, selector: string,\n                         namespaces: Record<string, string>): Element | null {\n  const guiSelector = toGUISelector(selector, namespaces);\n  const guiNode = $.data(node, \"wed_mirror_node\") as Element;\n  const foundNodes = guiNode.querySelector(guiSelector);\n  if (foundNodes == null) {\n    return null;\n  }\n  const data = $.data(foundNodes, \"wed_mirror_node\");\n  return (data != null) ? data : null;\n}\n\n/**\n * Allows applying simple CSS selectors on the data tree as if it were an HTML\n * tree. Operates like [[dataFind]] but returns an array of nodes.\n *\n * @param node The data node to use as the starting point of the query.\n *\n * @param selector The selector to use.\n *\n * @param namespaces The namespaces that are known. This is used to convert\n * element name prefixes to namespace URIs.\n *\n * @returns The resulting data nodes.\n */\nexport function dataFindAll(node: Element, selector: string,\n                            namespaces: Record<string, string>): Element[] {\n  const guiSelector = toGUISelector(selector, namespaces);\n  const guiNode = $.data(node, \"wed_mirror_node\") as Element;\n  const foundNodes = guiNode.querySelectorAll(guiSelector);\n  const ret: Element[] = [];\n  for (let i = 0; i < foundNodes.length; ++i) {\n    ret.push($.data(foundNodes[i], \"wed_mirror_node\"));\n  }\n  return ret;\n}\n\n/**\n * Converts an HTML string to an array of DOM nodes. **This function is not\n * responsible for checking the HTML for security holes it is the responsibility\n * of the calling code to ensure the HTML passed is clean.**\n *\n * @param html The HTML to convert.\n *\n * @param document The document for which to create the nodes. If not specified,\n * the document will be the global ``document``.\n *\n * @returns The resulting nodes.\n */\nexport function htmlToElements(html: string, document?: Document): Node[] {\n  const doc = document != null ? document : window.document;\n  const frag = doc.createDocumentFragment();\n  const div = doc.createElement(\"div\");\n  frag.appendChild(div);\n  //\n  // Entire point of this function is to convert arbitrary HTML to DOM\n  // elements. It is the responsibility of the caller to make sure the HTML\n  // passed is clean.\n  //\n  // tslint:disable-next-line:no-inner-html\n  div.innerHTML = html;\n  const ret = Array.prototype.slice.call(div.childNodes);\n  // Clear the div so that the children cannot access the DOM objects we created\n  // only to convert the HTML to DOM elements.\n  while (div.firstChild !== null) {\n    div.removeChild(div.firstChild);\n  }\n  return ret;\n}\n\n/**\n * Gets the character immediately before the caret. The word \"immediately\" here\n * means that this function does not walk the DOM. If the caret is pointing into\n * an element node, it will check whether the node before the offset is a text\n * node and use it. That's the extent to which it walks the DOM.\n *\n * @param caret The caret position.\n *\n * @return The character, if it exists.\n */\nexport function getCharacterImmediatelyBefore(caret: Caret):\nstring | undefined {\n  const [node, offset] = caret;\n  switch (node.nodeType) {\n  case Node.TEXT_NODE:\n    const value = (node as Text).data;\n    return value[offset - 1];\n  case Node.ELEMENT_NODE:\n    const prev = node.childNodes[offset - 1];\n    if (isText(prev)) {\n      return prev.data[prev.data.length - 1];\n    }\n    break;\n  default:\n    throw new Error(`unexpected node type: ${node.nodeType}`);\n  }\n  return undefined;\n}\n\n/**\n * Gets the character immediately at the caret. The word \"immediately\" here\n * means that this function does not walk the DOM. If the caret is pointing into\n * an element node, it will check whether the node at the offset is a text\n * node and use it. That's the extent to which it walks the DOM.\n *\n * @param caret The caret position.\n *\n * @return The character, if it exists.\n */\nexport function getCharacterImmediatelyAt(caret: Caret): string | undefined {\n  const [node, offset] = caret;\n  switch (node.nodeType) {\n  case Node.TEXT_NODE:\n    const value = (node as Text).data;\n    return value[offset];\n  case Node.ELEMENT_NODE:\n    const next = node.childNodes[offset];\n    if (isText(next)) {\n      return next.data[0];\n    }\n    break;\n  default:\n    throw new Error(`unexpected node type: ${node.nodeType}`);\n  }\n  return undefined;\n}\n\n/**\n * Determine whether an element is displayed. This function is designed to\n * handle checks in wed's GUI tree, and not as a general purpose solution. It\n * only checks whether the element or its parents have ``display`` set to\n * ``\"none\"``.\n *\n * @param el The DOM element for which we want to check whether it is displayed\n * or not.\n *\n * @param root The parent of ``el`` beyond which we do not search.\n *\n * @returns ``true`` if the element or any of its parents is not\n * displayed. ``false`` otherwise. If the search up the DOM tree hits ``root``,\n * then the value returned is ``false``.\n */\nexport function isNotDisplayed(el: HTMLElement,\n                               root: HTMLElement | HTMLDocument): boolean {\n  const win = el.ownerDocument.defaultView;\n\n  // We don't put a menu for attributes that are somehow not\n  // displayed.\n  while (el != null && el !== root) {\n    if (el.style.display === \"none\") {\n      return true;\n    }\n\n    const display = win.getComputedStyle(el).getPropertyValue(\"display\");\n\n    if (display === \"none\") {\n      return true;\n    }\n\n    el = el.parentNode as HTMLElement;\n  }\n\n  return false;\n}\n\n/**\n * A ``contains`` function that handles attributes. Attributes are not part of\n * the node tree and performing a ``contains`` test on them is always ``false``.\n *\n * Yet it makes sense to say that an element A contains its own attributes and\n * thus by transitivity if element A is contained by element B, then all\n * attributes of A are contained by B. This function supports the contention\n * just described.\n *\n * Usage note: this function is typically not *needed* when doing tests in the\n * GUI tree because we do not address attributes in that tree. There is,\n * however, no harm in using it where it is not strictly needed. In the data\n * tree, however, we do address attributes. Code that works with either tree\n * (e.g. the [[\"dloc\"]] module) should use this function as a general rule so\n * that it can work with either tree.\n *\n * @param container The thing which should contain in the test.\n *\n * @param contained The thing which should be contained in the test.\n *\n * @returns Whether ``container`` contains ``contained``.\n */\nexport function contains(container: Node, contained: Node): boolean {\n  if (isAttr(contained)) {\n    contained = contained.ownerElement;\n  }\n\n  return container.contains(contained);\n}\n\n// Re-export, for historical reasons.\nexport { isAttr };\n\n//  LocalWords:  wed's URIs rect clientTop jquery util whitespace clientLeft cd\n//  LocalWords:  contenteditable abcd abfoocd insertIntoText Prepend scrollbars\n//  LocalWords:  deleteText jQuery getSelectionRange prev lastChild nodeType zA\n//  LocalWords:  dom deleteNode mergeTextNodes jshint insertNodeAt noop treeA\n//  LocalWords:  validthis insertFragAt versa nextSibling Dubeau MPL nodeInA\n//  LocalWords:  Mangalam gui DOM unlinks startContainer startOffset childNodes\n//  LocalWords:  endContainer endOffset genericInsertIntoText\n"]}