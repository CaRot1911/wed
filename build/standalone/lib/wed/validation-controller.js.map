{"version":3,"file":"validation-controller.js","sourceRoot":"","sources":["../../../../lib/wed/validation-controller.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Controller managing the validation logic of a wed editor.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { AttributeNameError, NameResolver, ValidationError } from \"salve\";\nimport { ErrorData, ResetData, WorkingState,\n         WorkingStateData } from \"salve-dom\";\n\nimport { DLoc } from \"./dloc\";\nimport { isAttr, isElement } from \"./domtypeguards\";\nimport { isNotDisplayed } from \"./domutil\";\nimport { Editor } from \"./editor\";\nimport { GUIValidationError } from \"./gui-validation-error\";\nimport { ErrorLayer } from \"./gui/error-layer\";\nimport { Scroller } from \"./gui/scroller\";\nimport { AttributeNotFound } from \"./guiroot\";\nimport { TaskRunner } from \"./task-runner\";\nimport { ProcessValidationErrors } from \"./tasks/process-validation-errors\";\nimport { RefreshValidationErrors } from \"./tasks/refresh-validation-errors\";\nimport { convertPatternObj, newGenericID } from \"./util\";\nimport { Validator } from \"./validator\";\nimport { boundaryXY, getGUINodeIfExists } from \"./wed-util\";\n\nconst stateToStr: Record<string, string> = {};\nstateToStr[WorkingState.INCOMPLETE] = \"stopped\";\nstateToStr[WorkingState.WORKING] = \"working\";\nstateToStr[WorkingState.INVALID] = \"invalid\";\nstateToStr[WorkingState.VALID] = \"valid\";\n\nconst stateToProgressType: Record<string, string> = {};\nstateToProgressType[WorkingState.INCOMPLETE] = \"info\";\nstateToProgressType[WorkingState.WORKING] = \"info\";\nstateToProgressType[WorkingState.INVALID] = \"danger\";\nstateToProgressType[WorkingState.VALID] = \"success\";\n\n// This is a utility function for the method of the same name. If the mode is\n// set to not display attributes or if a custom decorator is set to not display\n// a specific attribute, then finding the GUI location of the attribute won't be\n// possible. In such case, we want to fail nicely rather than crash to the\n// ground.\n//\n// (NOTE: What we're talking about is not the label visibility level being such\n// that attributes are not *seen* but have DOM elements for them in the GUI\n// tree. We're talking about a situation in which the mode's decorator does not\n// create DOM elements for the attributes.)\n//\nfunction findInsertionPoint(editor: Editor, node: Node,\n                            index: number): DLoc | undefined {\n  const caretManager = editor.caretManager;\n  try {\n    return caretManager.fromDataLocation(node, index);\n  }\n  catch (ex) {\n    if (ex instanceof AttributeNotFound) {\n      // This happens only if node points to an attribute.\n      return caretManager.fromDataLocation((node as Attr).ownerElement!, 0);\n    }\n\n    throw ex;\n  }\n}\n\n/**\n * Add a list of elements to a ``DocumentFragment``.\n *\n * @param doc The document from which to create the fragment.\n *\n * @param items The elements to add to the new fragment.\n *\n * @returns A new fragment that contains the elements passed.\n */\nfunction elementsToFrag(doc: Document,\n                        items: HTMLElement[]): DocumentFragment {\n  const frag = doc.createDocumentFragment();\n  for (const item of items) {\n    frag.appendChild(item);\n  }\n  return frag;\n}\n\n/**\n * Convert the names in an error message from their expanded form to their\n * prefix, local name form.\n *\n * @param error The error.\n *\n * @param resolve The resolver to use to convert the names.\n *\n * @returns The converted names.\n */\nfunction convertNames(error: ValidationError,\n                      resolver: NameResolver): string[] {\n  // Turn the names into qualified names.\n  const convertedNames = [];\n  const patterns = error.getNames();\n  for (const pattern of patterns) {\n    const names = pattern.toArray();\n    let convertedName = \"\";\n    if (names !== null) {\n      // Simple pattern, just translate all names one by one.\n      const conv = [];\n      for (const name of names) {\n        conv.push(resolver.unresolveName(name.ns, name.name));\n      }\n      convertedName = conv.join(\" or \");\n    }\n    else {\n      // We convert the complex pattern into something reasonable.\n      convertedName = convertPatternObj(pattern.toObject(), resolver);\n    }\n    convertedNames.push(convertedName);\n  }\n\n  return convertedNames;\n}\n\n/**\n * The click event handler to use on list items created by the controller.\n */\nexport type ErrorItemHandler = (ev: JQueryMouseEventObject) => boolean;\n\n/**\n * Controls the validator and the tasks that pertain to error processing and\n * refreshing. Takes care of reporting errors to the user.\n */\nexport class ValidationController {\n  public readonly document: Document;\n\n  private readonly refreshErrorsRunner: TaskRunner;\n  private readonly processErrorsRunner: TaskRunner;\n\n  private lastDoneShown: number = 0;\n  private processErrorsTimeout: number | undefined;\n\n  /**\n   * This holds the timeout set to process validation errors in batch.  The\n   * delay in ms before we consider a batch ready to process.\n   */\n  private processErrorsDelay: number = 500;\n  private _errors: GUIValidationError[] = [];\n\n  private readonly $errorList: JQuery;\n\n  /**\n   * @param editor The editor for which this controller is created.\n   *\n   * @param validator The validator which is under control.\n   *\n   * @param resolver A name resolver to resolve names in errors.\n   *\n   * @param scroller The scroller for the edited contents.\n   *\n   * @param guiRoot The DOM element representing the root of the edited\n   * document.\n   *\n   * @param progressBar: The DOM element which contains the validation progress\n   * bar.\n   *\n   * @param validationMessage: The DOM element which serves to report the\n   * validation status.\n   *\n   * @param errorLayer: The layer that holds error markers.\n   *\n   * @param errorList: The DOM element which serves to contain the error list.\n   *\n   * @param errorItemHandler: An event handler for the markers.\n   */\n  constructor(private readonly editor: Editor,\n              private readonly validator: Validator,\n              private readonly resolver: NameResolver,\n              private readonly scroller: Scroller,\n              private readonly guiRoot: Element,\n              private readonly progressBar: HTMLElement,\n              private readonly validationMessage: HTMLElement,\n              private readonly errorLayer: ErrorLayer,\n              private readonly errorList: HTMLElement,\n              private readonly errorItemHandler: ErrorItemHandler) {\n    this.document = guiRoot.ownerDocument;\n    this.$errorList = $(errorList);\n    this.refreshErrorsRunner =\n      new TaskRunner(new RefreshValidationErrors(this));\n    this.processErrorsRunner =\n      new TaskRunner(new ProcessValidationErrors(this));\n    this.validator.events.addEventListener(\n      \"state-update\", this.onValidatorStateChange.bind(this));\n    this.validator.events.addEventListener(\n      \"error\", this.onValidatorError.bind(this));\n    this.validator.events.addEventListener(\n      \"reset-errors\", this.onResetErrors.bind(this));\n  }\n\n  /**\n   * @returns a shallow copy of the error list.\n   */\n  copyErrorList(): GUIValidationError[] {\n    return this._errors.slice();\n  }\n\n  /**\n   * Stops all tasks and the validator.\n   */\n  stop(): void {\n    this.refreshErrorsRunner.stop();\n    this.processErrorsRunner.stop();\n    this.validator.stop();\n  }\n\n  /**\n   * Resumes all tasks and the validator.\n   */\n  resume(): void {\n    this.refreshErrorsRunner.resume();\n    this.processErrorsRunner.resume();\n    this.validator.start(); // Yes, start is the right method.\n  }\n\n  /**\n   * Handles changes in the validator state. Updates the progress bar and the\n   * validation status.\n   */\n  private onValidatorStateChange(workingState: WorkingStateData): void {\n    const { state, partDone } = workingState;\n    if (state === WorkingState.WORKING) {\n      // Do not show changes less than 5%\n      if (partDone - this.lastDoneShown < 0.05) {\n        return;\n      }\n    }\n    else if (state === WorkingState.VALID || state === WorkingState.INVALID) {\n      // We're done so we might as well process the errors right now.\n      this.processErrors();\n    }\n\n    this.lastDoneShown = partDone;\n    const percent = partDone * 100;\n    const progress = this.progressBar;\n    progress.style.width = `${percent}%`;\n    progress.classList.remove(\"progress-bar-info\", \"progress-bar-success\",\n                              \"progress-bar-danger\");\n    progress.classList.add(`progress-bar-${stateToProgressType[state]}`);\n    this.validationMessage.textContent = stateToStr[state];\n  }\n\n  /**\n   * Handles a validation error reported by the validator. It records the error\n   * and schedule future processing of the errors.\n   */\n  private onValidatorError(ev: ErrorData): void {\n    this._errors.push({\n      ev,\n      marker: undefined,\n      item: undefined,\n    });\n    // We \"batch\" validation errors to process multiple of them in one shot\n    // rather than call _processErrors each time.\n    if (this.processErrorsTimeout === undefined) {\n      this.processErrorsTimeout = setTimeout(this.processErrors.bind(this),\n                                             this.processErrorsDelay);\n    }\n  }\n\n  /**\n   * Handles resets of the validation state.\n   */\n  private onResetErrors(ev: ResetData): void {\n    if (ev.at !== 0) {\n      throw new Error(\"internal error: wed does not yet support \" +\n                      \"resetting errors at an arbitrary location\");\n    }\n\n    this.lastDoneShown = 0;\n    this.clearErrors();\n  }\n\n  /**\n   * Resets the state of the error processing task and resumes it\n   * as soon as possible.\n   */\n  processErrors(): void {\n    // Clear the timeout... because this function may be called from somewhere\n    // else than the timeout.\n    if (this.processErrorsTimeout !== undefined) {\n      clearTimeout(this.processErrorsTimeout);\n      this.processErrorsTimeout = undefined;\n    }\n\n    this.processErrorsRunner.reset();\n    this.editor.resumeTaskWhenPossible(this.processErrorsRunner);\n  }\n\n  /**\n   * Find where the error represented by the event passed should be marked.\n   *\n   * @param ev The error reported by the validator.\n   *\n   * @returns A location, if possible.\n   */\n  private findInsertionPoint(ev: ErrorData): DLoc | undefined {\n    const { error, node: dataNode, index } = ev;\n\n    if (dataNode == null) {\n      throw new Error(\"error without a node\");\n    }\n\n    if (index === undefined) {\n      throw new Error(\"error without an index\");\n    }\n\n    const isAttributeNameError = error instanceof AttributeNameError;\n\n    let insertAt: DLoc | undefined;\n    if (isAttributeNameError) {\n      const guiNode = getGUINodeIfExists(this.editor, dataNode);\n      if (guiNode === undefined) {\n        return undefined;\n      }\n\n      // Attribute name errors can have two causes: the attribute is not\n      // allowed, or an attribute is missing. In the former case, the error\n      // points to the attribute node. In the latter case, it points to the\n      // element that's missing the attribute.\n      let insertionNode: Node | null;\n      if (isAttr(dataNode)) {\n        // Spurious attribute.\n        insertionNode = guiNode;\n      }\n      else {\n        // Missing attribute.\n        if (!isElement(guiNode)) {\n          throw new Error(\"attribute name errors should be associated with \" +\n                          \"elements\");\n        }\n\n        insertionNode =\n          guiNode.querySelector(\"._gui.__start_label ._greater_than\");\n      }\n\n      insertAt = DLoc.mustMakeDLoc(this.guiRoot, insertionNode, 0);\n    }\n    else {\n      insertAt = findInsertionPoint(this.editor, dataNode, index);\n\n      if (insertAt === undefined) {\n        return undefined;\n      }\n\n      insertAt = this.editor.caretManager.normalizeToEditableRange(insertAt);\n    }\n\n    return insertAt;\n  }\n\n  /**\n   * Process a single error. This will compute the location of the error marker\n   * and will create a marker to add to the error layer, and a list item to add\n   * to the list of errors.\n   *\n   * @return ``false`` if there was no insertion point for the error, and thus\n   * no marker or item were created. ``true`` otherwise.\n   */\n  // tslint:disable-next-line:max-func-body-length\n  processError(err: GUIValidationError): boolean {\n    this.editor.expandErrorPanelWhenNoNavigation();\n    const { ev } = err;\n    const { error, node: dataNode } = ev;\n\n    if (dataNode == null) {\n      throw new Error(\"error without a node\");\n    }\n\n    const insertAt = this.findInsertionPoint(ev);\n    if (insertAt === undefined) {\n      return false;\n    }\n\n    let closestElement = insertAt.node as HTMLElement;\n    if (closestElement.nodeType === Node.TEXT_NODE) {\n      closestElement = closestElement.parentNode as HTMLElement;\n    }\n\n    if (!isElement(closestElement)) {\n      throw new Error(\"we should be landing on an element\");\n    }\n\n    let item;\n    let marker = err.marker;\n\n    // We may be getting here with an error that already has a marker. It has\n    // already been \"processed\" and only needs its location updated. Otherwise,\n    // this is a new error: create a list item and marker for it.\n    if (marker === undefined) {\n      // Turn the names into qualified names.\n      const convertedNames = convertNames(error, this.resolver);\n      const doc = insertAt.node.ownerDocument;\n      item = doc.createElement(\"li\");\n      const linkId = item.id = newGenericID();\n      if (isAttr(dataNode) &&\n          isNotDisplayed(closestElement,\n                         insertAt.root as (HTMLElement | HTMLDocument))) {\n        item.textContent = error.toStringWithNames(convertedNames);\n        item.title = \"This error belongs to an attribute \" +\n          \"which is not currently displayed.\";\n      }\n      else {\n        marker = doc.createElement(\"span\");\n        marker.className = \"_phantom wed-validation-error\";\n        const $marker = $(marker);\n\n        $marker.mousedown(() => {\n          this.$errorList.parents(\".panel-collapse\").collapse(\"show\");\n          const $link = $(this.errorList.querySelector(`#${linkId}`));\n          const $scrollable = this.$errorList.parent(\".panel-body\");\n          $scrollable.animate({\n            scrollTop: $link.offset()!.top - $scrollable.offset()!.top +\n              $scrollable[0].scrollTop,\n          });\n          this.errorLayer.select(marker!);\n          $link.siblings().removeClass(\"selected\");\n          $link.addClass(\"selected\");\n\n          // We move the caret ourselves and prevent further processing of this\n          // event. Older versions of wed let the event trickle up and be\n          // handled by the general caret movement code but that would sometimes\n          // result in a caret being put in a bad position.\n          this.editor.caretManager.setCaret(insertAt);\n          return false;\n        });\n\n        const markerId = marker.id = newGenericID();\n        const link = doc.createElement(\"a\");\n        link.href = `#${markerId}`;\n        link.textContent = error.toStringWithNames(convertedNames);\n        item.appendChild(link);\n\n        $(item.firstElementChild).click(err, this.errorItemHandler);\n      }\n    }\n\n    // Update the marker's location.\n    if (marker !== undefined) {\n      const { top, left } = boundaryXY(insertAt);\n      const { scrollTop, scrollLeft } = this.scroller;\n      const scrollerPos = this.scroller.getBoundingClientRect();\n      const fontSize =\n        parseFloat(this.editor.window.getComputedStyle(closestElement)\n                   .fontSize!);\n      const height = fontSize * 0.2;\n      marker.style.height = `${height}px`;\n      // We move down from the top of the box produced by boundaryXY because\n      // when targeting parent, it may return a box which is as high as the\n      // parent's contents.\n      marker.style.top =\n        `${top + fontSize - height - scrollerPos.top + scrollTop}px`;\n      marker.style.left = `${left - scrollerPos.left + scrollLeft}px`;\n    }\n\n    if (err.item === undefined) {\n      err.item = item;\n    }\n    err.marker = marker;\n\n    return true;\n  }\n\n  /**\n   * Clear all validation errors. This makes the editor forget and updates the\n   * GUI to remove all displayed errors.\n   */\n  private clearErrors(): void {\n    this._errors = [];\n    this.refreshErrorsRunner.stop();\n    this.processErrorsRunner.stop();\n\n    this.errorLayer.clear();\n\n    const list = this.errorList;\n    while (list.lastChild != null) {\n      list.removeChild(list.lastChild);\n    }\n\n    this.refreshErrorsRunner.reset();\n    this.processErrorsRunner.reset();\n  }\n\n  /**\n   * Terminate the controller. This stops all runners and clears any unexpired\n   * timeout.\n   */\n  terminate(): void {\n    if (this.processErrorsTimeout !== undefined) {\n      clearTimeout(this.processErrorsTimeout);\n    }\n    this.stop();\n  }\n\n  /**\n   * This method updates the location markers of the errors.\n   */\n  refreshErrors(): void {\n    this.refreshErrorsRunner.reset();\n    this.editor.resumeTaskWhenPossible(this.refreshErrorsRunner);\n  }\n\n  /**\n   * This method recreates the error messages and the error markers associated\n   * with the errors that the editor already knows.\n   */\n  recreateErrors(): void {\n    this.errorLayer.clear();\n\n    const list = this.errorList;\n    while (list.lastChild !== null) {\n      list.removeChild(list.lastChild);\n    }\n\n    for (const error of this._errors) {\n      error.marker = undefined;\n      error.item = undefined;\n    }\n\n    this.processErrors();\n  }\n\n  /**\n   * Add items to the list of errors.\n   *\n   * @param items The items to add to the list of errors.\n   */\n  appendItems(items: HTMLElement[]): void {\n    this.errorList.appendChild(elementsToFrag(this.document, items));\n  }\n\n  /**\n   * Add markers to the layer that is used to contain error markers.\n   *\n   * @param markers The markers to add.\n   */\n  appendMarkers(markers: HTMLElement[]): void {\n    this.errorLayer.append(elementsToFrag(this.document, markers));\n  }\n}\n\n//  LocalWords:  MPL scroller processErrors li markerId loc scrollerPos px\n//  LocalWords:  scrollTop scrollLeft\n"]}