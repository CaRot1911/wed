{"version":3,"file":"wed-util.js","sourceRoot":"","sources":["../../../../lib/wed/wed-util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\n//\n// We already have domutil and util so why this module? It combines those\n// functions that are really part of wed but are not meant to be used outside\n// the Editor class itself. domutil is meant to encompass those functions that\n// could be used in other contexts and are about the DOM. util is meant to\n// encompass those functions that do not depend on having a browser available.\n//\n\nimport { DLoc } from \"./dloc\";\nimport { isElement, isText } from \"./domtypeguards\";\nimport { Editor } from \"./editor\";\nimport { AttributeNotFound } from \"./guiroot\";\n\nexport interface BoundaryCoordinates {\n  left: number;\n  top: number;\n  bottom: number;\n}\n\n// Utility function for boundaryXY.\nfunction parentBoundary(node: Node,\n                        root: Document | Element): BoundaryCoordinates {\n  const parent = node.parentNode!;\n\n  // Cannot find a sensible boundary\n  if (!root.contains(parent)) {\n    return { left: 0, top: 0, bottom: 0 };\n  }\n\n  return boundaryXY(DLoc.mustMakeDLoc(root, node));\n}\n\n// tslint:disable-next-line:max-func-body-length\nexport function boundaryXY(boundary: DLoc): BoundaryCoordinates {\n  const node = boundary.node;\n  let offset = boundary.offset;\n\n  const nodeIsElement = isElement(node);\n  const nodeIsText = isText(node);\n  let nodeLen;\n  if (nodeIsElement) {\n    nodeLen = node.childNodes.length;\n  }\n  else if (nodeIsText) {\n    nodeLen = (node as Text).length;\n  }\n  else {\n    throw new Error(`unexpected node type: ${node.nodeType}`);\n  }\n\n  // The node is empty ...\n  if (nodeLen === 0) {\n    return parentBoundary(node, boundary.root);\n  }\n\n  const range = node.ownerDocument.createRange();\n  let rect;\n\n  let child;\n  while (offset < nodeLen) {\n    // The array is empty if the node is a text node, and child will be\n    // undefined.\n    child = node.childNodes[offset];\n\n    // We use getClientRects()[0] so that when we are working with an inline\n    // node, we get only the first rect of the node. If the node is a block,\n    // then there should be only one rect anyway.\n    if (isElement(child)) {\n      rect = child.getClientRects()[0];\n    }\n    else {\n      range.setStart(node, offset);\n      range.setEnd(node, offset + 1);\n\n      rect = range.getClientRects()[0];\n    }\n\n    // If the element that covers the range is invisible, then getClientRects\n    // can return undefined. A 0, 0, 0, 0 rect is also theoretically possible.\n    if (rect != null &&\n        (rect.left !== 0 || rect.right !== 0 || rect.top !== 0 ||\n         rect.bottom !== 0)) {\n      return { left: rect.left, top: rect.top, bottom: rect.bottom };\n    }\n\n    offset++;\n  }\n\n  // We failed to find something after our offset from which to get\n  // coordinates. Try again.\n  offset = boundary.offset;\n\n  const win = node.ownerDocument.defaultView;\n  while (offset !== 0) {\n    offset--;\n    child = undefined;\n\n    // We check whether the thing we are going to cover with the range is\n    // inline.\n    let inline;\n    if (nodeIsText) {\n      inline = true;\n    }\n    else if (nodeIsElement) {\n      child = node.childNodes[offset];\n      if (isText(child)) {\n        inline = true;\n      }\n      else if (isElement(child)) {\n        const display = win.getComputedStyle(child).getPropertyValue(\"display\");\n        inline = (display === \"inline\" || display === \"inline-block\");\n      }\n      else {\n        throw new Error(`unexpected node type: ${child.nodeType}`);\n      }\n    }\n    else {\n      throw new Error(`unexpected node type: ${node.nodeType}`);\n    }\n\n    // If it is not empty, and offset is at the end of the contents, then there\n    // must be something *before* the point indicated by offset. Get a rectangle\n    // around that and return the right side as the left value.\n    let rects;\n    if (isElement(child)) {\n      rects = child.getClientRects();\n    }\n    else {\n      range.setStart(node, offset);\n      range.setEnd(node, offset + 1);\n      rects = range.getClientRects();\n    }\n    rect = rects[rects.length - 1];\n    if (rect != null) {\n      return (inline ?\n              // Yep, we use the right side when it is inline.\n              { left: rect.right, top: rect.top, bottom: rect.bottom } :\n              { left: rect.left, top: rect.top, bottom: rect.bottom });\n    }\n  }\n\n  // We can get here with an offset of 0. In this case, we have to move to the\n  // parent.\n  return parentBoundary(node, boundary.root);\n}\n\nexport function getAttrValueNode(attrVal: Element): Node {\n  if (!attrVal.classList.contains(\"_attribute_value\")) {\n    throw new Error(\"getAttrValueNode operates only on attribute values\");\n  }\n\n  let ret: Node = attrVal;\n\n  let child = attrVal.firstChild;\n  if (child !== null) {\n    while (child !== null && !isText(child)) {\n      child = child.nextSibling;\n    }\n\n    if (child !== null) {\n      ret = child;\n    }\n  }\n\n  return ret;\n}\n\nexport function getGUINodeIfExists(editor: Editor,\n                                   node: Node | null | undefined):\nNode | undefined {\n  if (node == null) {\n    return undefined;\n  }\n\n  try {\n    const caret = editor.caretManager.fromDataLocation(node, 0);\n    return caret != null ? caret.node : undefined;\n  }\n  catch (ex) {\n    if (ex instanceof AttributeNotFound) {\n      return undefined;\n    }\n\n    throw ex;\n  }\n}\n\n//  LocalWords:  MPL domutil util boundaryXY nodeType getClientRects rect\n//  LocalWords:  getAttrValueNode\n"]}