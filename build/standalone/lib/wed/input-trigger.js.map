{"version":3,"file":"input-trigger.js","sourceRoot":"","sources":["../../../../lib/wed/input-trigger.ts"],"names":[],"mappings":";;;;;;;IA4BA;;;;;;;;;;;;;;;;OAgBG;IACH;QAKE;;;;;;;;WAQG;QACH,sBAA6B,MAAiB,EACjB,IAAU,EACV,QAAqB;YAChD,4EAA4E;YAC5E,wEAAwE;YACxE,kEAAkE;YAClE,4EAA4E;YAC5E,yEAAyE;YACzE,2EAA2E;YAC3E,0DAA0D;YAT/B,WAAM,GAAN,MAAM,CAAW;YACjB,SAAI,GAAJ,IAAI,CAAM;YACV,aAAQ,GAAR,QAAQ,CAAa;YAflD,+CAA+C;YAC9B,iBAAY,GAA2B,IAAI,GAAG,EAAE,CAAC;YACjD,0BAAqB,GAA2B,IAAI,GAAG,EAAE,CAAC;YAsBzE,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAEnE,0EAA0E;YAC1E,yEAAyE;YACzE,qEAAqE;YACrE,2EAA2E;YAC3E,2EAA2E;YAC3E,yEAAyE;YACzE,2EAA2E;YAC3E,mEAAmE;YACnE,YAAY;YACZ,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,2BAA2B,EAC3B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACnD,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,4BAA4B,EAC5B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACtD,CAAC;QAED;;;;;;;;;;;;;;;;;;;;;;;;;;;WA2BG;QACH,oCAAa,GAAb,UAAc,GAAQ,EAAE,OAAmB;YACzC,IAAI,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC1C,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC1B,QAAQ,GAAG,EAAE,CAAC;gBACd,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;aACtC;YAED,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAEvB,wEAAwE;YACxE,cAAc;YACd,IAAI,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE;gBACtC,OAAO;aACR;YAED,oDAAoD;YACpD,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACxC,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;aAC/C;QACH,CAAC;QAEO,wCAAiB,GAAzB;YACE,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAE1D,IAAI,KAAK,IAAI,IAAI,EAAE;gBACjB,OAAO,IAAI,CAAC;aACb;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,EAAE;gBAC1D,4BAA4B;gBAC5B,OAAO,IAAI,CAAC;aACb;YAED,mEAAmE;YACnE,yEAAyE;YACzE,uCAAuC;YACvC,IAAM,QAAQ,GAAG,sBAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;YACzE,IAAM,OAAO,GAAG,gBAAC,CAAC,IAAI,CAAC,QAAmB,EAAE,iBAAiB,CAAC,CAAC;YAE/D,OAAO,iBAAO,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACpE,CAAC;QAED;;;;;;WAMG;QACK,qCAAc,GAAtB,UAAuB,SAAgB,EAAE,CAAuB;YAC9D,IAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAChD,IAAI,cAAc,KAAK,IAAI,EAAE;gBAC3B,OAAO;aACR;YAED,IAAM,QAAQ,GAAG,gBAAC,CAAC,IAAI,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;YAC3D,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,QAAsB,EAAE,GAAQ;gBACzD,IAAI,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;oBACvB,KAAsB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;wBAAzB,IAAM,OAAO,iBAAA;wBAChB,OAAO,CAAC,SAAS,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;qBACjC;iBACF;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAED;;;;;;WAMG;QACK,sCAAe,GAAvB,UAAwB,SAAgB,EAAE,CAAuB;YAC/D,IAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAChD,IAAI,cAAc,KAAK,IAAI,EAAE;gBAC3B,OAAO;aACR;YAED,IAAM,QAAQ,GAAG,gBAAC,CAAC,IAAI,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;YAC3D,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,QAAsB,EAAE,GAAQ;gBACzD,IAAI,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;oBACvB,KAAsB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;wBAAzB,IAAM,OAAO,iBAAA;wBAChB,OAAO,CAAC,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;qBAClC;iBACF;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAED;;;;;;;;;;WAUG;QACK,mCAAY,GAApB,UAAqB,SAAgB,EAAE,CAAuB,EAAE,KAAW,EACtD,IAAa;YAChC,IAAI,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAAE,EAAE;gBAClC,OAAO;aACR;YAED,IAAM,IAAI,GAAW,EAAE,CAAC;YACxB,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC5B,OAAO,KAAK,KAAK,IAAI,EAAE;gBACrB,IAAI,sBAAM,CAAC,KAAK,CAAC,EAAE;oBACjB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBAClB;gBACD,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;aAC3B;YAED,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACrB,OAAO;aACR;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,EAAE;gBAC1D,4BAA4B;gBAC5B,OAAO;aACR;YAED,mEAAmE;YACnE,yEAAyE;YACzE,uCAAuC;YACvC,IAAM,cAAc,GAAG,CAAC,sBAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACpB,KAAK,CAAC,IAAI,CAAC,UAAW,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAY,CAAC;YACxE,IAAM,OAAO,GAAG,gBAAC,CAAC,IAAI,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;YAE1D,IAAI,iBAAO,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;gBACvE,OAAO;aACR;YAED,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,UAAC,QAAsB,EAAE,GAAQ;gBAClE,gCAAgC;gBAChC,IAAI,GAAG,CAAC,WAAW,EAAE,EAAE;oBACrB,OAAO;iBACR;gBACD,IAAM,EAAE,GAAG,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAE1C,KAAmB,UAAI,EAAJ,aAAI,EAAJ,kBAAI,EAAJ,IAAI;oBAAlB,IAAM,IAAI,aAAA;oBACb,+CAA+C;oBAC/C,IAAI,IAAI,CAAC,UAAU,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;wBAC1D,KAAsB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;4BAAzB,IAAM,OAAO,iBAAA;4BAChB,OAAO,CAAC,OAAO,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;yBACrC;qBACF;iBACF;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QACH,mBAAC;IAAD,CAAC,AA7ND,IA6NC;IA7NY,oCAAY;;AA+NzB,+EAA+E;AAC/E,iDAAiD","sourcesContent":["/**\n * Module implementing the basic functionality for input triggers.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport $ from \"jquery\";\n\nimport { DLoc } from \"./dloc\";\nimport { isText } from \"./domtypeguards\";\nimport { closest } from \"./domutil\";\nimport { GUISelector } from \"./gui-selector\";\nimport { Key } from \"./key\";\nimport { Mode } from \"./mode\";\nimport { EditorAPI } from \"./mode-api\";\n\n/**\n * @param eventType The type of event being processed.\n *\n * @param element A DOM element in the **data tree** that was modified or had\n * the caret when the keydown event happened.\n *\n * @param event The jQuery event in question.\n */\nexport type KeyHandler = (eventType: \"keypress\" | \"keydown\" | \"paste\",\n                          el: Element,\n                          event: JQueryKeyEventObject) => void;\n\n/**\n * An InputTrigger listens to keyboard events and to DOM changes that insert\n * text into an element. The object has to listen to both types of events\n * because:\n *\n * - Listening only to keyboard events would miss modifications to the DOM tree\n *   that happen programmatically.\n *\n * - Listening only to DOM changes would not trap keyboard events that do not\n *   **inherently** modify the DOM tree like a backspace key hit at the start of\n *   an element.\n *\n * The portion of InputTrigger objects that handle keyboard events attaches\n * itself to the editor to which the InputTrigger belongs in such a way that\n * allows for suppressing the generic handling of such events. See\n * [[addKeyHandler]] for more information.\n */\nexport class InputTrigger {\n  // This is a map of all keys to their handlers.\n  private readonly keyToHandler: Map<Key, KeyHandler[]> = new Map();\n  private readonly textInputKeyToHandler: Map<Key, KeyHandler[]> = new Map();\n\n  /**\n   * @param editor The editor to which this ``InputTrigger`` belongs.\n   *\n   * @param mode The mode for which this ``InputTrigger`` is being created.\n   *\n   * @param selector This is a CSS selector which must be fit to be used in the\n   * GUI tree. (For instance by being the output of\n   * [[\"wed/domutil\".toGUISelector]].)\n   */\n  constructor(private readonly editor: EditorAPI,\n              private readonly mode: Mode,\n              private readonly selector: GUISelector) {\n    // This is a map of keys that are actually text keys to their handlers. This\n    // map is in effect a submap of _key_to_handler. We want this for speed,\n    // because otherwise each text change event would require that the\n    // InputTrigger filter out all those keys that we don't care about. The keys\n    // that are \"text input\" keys are those that actually modify DOM text. So\n    // things like cursor movement keys or ENTER, BACKSPACE, or control keys do\n    // not appear *in* text and so are excluded from this map.\n\n    editor.$guiRoot.on(\"wed-post-paste\", this.pasteHandler.bind(this));\n\n    // Implementation note: getting keydown events to get fired on random HTML\n    // elements is finicky. For one thing, the element needs to be focusable,\n    // which is false for most elements unless tabindex is set. Even with\n    // tabindex set, browsers don't seem to consistently emit the events on the\n    // elements we want. An initial implementation attempted to set the keydown\n    // handler with $root.on(\"keydown\", this._selector, ...) but this was not\n    // reliable. So we listen to all keydown events on $root and in the handler\n    // we filter out what we don't care about. More expensive but works\n    // reliably.\n    editor.$guiRoot.on(\"wed-input-trigger-keydown\",\n                       this.keydownHandler.bind(this));\n    editor.$guiRoot.on(\"wed-input-trigger-keypress\",\n                       this.keypressHandler.bind(this));\n  }\n\n  /**\n   * Adds a key handler to the object.\n   *\n   * The handler is called once per event. This means for instance that if a\n   * paste event introduces the text \"a;b;c\" and we are listening for \";\", the\n   * handler will be called once, even though two \";\" are added. It is up to the\n   * handler to detect that \";\" has been added more than once.\n   *\n   * Handlers that wish to stop further processing or prevent the browser's\n   * default processing of an event must call the appropriate method on the\n   * ``event`` object.\n   *\n   * Although it is possible to add multiple handlers for the same key to the\n   * same ``InputTrigger`` object, the ``InputTrigger`` class does not define\n   * how one handler could prevent another handler from executing. Calling the\n   * methods on the ``event`` object does not in any way affect how an\n   * ``InputTrigger`` calls its handlers. However, as stated above, these\n   * methods can prevent further propagation of the JavaScript\n   * event. Consequently, if more than one handler should handle the same key on\n   * the same ``InputTrigger`` object, these handlers should either deal with\n   * orthogonal concerns (e.g. one modifies the data DOM tree and the other does\n   * logging), or provide their own mechanism to determine whether one can\n   * prevent the other from executing.\n   *\n   * @param key The key we are interested in.\n   *\n   * @param handler The handler that will process events related to that key.\n   */\n  addKeyHandler(key: Key, handler: KeyHandler): void {\n    let handlers = this.keyToHandler.get(key);\n    if (handlers === undefined) {\n      handlers = [];\n      this.keyToHandler.set(key, handlers);\n    }\n\n    handlers.push(handler);\n\n    // We could get here due to keys that are actually not text (e.g. ENTER,\n    // BACKSPACE).\n    if (key.anyModifier() || !key.keypress) {\n      return;\n    }\n\n    // We share the handlers array between the two maps.\n    if (!this.textInputKeyToHandler.has(key)) {\n      this.textInputKeyToHandler.set(key, handlers);\n    }\n  }\n\n  private getNodeOfInterest(): Element | null{\n    const caret = this.editor.caretManager.getDataCaret(true);\n\n    if (caret == null) {\n      return null;\n    }\n\n    if (this.editor.modeTree.getMode(caret.node) !== this.mode) {\n      // Outside our jurisdiction.\n      return null;\n    }\n\n    // We transit through the GUI tree to perform our match because CSS\n    // selectors cannot operate on XML namespace prefixes (or, at the time of\n    // writing, on XML namespaces, period).\n    const dataNode = isText(caret.node) ? caret.node.parentNode : caret.node;\n    const guiNode = $.data(dataNode as Element, \"wed_mirror_node\");\n\n    return closest(guiNode, this.selector.value, this.editor.guiRoot);\n  }\n\n  /**\n   * Handles ``keydown`` events.\n   *\n   * @param _wedEvent The DOM event wed generated to trigger this handler.\n   *\n   * @param e The original DOM event that wed received.\n   */\n  private keydownHandler(_wedEvent: Event, e: JQueryKeyEventObject): void {\n    const nodeOfInterest = this.getNodeOfInterest();\n    if (nodeOfInterest === null) {\n      return;\n    }\n\n    const dataNode = $.data(nodeOfInterest, \"wed_mirror_node\");\n    this.keyToHandler.forEach((handlers: KeyHandler[], key: Key) => {\n      if (key.matchesEvent(e)) {\n        for (const handler of handlers) {\n          handler(\"keydown\", dataNode, e);\n        }\n      }\n    });\n  }\n\n  /**\n   * Handles ``keypress`` events.\n   *\n   * @param _wedEvent The DOM event wed generated to trigger this handler.\n   *\n   * @param e The original DOM event that wed received.\n   */\n  private keypressHandler(_wedEvent: Event, e: JQueryKeyEventObject): void {\n    const nodeOfInterest = this.getNodeOfInterest();\n    if (nodeOfInterest === null) {\n      return;\n    }\n\n    const dataNode = $.data(nodeOfInterest, \"wed_mirror_node\");\n    this.keyToHandler.forEach((handlers: KeyHandler[], key: Key) => {\n      if (key.matchesEvent(e)) {\n        for (const handler of handlers) {\n          handler(\"keypress\", dataNode, e);\n        }\n      }\n    });\n  }\n\n  /**\n   * Handles ``paste`` events.\n   *\n   * @param _wedEvent The DOM event wed generated to trigger this handler.\n   *\n   * @param e The original DOM event that wed received.\n   *\n   * @param caret The data caret.\n   *\n   * @param data The data that the user wants to insert.\n   */\n  private pasteHandler(_wedEvent: Event, e: JQueryKeyEventObject, caret: DLoc,\n                       data: Element): void {\n    if (this.editor.undoingOrRedoing()) {\n      return;\n    }\n\n    const text: Text[] = [];\n    let child = data.firstChild;\n    while (child !== null) {\n      if (isText(child)) {\n        text.push(child);\n      }\n      child = child.nextSibling;\n    }\n\n    if (text.length === 0) {\n      return;\n    }\n\n    if (this.editor.modeTree.getMode(caret.node) !== this.mode) {\n      // Outside our jurisdiction.\n      return;\n    }\n\n    // We transit through the GUI tree to perform our match because CSS\n    // selectors cannot operate on XML namespace prefixes (or, at the time of\n    // writing, on XML namespaces, period).\n    const nodeOfInterest = (isText(caret.node) ?\n                            caret.node.parentNode! : caret.node) as Element;\n    const guiNode = $.data(nodeOfInterest, \"wed_mirror_node\");\n\n    if (closest(guiNode, this.selector.value, this.editor.guiRoot) === null) {\n      return;\n    }\n\n    this.textInputKeyToHandler.forEach((handlers: KeyHandler[], key: Key) => {\n      // We care only about text input\n      if (key.anyModifier()) {\n        return;\n      }\n      const ch = String.fromCharCode(key.which);\n\n      for (const node of text) {\n        // Skip those that are not in the tree anymore.\n        if (node.parentNode !== null && node.data.indexOf(ch) > -1) {\n          for (const handler of handlers) {\n            handler(\"paste\", nodeOfInterest, e);\n          }\n        }\n      }\n    });\n  }\n}\n\n//  LocalWords:  InputTrigger keydown tabindex keypress submap jQuery focusable\n//  LocalWords:  Dubeau MPL Mangalam gui html DOM\n"]}