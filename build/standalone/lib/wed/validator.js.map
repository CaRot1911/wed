{"version":3,"file":"validator.js","sourceRoot":"","sources":["../../../../lib/wed/validator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This module is responsible for validating the document being edited in wed.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { EventSet, Grammar } from \"salve\";\nimport { ErrorData, Validator as BaseValidator,\n         WorkingState } from \"salve-dom\";\n\nimport * as dloc from \"./dloc\";\nimport { isElement, isNode } from \"./domtypeguards\";\n\nexport const INCOMPLETE = WorkingState.INCOMPLETE;\nexport const WORKING = WorkingState.WORKING;\nexport const INVALID = WorkingState.INVALID;\nexport const VALID = WorkingState.VALID;\n\nexport interface ModeValidator {\n  validateDocument(): ErrorData[];\n}\n\n/**\n * A document validator.\n */\nexport class Validator extends BaseValidator {\n  /**\n   * @param schema A path to the schema to pass to salve for validation. This is\n   * a path that will be interpreted by RequireJS. The schema must have already\n   * been prepared for use by salve. See salve's documentation. Or this can be a\n   * ``Grammar`` object that has already been produced from ``salve``'s\n   * ``constructTree``.\n   *\n   * @param root The root of the DOM tree to validate. This root contains the\n   * document to validate but is not **part** of it.\n   *\n   * @param modeValidators The mode-specific validators to use.\n   */\n  constructor(schema: Grammar, root: Element | Document,\n              private readonly modeValidators: ModeValidator[]) {\n    super(schema, root, {\n      timeout: 0,\n      maxTimespan: 100,\n    });\n  }\n\n  /**\n   * Runs document-wide validation specific to the mode passed to\n   * the validator.\n   */\n  _runDocumentValidation(): void {\n    for (const validator of this.modeValidators) {\n      const errors = validator.validateDocument();\n      for (const error of errors) {\n        this._processError(error);\n      }\n    }\n  }\n\n  /**\n   * Returns the set of possible events for the location specified by the\n   * parameters.\n   *\n   * @param loc Location at which to get possibilities.\n   *\n   * @param container Together with ``index`` this parameter is interpreted to\n   * form a location as would be specified by ``loc``.\n   *\n   * @param index Together with ``container`` this parameter is interpreted to\n   * form a location as would be specified by ``loc``.\n   *\n   * @param attributes Whether we are interested in the attribute events of the\n   * node pointed to by ``container, index``. If ``true`` the node pointed to by\n   * ``container, index`` must be an element, and the returned set will contain\n   * attribute events.\n   *\n   * @returns A set of possible events.\n   */\n  possibleAt(loc: dloc.DLoc, attributes?: boolean): EventSet;\n  possibleAt(container: Node, index: number,\n             attributes?: boolean): EventSet;\n  possibleAt(container: Node | dloc.DLoc, index: number | boolean = false,\n             attributes: boolean = false): EventSet {\n    if (container instanceof dloc.DLoc) {\n      if (typeof index !== \"boolean\") {\n        throw new Error(\"2nd parameter must be boolean\");\n      }\n      attributes = index;\n      index = container.offset;\n      container = container.node;\n    }\n\n    if (typeof index !== \"number\") {\n      throw new Error(\"index must be a number\");\n    }\n    return super.possibleAt(container, index, attributes);\n  }\n\n  /**\n   * Validate a DOM fragment as if it were present at the point specified in the\n   * parameters in the DOM tree being validated.\n   *\n   * WARNING: This method will not catch unclosed elements. This is because the\n   * fragment is not considered to be a \"complete\" document. Unclosed elements\n   * or fragments that are not well-formed must be caught by other means.\n   *\n   * @param loc The location in the tree to start at.\n   *\n   * @param container The location in the tree to start at, if ``loc`` is not\n   * used.\n   *\n   * @param index The location in the tree to start at, if ``loc`` is not used.\n   *\n   * @param toParse The fragment to parse.\n   *\n   * @returns An array of errors if there is an error. Otherwise returns false.\n   */\n  speculativelyValidate(loc: dloc.DLoc,\n                        toParse: Node | Node[]): ErrorData[] | false;\n  speculativelyValidate(container: Node, index: number,\n                        toParse: Node | Node[]): ErrorData[] | false;\n  speculativelyValidate(container: Node | dloc.DLoc,\n                        index: number | Node | Node[],\n                        toParse?: Node | Node[]): ErrorData[] | false {\n    if (container instanceof dloc.DLoc) {\n      if (!(isNode(index) || index instanceof Array)) {\n        throw new Error(\"2nd argument must be a Node or an array of Nodes\");\n      }\n      toParse = index;\n      index = container.offset;\n      container = container.node;\n    }\n\n    if (typeof index !== \"number\") {\n      throw new Error(\"index must be a number\");\n    }\n\n    if (toParse === undefined) {\n      throw new Error(\"toParse must be defined\");\n    }\n\n    return super.speculativelyValidate(container, index, toParse);\n  }\n\n  /**\n   * Validate a DOM fragment as if it were present at the point specified in the\n   * parameters in the DOM tree being validated.\n   *\n   * WARNING: This method will not catch unclosed elements. This is because the\n   * fragment is not considered to be a \"complete\" document. Unclosed elements\n   * or fragments that are not well-formed must be caught by other means.\n   *\n   * @param loc The location in the tree to start at.\n   *\n   * @param container The location in the tree to start at.\n   *\n   * @param index The location in the tree to start at.\n   *\n   * @param toParse The fragment to parse. This fragment must not be part of the\n   * tree that the validator normally validates. (It can be **cloned** from that\n   * tree.) This fragment must contain a single top level element which has only\n   * one child. This child is the element that will actually be parsed.\n   *\n   * @returns An array of errors if there is an error. Otherwise returns false.\n   */\n  speculativelyValidateFragment(loc: dloc.DLoc,\n                                toParse: Element): ErrorData[] | false;\n  speculativelyValidateFragment(container: Node, index: number,\n                                toParse: Element): ErrorData[] | false;\n  speculativelyValidateFragment(container: Node | dloc.DLoc,\n                                index: number | Element,\n                                toParse?: Element): ErrorData[] | false {\n    if (container instanceof dloc.DLoc) {\n      if ((typeof index === \"number\") || !isElement(index)) {\n        // It appears as \"toParse\" to the caller, not \"index\".\n        throw new Error(\"toParse is not an element\");\n      }\n      toParse = index;\n      index = container.offset;\n      container = container.node;\n    }\n\n    if (typeof index !== \"number\") {\n      throw new Error(\"index must be a number\");\n    }\n\n    if (toParse === undefined) {\n      throw new Error(\"toParse must be defined\");\n    }\n\n    return super.speculativelyValidateFragment(container, index, toParse);\n  }\n}\n\n//  LocalWords:  boolean Dubeau Mangalam validator MPL RequireJS unclosed DOM\n//  LocalWords:  speculativelyValidate nd toParse\n"]}