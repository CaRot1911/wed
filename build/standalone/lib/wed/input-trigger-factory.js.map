{"version":3,"sources":["../../../wed/input-trigger-factory.ts"],"names":[],"mappings":"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","file":"input-trigger-factory.js","sourcesContent":["/**\n * Functions to create input triggers according to some common patterns.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { isText } from \"./domtypeguards\";\nimport * as domutil from \"./domutil\";\nimport { InputTrigger } from \"./input-trigger\";\nimport { Key } from \"./key\";\nimport * as transformation from \"./transformation\";\n\n// tslint:disable-next-line:no-any\nexport type Editor = any;\n\ninterface SplitData extends transformation.TransformationData {\n  // node is no longer optional.\n  node: Node;\n  sep: string;\n}\n\n/**\n * A transformation handler for a node splitting transformation.\n *\n * @param editor The editor which invoked the transformation.\n *\n * @param data The key that is splitting the element.\n *\n * @throws {Error} If the data passed is incorrect.\n */\nfunction splitNodeOn(editor: Editor, data: SplitData): void {\n  let node = data.node;\n  const sep = data.sep;\n  if (typeof sep !== \"string\" || sep.length !== 1) {\n    throw new Error(\"transformation invoked with incorrect data\");\n  }\n  let modified = true;\n  while (modified) {\n    modified = false;\n    const textNodes: Text[] = [];\n    let child = node.firstChild;\n    while (child !== null) {\n      if (isText(child)) {\n        textNodes.push(child);\n      }\n      child = child.nextSibling;\n    }\n\n    for (let i = 0; !modified && i < textNodes.length; ++i) {\n      const text = textNodes[i];\n      const offset = text.data.indexOf(sep);\n      if (node.firstChild === text && offset === 0) {\n        // We just drop the separator\n        editor.data_updater.deleteText(text, offset, 1);\n        modified = true;\n      }\n      else if (node.lastChild === text && offset !== -1 &&\n               offset === text.length - 1) {\n        // Just drop the separator\n        editor.data_updater.deleteText(text, text.length - 1, 1);\n        modified = true;\n      }\n      else if (offset !== -1) {\n        const pair = editor.data_updater.splitAt(node, text, offset);\n        // Continue with the 2nd half of the split\n        node = pair[1];\n        modified = true;\n      }\n    }\n  }\n  // Find the deepest location at the start of the last element.\n  editor.caretManager.setCaret(domutil.firstDescendantOrSelf(node), 0);\n}\n\n/**\n * Makes an input trigger that splits and merges consecutive elements.\n *\n * @param editor The editor for which to create the input trigger.\n *\n * @param elementName A CSS selector that determines which element we want to\n * split or merge. For instance, to operate on all paragraphs, this parameter\n * could be ``\"p\"``.\n *\n * @param splitKey The key which splits the element.\n *\n * @param mergeWithPreviousKey The key which merges the element with its\n * previous sibling.\n *\n * @param mergeWithNextKey The key which merges the element with its next\n * sibling.\n *\n * @returns The input trigger.\n */\nexport function makeSplitMergeInputTrigger(editor: Editor,\n                                           elementName: string,\n                                           splitKey: Key,\n                                           mergeWithPreviousKey: Key,\n                                           mergeWithNextKey: Key):\nInputTrigger {\n  const splitNodeOnTr = new transformation.Transformation(\n    editor, \"split\", \"Split node on character\", splitNodeOn);\n\n  const ret = new InputTrigger(editor, elementName);\n  ret.addKeyHandler(splitKey, (eventType, el, ev) => {\n    if (ev !== undefined) {\n      ev.stopImmediatePropagation();\n      ev.preventDefault();\n    }\n    if (eventType === \"keypress\" || eventType === \"keydown\") {\n      editor.fireTransformation(editor.split_node_tr, { node: el });\n    }\n    else {\n      editor.fireTransformation(\n        splitNodeOnTr, { node: el, sep: String.fromCharCode(splitKey.which) });\n    }\n  });\n\n  ret.addKeyHandler(mergeWithPreviousKey, (eventType, el, ev) => {\n    const caret = editor.caretManager.getDataCaret();\n\n    if (caret == null) {\n      return;\n    }\n\n    // Fire it only if it the caret is at the start of the element we are\n    // listening on and can't go back.\n    if ((caret.offset === 0) &&\n        (caret.node === el ||\n         (isText(caret.node) && caret.node === el.firstChild))) {\n      if (ev !== undefined) {\n        ev.stopImmediatePropagation();\n        ev.preventDefault();\n      }\n      editor.fireTransformation(\n        editor.merge_with_previous_homogeneous_sibling_tr,\n        { node: el, name: el.tagName });\n    }\n  });\n\n  ret.addKeyHandler(mergeWithNextKey, (eventType, el, ev) => {\n    const caret = editor.caretManager.getDataCaret();\n\n    if (caret == null) {\n      return;\n    }\n\n    // Fire it only if it the caret is at the end of the element we are\n    // listening on and can't actually delete text.\n    if ((caret.node === el && caret.offset === el.childNodes.length) ||\n        (isText(caret.node) &&\n         caret.node === el.lastChild &&\n         caret.offset === (el.lastChild as Text).length)) {\n      if (ev !== undefined) {\n        ev.stopImmediatePropagation();\n        ev.preventDefault();\n      }\n      editor.fireTransformation(\n        editor.merge_with_next_homogeneous_sibling_tr,\n        { node: el, name: el.tagName });\n    }\n  });\n  return ret;\n}\n\n//  LocalWords:  Mangalam MPL Dubeau lastChild deleteText domutil\n//  LocalWords:  keypress keydown util\n//  LocalWords:  InputTrigger\n"]}