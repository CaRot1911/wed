{"version":3,"file":"input-trigger-factory.js","sourceRoot":"","sources":["../../../../lib/wed/input-trigger-factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Functions to create input triggers according to some common patterns.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { isText } from \"./domtypeguards\";\nimport * as domutil from \"./domutil\";\nimport { GUISelector } from \"./gui-selector\";\nimport { InputTrigger } from \"./input-trigger\";\nimport { Key } from \"./key\";\nimport { Mode } from \"./mode\";\nimport { EditorAPI } from \"./mode-api\";\nimport * as transformation from \"./transformation\";\n\ninterface SplitData extends transformation.TransformationData {\n  // node is no longer optional.\n  node: Node;\n  sep: string;\n}\n\n/**\n * A transformation handler for a node splitting transformation.\n *\n * @param editor The editor which invoked the transformation.\n *\n * @param data The key that is splitting the element.\n *\n * @throws {Error} If the data passed is incorrect.\n */\nfunction splitNodeOn(editor: EditorAPI, data: SplitData): void {\n  let node = data.node;\n  const sep = data.sep;\n  if (typeof sep !== \"string\" || sep.length !== 1) {\n    throw new Error(\"transformation invoked with incorrect data\");\n  }\n  let modified = true;\n  while (modified) {\n    modified = false;\n    const textNodes: Text[] = [];\n    let child = node.firstChild;\n    while (child !== null) {\n      if (isText(child)) {\n        textNodes.push(child);\n      }\n      child = child.nextSibling;\n    }\n\n    for (let i = 0; !modified && i < textNodes.length; ++i) {\n      const text = textNodes[i];\n      const offset = text.data.indexOf(sep);\n      if (node.firstChild === text && offset === 0) {\n        // We just drop the separator\n        editor.dataUpdater.deleteText(text, offset, 1);\n        modified = true;\n      }\n      else if (node.lastChild === text && offset !== -1 &&\n               offset === text.length - 1) {\n        // Just drop the separator\n        editor.dataUpdater.deleteText(text, text.length - 1, 1);\n        modified = true;\n      }\n      else if (offset !== -1) {\n        const [, end] = editor.dataUpdater.splitAt(node, text, offset);\n        // Continue with the 2nd half of the split\n        if (end === null) {\n          throw new Error(\"null end; we should not be getting that\");\n        }\n        node = end;\n        modified = true;\n      }\n    }\n  }\n  // Find the deepest location at the start of the last element.\n  editor.caretManager.setCaret(domutil.firstDescendantOrSelf(node), 0);\n}\n\n/**\n * Makes an input trigger that splits and merges consecutive elements.\n *\n * @param editor The editor for which to create the input trigger.\n *\n * @param selector A CSS selector that determines which element we want to\n * split or merge. For instance, to operate on all paragraphs, this parameter\n * could be ``\"p\"``. This selector must be fit to be used in the GUI tree.\n *\n * @param splitKey The key which splits the element.\n *\n * @param mergeWithPreviousKey The key which merges the element with its\n * previous sibling.\n *\n * @param mergeWithNextKey The key which merges the element with its next\n * sibling.\n *\n * @returns The input trigger.\n */\nexport function makeSplitMergeInputTrigger(editor: EditorAPI,\n                                           mode: Mode,\n                                           selector: GUISelector,\n                                           splitKey: Key,\n                                           mergeWithPreviousKey: Key,\n                                           mergeWithNextKey: Key):\nInputTrigger {\n  const splitNodeOnTr = new transformation.Transformation<SplitData>(\n    editor, \"split\", \"Split node on character\", splitNodeOn);\n\n  const ret = new InputTrigger(editor, mode, selector);\n  ret.addKeyHandler(splitKey, (eventType, el, ev) => {\n    if (ev !== undefined) {\n      ev.stopImmediatePropagation();\n      ev.preventDefault();\n    }\n    if (eventType === \"keypress\" || eventType === \"keydown\") {\n      editor.fireTransformation(editor.splitNodeTr, { node: el });\n    }\n    else {\n      editor.fireTransformation(\n        splitNodeOnTr, {\n          name: el.tagName,\n          node: el,\n          sep: String.fromCharCode(splitKey.which),\n        });\n    }\n  });\n\n  ret.addKeyHandler(mergeWithPreviousKey, (_eventType, el, ev) => {\n    const caret = editor.caretManager.getDataCaret();\n\n    if (caret == null) {\n      return;\n    }\n\n    // Fire it only if it the caret is at the start of the element we are\n    // listening on and can't go back.\n    if ((caret.offset === 0) &&\n        (caret.node === el ||\n         (isText(caret.node) && caret.node === el.firstChild))) {\n      if (ev !== undefined) {\n        ev.stopImmediatePropagation();\n        ev.preventDefault();\n      }\n      editor.fireTransformation(editor.mergeWithPreviousHomogeneousSiblingTr,\n                                { node: el, name: el.tagName });\n    }\n  });\n\n  ret.addKeyHandler(mergeWithNextKey, (_eventType, el, ev) => {\n    const caret = editor.caretManager.getDataCaret();\n\n    if (caret == null) {\n      return;\n    }\n\n    // Fire it only if it the caret is at the end of the element we are\n    // listening on and can't actually delete text.\n    if ((caret.node === el && caret.offset === el.childNodes.length) ||\n        (isText(caret.node) &&\n         caret.node === el.lastChild &&\n         caret.offset === (el.lastChild as Text).length)) {\n      if (ev !== undefined) {\n        ev.stopImmediatePropagation();\n        ev.preventDefault();\n      }\n      editor.fireTransformation(editor.mergeWithNextHomogeneousSiblingTr,\n                                { node: el, name: el.tagName });\n    }\n  });\n  return ret;\n}\n\n//  LocalWords:  InputTrigger keydown keypress domutil deleteText lastChild MPL\n//  LocalWords:  Dubeau Mangalam\n"]}