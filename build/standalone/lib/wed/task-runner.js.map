{"version":3,"file":"task-runner.js","sourceRoot":"","sources":["../../../../lib/wed/task-runner.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Task abstraction for wed.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { first } from \"rxjs/operators\";\n\n/**\n * The options accepted by a task runner.\n */\nexport interface TaskRunnerOptions {\n  /**\n   * The timeout between one cycle and the next. This is the number of\n   * milliseconds that elapse before the next cycle runs.\n   */\n  timeout?: number;\n\n  /**\n   * The maximum number of milliseconds a cycle may run. A cycle will stop after\n   * it has used the number of milliseconds listed here. Setting this to 0 means\n   * \"run until done\" which is not generally recommended.\n   */\n  maxTimespan?: number;\n}\n\nexport interface Task {\n  /**\n   * Performs one cycle of work. \"One cycle\" is an arbitrarily small unit of\n   * work. For instance, if the task is to do something to all elements in an\n   * array, one cycle could process a set number of elements from the array.\n   *\n   * @param task The task that is performing the computation.\n   *\n   * @returns False if there is no more work to be done. True otherwise.\n   */\n  cycle(task: TaskRunner): boolean;\n\n  /**\n   * Inform the computation that it should reset its state to start a\n   * computation anew.\n   */\n  reset(task: TaskRunner): void;\n}\n\nexport interface State {\n  running: boolean;\n  completed: boolean;\n  terminated: boolean;\n}\n\n/**\n * A task is a computation that should produce a definite goal after a finite\n * time. This class is used to allow the task to happen in a way that does not\n * completely block the JavaScript virtual machine. The task will happen in\n * cycles that run for a maximum amount of time before relinquishing control.\n */\nexport class TaskRunner {\n  private readonly _timeout: number = 0;\n  private readonly _maxTimespan: number = 100;\n  private readonly _boundWrapper: Function = this._workWrapper.bind(this);\n  private _timeoutId: number | undefined;\n  private _state: BehaviorSubject<State>;\n\n  public state: Observable<State>;\n  /**\n   * @param task The computation controlled by this runner.\n   *\n   * @param options The options governing this runner.\n   */\n  constructor(private readonly task: Task, options: TaskRunnerOptions = {}) {\n    const keys: (keyof TaskRunnerOptions)[] = [\"timeout\", \"maxTimespan\"];\n    for (const key of keys) {\n      const value = options[key];\n      if (value === undefined) {\n        continue;\n      }\n\n      if (value < 0) {\n        throw new Error(`the value for ${key} cannot be negative`);\n      }\n\n      // tslint:disable-next-line:no-any\n      (this as any)[`_${key}`] = options[key];\n    }\n\n    this._state = new BehaviorSubject({\n      running: false,\n      completed: false,\n      terminated: false,\n    });\n\n    this.state = this._state.asObservable();\n  }\n\n  get running(): boolean {\n    return this._state.value.running;\n  }\n\n  get completed(): boolean {\n    return this._state.value.completed;\n  }\n\n  get terminated(): boolean {\n    return this._state.value.terminated;\n  }\n\n  onCompleted(): Promise<State> {\n    return this.state.pipe(first((state) => state.completed)).toPromise();\n  }\n\n  private _stateFieldChange<T extends keyof State>(field: T,\n                                                   value: State[T]): void {\n    const latest = this._state.value;\n    const newState = {...this._state.value};\n    newState[field] = value;\n\n    if (newState[field] !== latest[field]) {\n      this._state.next(newState);\n    }\n  }\n\n  private _setTimeoutId(value: number | undefined): void {\n    this._timeoutId = value;\n    this._stateFieldChange(\"running\", this._timeoutId !== undefined);\n  }\n\n  /**\n   * Marks the task as incomplete and starts processing.\n   */\n  start(): void {\n    this.reset();\n    this.resume();\n  }\n\n  /**\n   * Resets the task to its initial state. The task will be deemed incomplete.\n   */\n  reset(): void {\n    this._stateFieldChange(\"completed\", false);\n    this.task.reset(this);\n  }\n\n  /**\n   * Resumes the task. This method does not change the completion status of the\n   * task. So it is possible to stop a task temporarily and resume it later from\n   * where it stopped.\n   */\n  resume(): void {\n    if (this.completed) {\n      return;\n    }\n\n    if (this._timeoutId !== undefined) {\n      this.stop();\n    }\n\n    // When we call ``this.resume``, we want the task to resume ASAP. So we do\n    // not use ``this._timeout`` here. However, we do not call\n    // ``this._workWrapper`` directly because we want to be able to call\n    // ``this.resume`` from event handlers. If we did call ``this._workWrapper``\n    // directly, we'd be calling this._cycle from inside this._cycle\n    this._setTimeoutId(setTimeout(this._boundWrapper, 0));\n  }\n\n  /**\n   * Convenience method. The bound version of this method\n   * (``this._boundWrapper``) is what is called by the timeouts.\n   */\n  private _workWrapper(): void {\n    if (this._work()) {\n      this._setTimeoutId(setTimeout(this._boundWrapper, this._timeout));\n    }\n    else {\n      this._stateFieldChange(\"completed\", true);\n    }\n  }\n\n  /**\n   * Keeps the task running by launching cycles only until done or until the\n   * maximum time span for one run is reached.\n   *\n   * @returns False if there is no more work to do. True otherwise.\n   */\n  private _work(): boolean {\n    const startDate = Date.now();\n    // tslint:disable-next-line:strict-boolean-expressions no-constant-condition\n    while (true) {\n      // Give a chance to other operations to work.\n      if ((this._maxTimespan > 0) &&\n          (Date.now() - startDate) >= this._maxTimespan) {\n        return true;\n      }\n\n      const ret = this.task.cycle(this);\n      if (!ret) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Stops the task.\n   */\n  stop(): void {\n    if (this._timeoutId !== undefined) {\n      clearTimeout(this._timeoutId);\n    }\n    this._setTimeoutId(undefined);\n  }\n\n  /**\n   * Terminate the task.\n   */\n  terminate(): void {\n    this.stop();\n    this._stateFieldChange(\"terminated\", true);\n    this._state.complete();\n  }\n}\n\n//  LocalWords:  MPL maxTimespan workWrapper\n"]}