{"version":3,"file":"mode-tree.js","sourceRoot":"","sources":["../../../../lib/wed/mode-tree.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAkCA;;OAEG;IACH;QAIE;;;;;;;;;;;;WAYG;QACH,kBAA4B,IAAU,EACV,MAAc,EACd,QAAgB,EAChB,QAAoB,EACpB,UAA6B;YAJ7B,SAAI,GAAJ,IAAI,CAAM;YACV,WAAM,GAAN,MAAM,CAAQ;YACd,aAAQ,GAAR,QAAQ,CAAQ;YAChB,aAAQ,GAAR,QAAQ,CAAY;YACpB,eAAU,GAAV,UAAU,CAAmB;QAAG,CAAC;QAE7D;;;;;;;;;;;;;WAaG;QACH,oCAAiB,GAAjB,UAAkB,WAAoB,EAAE,IAAU;YAChD,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBAC/B,OAAO,IAAI,CAAC;aACb;YAED,IAAI,IAAI,CAAC,QAAQ,KAAK,EAAE,EAAE;gBACxB,OAAO,WAAW,CAAC;aACpB;YAED,IAAM,OAAO,GAAG,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5D,KAAqB,UAAmB,EAAnB,KAAA,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,EAAnB,cAAmB,EAAnB,IAAmB;gBAAnC,IAAM,MAAM,SAAA;gBACf,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;oBACzB,OAAO,MAAM,CAAC;iBACf;aACF;YAED,OAAO,IAAI,CAAC;QACd,CAAC;QAED,iCAAc,GAAd,UAAkB,EAAyC,EACzC,YAAe;YAC/B,IAAI,KAAK,GAAG,EAAE,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;YAEnC,KAAsB,UAAa,EAAb,KAAA,IAAI,CAAC,QAAQ,EAAb,cAAa,EAAb,IAAa;gBAA9B,IAAM,OAAO,SAAA;gBAChB,KAAK,GAAG,OAAO,CAAC,cAAc,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;aAC3C;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAED,+BAAY,GAAZ,UAAa,EAA4B;YACvC,EAAE,CAAC,IAAI,CAAC,CAAC;YAET,KAAsB,UAAa,EAAb,KAAA,IAAI,CAAC,QAAQ,EAAb,cAAa,EAAb,IAAa;gBAA9B,IAAM,OAAO,SAAA;gBAChB,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;aAC1B;QACH,CAAC;QAED,sBAAI,0CAAoB;iBAAxB;gBACE,IAAI,IAAI,CAAC,qBAAqB,KAAK,SAAS,EAAE;oBAC5C,IAAM,eAAe,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,CAAC;oBAC5D,IAAI,eAAe,KAAK,SAAS,EAAE;wBACjC,yBAAyB;wBACzB,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;qBACnC;yBACI;wBACH,IAAM,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;wBACtC,IAAI,MAAM,KAAK,UAAU,EAAE;4BACzB,MAAM,IAAI,KAAK,CAAC,sCAAoC,MAAQ,CAAC,CAAC;yBAC/D;wBAED,IAAM,KAAK,GAAyB;4BAClC,QAAQ,EAAE,EAAE;yBACb,CAAC;wBAEF,KAAsB,UAAwB,EAAxB,KAAA,eAAe,CAAC,QAAQ,EAAxB,cAAwB,EAAxB,IAAwB;4BAAzC,IAAM,OAAO,SAAA;4BAChB,IAAM,IAAI,GAAG,uBAAY,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;4BACvC,IAAI,CAAC,QAAQ;gCACX,uBAAa,CAAC,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,IAAI,CAAC,4BAA4B,EAAE,CAAC,CAAC;4BAC1D,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAC3B;wBAED,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;qBACpC;iBACF;gBAED,OAAO,IAAI,CAAC,qBAAqB,CAAC;YACpC,CAAC;;;WAAA;QAED,sBAAI,+BAAS;iBAAb;gBACE,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE;oBACjC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;iBAC7C;gBAED,OAAO,IAAI,CAAC,UAAU,CAAC;YACzB,CAAC;;;WAAA;QACH,eAAC;IAAD,CAAC,AAlHD,IAkHC;IAED;;OAEG;IACH;QAKE;;;;;WAKG;QACH,kBAA6B,MAAc,EACd,MAAkB;YADlB,WAAM,GAAN,MAAM,CAAQ;YACd,WAAM,GAAN,MAAM,CAAY;YAC7C,IAAI,CAAC,MAAM,GAAG,IAAI,wBAAU,CAAC,MAAM,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;QACvD,CAAC;QAED;;;;;WAKG;QACG,uBAAI,GAAV;;;;;;4BACQ,cAAc,GAAa,EAAE,CAAC;4BACpC,KAAA,IAAI,CAAA;4BAAQ,qBAAM,IAAI,CAAC,SAAS,CAC9B,EAAE,EACF,IAAI,CAAC,MAAM,EACX,UAAC,IAAY,EAAE,MAAgB;oCAC7B,KAAoB,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM;wCAArB,IAAM,KAAK,eAAA;wCACd,cAAc,CAAC,IAAI,CACjB,kBAAgB,IAAI,0CAAqC,KAAO,CAAC,CAAC;qCACrE;gCACH,CAAC,CAAC,EAAA;;4BARJ,GAAK,IAAI,GAAG,SAQR,CAAC;4BAEL,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;gCAC7B,MAAM,IAAI,KAAK,CAAC,gCAA8B,cAAc,CAAC,IAAI,CAAC,EAAE,CAAG,CAAC,CAAC;6BAC1E;4BAED,sBAAO,IAAI,EAAC;;;;SACb;QAED;;;;;;;;;;;;;;;;WAgBG;QACW,4BAAS,GAAvB,UAAwB,QAAgB,EAChB,MAAkB,EAClB,YAAqC;;;;;;4BAErD,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;4BAClB,qBAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,EAAA;;4BAA9D,IAAI,GAAG,SAAuD;iCACnD,CAAC,OAAO,KAAK,SAAS,CAAC,EAAvB,wBAAuB;4BACrC,qBAAM,IAAI,CAAC,SAAS,CAAC,uBAAa,CAAC,OAAO,CAAC,QAAQ,EAChB,IAAI,CAAC,4BAA4B,EAAE,CAAC,EAClD,OAAO,CAAC,IAAI,EACZ,YAAY,CAAC,EAAA;;4BAHnC,MAAC,SAGkC,EAAC;;;4BACpC,KAAA,EAAE,CAAA;;;4BALE,QAAQ,KAKV;4BACE,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;4BAClC,MAAM,GAAG,0CAAiB,CAAC,UAAU,CAAC,CAAC;4BAE7C,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gCACzB,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;gCAClC,iBAAiB;gCACjB,cAAc,GAAG,UAA+B,CAAC;6BAClD;iCACI;gCACH,cAAc,GAAG,MAAM,CAAC;6BACzB;4BACD,sBAAO,IAAI,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,CAAC,EAAC;;;;SAC5E;QAED,0BAAO,GAAP,UAAQ,IAAU;YAChB,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;QACrC,CAAC;QAED,+BAAY,GAAZ,UAAa,IAAU;YACrB,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;QAC1C,CAAC;QAED,gCAAa,GAAb,UAAc,IAAU;YACtB,IAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YACxC,OAAO,QAAQ,CAAC,UAAU,CAAC;QAC7B,CAAC;QAED,uCAAoB,GAApB,UAAqB,IAAU;YAC7B,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC;QACtD,CAAC;QAED,0CAAuB,GAAvB,UAAwB,IAAU;YAChC,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,oBAAoB,CAAC;QACrD,CAAC;QAED;;;;;;;WAOG;QACK,8BAAW,GAAnB,UAAoB,IAAU;YAC5B,2DAA2D;YAC3D,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBACnC,OAAO,IAAI,CAAC,IAAI,CAAC;aAClB;YAED,IAAI,kBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE;gBACxC,IAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,IAAI,KAAK,IAAI,EAAE;oBACjB,IAAI,GAAG,IAAI,CAAC;iBACb;aACF;YAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACvC,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;aAChE;YAED,IAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;YACvE,IAAI,MAAM,KAAK,SAAS,EAAE;gBACxB,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;aACxE;YAED,OAAO,MAAM,CAAC;QAChB,CAAC;QAEO,+BAAY,GAApB,UAAqB,MAAgB,EAAE,WAAoB,EACtC,IAAU;YAC7B,IAAM,KAAK,GAAG,MAAM,CAAC,iBAAiB,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;YAC1D,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,IAAI,QAAQ,SAAsB,CAAC;gBACnC,KAAsB,UAAe,EAAf,KAAA,MAAM,CAAC,QAAQ,EAAf,cAAe,EAAf,IAAe;oBAAhC,IAAM,OAAO,SAAA;oBAChB,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACnD,IAAI,QAAQ,KAAK,SAAS,EAAE;wBAC1B,OAAO,QAAQ,CAAC;qBACjB;iBACF;gBAED,OAAO,MAAM,CAAC;aACf;YAED,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,iCAAc,GAAd;YACE,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CACzC,UAAC,WAAoC,EAAE,IAAI;gBACzC,KAAoB,UAA0B,EAA1B,KAAA,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAA1B,cAA0B,EAA1B,IAA0B;oBAAzC,IAAM,KAAK,SAAA;oBACd,WAAW,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;iBAC3B;gBACD,OAAO,WAAW,CAAC;YACrB,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC7B,CAAC;QAED,mCAAgB,GAAhB;YACE,OAAO,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC;QAC5D,CAAC;QAED,uCAAoB,GAApB;YACE,OAAO,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC;QAChE,CAAC;QAUD,sBAAY,uCAAiB;YAR7B;;;;;;;eAOG;iBACH;gBACE,IAAI,IAAI,CAAC,kBAAkB,KAAK,SAAS,EAAE;oBACzC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,CAChD,UAAC,WAAW,EAAE,IAAI;wBAChB,IAAM,MAAM,GAAG,WAAW,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC;wBACvD,IAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC;wBACjD,OAAO,CAAC,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC;oBACjD,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;iBACjB;gBAED,OAAO,IAAI,CAAC,kBAAkB,CAAC;YACjC,CAAC;;;WAAA;QAED,gCAAa,GAAb;YACE,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAC7B,UAAC,WAAW,EAAE,IAAI;gBAChB,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;gBAC3C,OAAO,SAAS,KAAK,SAAS,CAAC,CAAC;oBAC9B,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;YAChD,CAAC,EAAE,EAAE,CAAC,CAAC;QACX,CAAC;QAED;;WAEG;QACH,uCAAoB,GAApB;YACE,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAC,IAAI;gBAC1B,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;YAC/B,CAAC,CAAC,CAAC;QACL,CAAC;QAED;;WAEG;QACH,iCAAc,GAAd;YACE,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAC,IAAI;gBAC1B,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,CAAC;YAClC,CAAC,CAAC,CAAC;QACL,CAAC;QACH,eAAC;IAAD,CAAC,AA7ND,IA6NC;IA7NY,4BAAQ;;AA+NrB,oEAAoE;AACpE,4BAA4B","sourcesContent":["/**\n * Manage a tree of modes.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport mergeOptions from \"merge-options\";\n\nimport { Decorator } from \"./decorator\";\nimport { contains, toGUISelector } from \"./domutil\";\nimport { Editor } from \"./editor\";\nimport { Mode } from \"./mode\";\nimport { ModeTreeAPI } from \"./mode-api\";\nimport { ModeLoader } from \"./mode-loader\";\nimport { Mode as ModeOption } from \"./options\";\nimport { ModeValidator } from \"./validator\";\nimport { CleanedWedOptions, processWedOptions } from \"./wed-options-validation\";\n\n/**\n * A callback for reporting wed option errors.\n *\n * @param path The mode's path, as specified in the configuration.\n *\n * @param errors The errors encountered.\n */\ntype WedOptionsErrorCallback = (path: string, errors: string[]) => void;\n\nexport interface AttributeHidingSpecs {\n  elements: {\n    selector: string;\n    attributes: (string | { except: string[]})[];\n  }[];\n}\n\n/**\n * A node for the mode tree.\n */\nclass ModeNode {\n  private _attributeHidingSpecs: AttributeHidingSpecs | null | undefined;\n  private _decorator: Decorator | undefined;\n\n  /**\n   * @param mode The mode that this node holds.\n   *\n   * @param editor The editor for which we are holding a mode.\n   *\n   * @param selector The selector that determines to what this modes apply. This\n   * selector must have been converted to operate in the GUI tree.\n   *\n   * @param submodes The submodes set for this mode.\n   *\n   * @param wedOptions The cleaned up wed options that pertain to the mode held\n   * by this node.\n   */\n  constructor(public readonly mode: Mode,\n              public readonly editor: Editor,\n              public readonly selector: string,\n              public readonly submodes: ModeNode[],\n              public readonly wedOptions: CleanedWedOptions) {}\n\n  /**\n   * Determines whether an element matched by the selector of this ``ModeNode``\n   * node in the GUI tree contains a node. If it does, this means that the mode\n   * that this ``ModeNode`` holds, or one of the submode, governs the node.\n   *\n   * @param parentScope The element from which the selector in this ``ModeNode``\n   * is interpreted.\n   *\n   * @param node A GUI node to test.\n   *\n   * @returns The element that represents the top of the mode's region of\n   * activity and contains ``node``. Returns ``null`` if no element contains the\n   * node.\n   */\n  containingElement(parentScope: Element, node: Node): Element | null {\n    if (!parentScope.contains(node)) {\n      return null;\n    }\n\n    if (this.selector === \"\") {\n      return parentScope;\n    }\n\n    const regions = parentScope.querySelectorAll(this.selector);\n    for (const region of Array.from(regions)) {\n      if (region.contains(node)) {\n        return region;\n      }\n    }\n\n    return null;\n  }\n\n  reduceTopFirst<T>(fn: (accumulator: T, node: ModeNode) => T,\n                    initialValue: T): T {\n    let value = fn(initialValue, this);\n\n    for (const submode of this.submodes) {\n      value = submode.reduceTopFirst(fn, value);\n    }\n\n    return value;\n  }\n\n  eachTopFirst(fn: (node: ModeNode) => void): void {\n    fn(this);\n\n    for (const submode of this.submodes) {\n      submode.eachTopFirst(fn);\n    }\n  }\n\n  get attributeHidingSpecs(): AttributeHidingSpecs | null {\n    if (this._attributeHidingSpecs === undefined) {\n      const attributeHiding = this.wedOptions.attributes.autohide;\n      if (attributeHiding === undefined) {\n        // No attribute hiding...\n        this._attributeHidingSpecs = null;\n      }\n      else {\n        const method = attributeHiding.method;\n        if (method !== \"selector\") {\n          throw new Error(`unknown attribute hiding method: ${method}`);\n        }\n\n        const specs: AttributeHidingSpecs = {\n          elements: [],\n        };\n\n        for (const element of attributeHiding.elements) {\n          const copy = mergeOptions({}, element);\n          copy.selector =\n            toGUISelector(copy.selector,\n                          this.mode.getAbsoluteNamespaceMappings());\n          specs.elements.push(copy);\n        }\n\n        this._attributeHidingSpecs = specs;\n      }\n    }\n\n    return this._attributeHidingSpecs;\n  }\n\n  get decorator(): Decorator {\n    if (this._decorator === undefined) {\n      this._decorator = this.mode.makeDecorator();\n    }\n\n    return this._decorator;\n  }\n}\n\n/**\n * A tree containing the modes configured for the current editing session.\n */\nexport class ModeTree implements ModeTreeAPI {\n  private root!: ModeNode;\n  private loader: ModeLoader;\n  private cachedMaxLabelNode: ModeNode | undefined;\n\n  /**\n   * @param editor The editor for which we are building this tree.\n   *\n   * @param option The ``mode`` option from the options passed to the wed\n   * instance. This object will construct a tree from this option.\n   */\n  constructor(private readonly editor: Editor,\n              private readonly option: ModeOption) {\n    this.loader = new ModeLoader(editor, editor.runtime);\n  }\n\n  /**\n   * Load the modes, initialize them and build the tree.\n   *\n   * @returns A promise that resolves to ``this`` once all the modes are loaded\n   * and initialized.\n   */\n  async init(): Promise<ModeTree> {\n    const combinedErrors: string[] = [];\n    this.root = await this.makeNodes(\n      \"\",\n      this.option,\n      (path: string, errors: string[]) => {\n        for (const error of errors) {\n          combinedErrors.push(\n            `mode at path ${path} has an error in its wed options: ${error}`);\n        }\n      });\n\n    if (combinedErrors.length > 0) {\n      throw new Error(`wed options are incorrect: ${combinedErrors.join(\"\")}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Make the nodes of the tree. This function operates recursively: it will\n   * inspect ``option`` for a ``submode`` option and will call itself to create\n   * the necessary child nodes.\n   *\n   * @param selector The selector associated with the options passed in the 2nd\n   * argument.\n   *\n   * @param option The mode option being processed.\n   *\n   * @param errorHanler The handler to call on errors in processing the wed\n   * options. If this handler is called at all, then the returned value should\n   * not be used. We operate this way because we want to report all errors that\n   * can be reported, rather than abort early.\n   *\n   * @returns A promise that resolves to the created node.\n   */\n  private async makeNodes(selector: string,\n                          option: ModeOption,\n                          errorHandler: WedOptionsErrorCallback):\n  Promise<ModeNode> {\n    const submode = option.submode;\n    const mode = await this.loader.initMode(option.path, option.options);\n    const submodes = (submode !== undefined) ?\n      [await this.makeNodes(toGUISelector(submode.selector,\n                                          mode.getAbsoluteNamespaceMappings()),\n                            submode.mode,\n                            errorHandler)] :\n      [];\n    const rawOptions = mode.getWedOptions();\n    const result = processWedOptions(rawOptions);\n    let cleanedOptions: CleanedWedOptions;\n    if (Array.isArray(result)) {\n      errorHandler(option.path, result);\n      // This is a lie.\n      cleanedOptions = rawOptions as CleanedWedOptions;\n    }\n    else {\n      cleanedOptions = result;\n    }\n    return new ModeNode(mode, this.editor, selector, submodes, cleanedOptions);\n  }\n\n  getMode(node: Node): Mode {\n    return this.getModeNode(node).mode;\n  }\n\n  getDecorator(node: Node): Decorator {\n    return this.getModeNode(node).decorator;\n  }\n\n  getWedOptions(node: Node): CleanedWedOptions {\n    const modeNode = this.getModeNode(node);\n    return modeNode.wedOptions;\n  }\n\n  getAttributeHandling(node: Node): \"show\" | \"hide\" | \"edit\" {\n    return this.getWedOptions(node).attributes.handling;\n  }\n\n  getAttributeHidingSpecs(node: Node):  AttributeHidingSpecs | null {\n    return this.getModeNode(node).attributeHidingSpecs;\n  }\n\n  /**\n   * Get the mode node that governs a node.\n   *\n   * @param The node we want to check. This must be a done in the data tree or\n   * the GUI tree.\n   *\n   * @returns The mode that governs the node.\n   */\n  private getModeNode(node: Node): ModeNode {\n    // Handle the trivial case where there is no submode first.\n    if (this.root.submodes.length === 0) {\n      return this.root;\n    }\n\n    if (contains(this.editor.dataRoot, node)) {\n      const data = this.editor.fromDataNode(node);\n      if (data !== null) {\n        node = data;\n      }\n    }\n\n    if (!this.editor.guiRoot.contains(node)) {\n      throw new Error(\"did not pass a node in the GUI or data tree\");\n    }\n\n    const result = this._getModeNode(this.root, this.editor.guiRoot, node);\n    if (result === undefined) {\n      throw new Error(\"cannot find a mode for the node; something is wrong\");\n    }\n\n    return result;\n  }\n\n  private _getModeNode(parent: ModeNode, parentScope: Element,\n                       node: Node): ModeNode | undefined {\n    const scope = parent.containingElement(parentScope, node);\n    if (scope !== null) {\n      let narrower: ModeNode | undefined;\n      for (const submode of parent.submodes) {\n        narrower = this._getModeNode(submode, scope, node);\n        if (narrower !== undefined) {\n          return narrower;\n        }\n      }\n\n      return parent;\n    }\n\n    return undefined;\n  }\n\n  getStylesheets(): string[] {\n    return Object.keys(this.root.reduceTopFirst(\n      (accumulator: Record<string, boolean>, node) => {\n        for (const sheet of node.mode.getStylesheets()) {\n          accumulator[sheet] = true;\n        }\n        return accumulator;\n      }, Object.create(null)));\n  }\n\n  getMaxLabelLevel(): number {\n    return this.maxLabelLevelNode.wedOptions.label_levels.max;\n  }\n\n  getInitialLabelLevel(): number {\n    return this.maxLabelLevelNode.wedOptions.label_levels.initial;\n  }\n\n  /**\n   * The node with the maximum label visibility level. If multiple nodes have\n   * the same value, the earlier node \"wins\", and is the one provided by this\n   * property. For instance, if the root node and its submode have the same\n   * number, then this property has the root node for value.\n   *\n   * This is a cached value, computed on first access.\n   */\n  private get maxLabelLevelNode(): ModeNode {\n    if (this.cachedMaxLabelNode === undefined) {\n      this.cachedMaxLabelNode = this.root.reduceTopFirst<ModeNode>(\n        (accumulator, node) => {\n          const accMax = accumulator.wedOptions.label_levels.max;\n          const nodeMax = node.wedOptions.label_levels.max;\n          return (nodeMax > accMax) ? node : accumulator;\n        }, this.root);\n    }\n\n    return this.cachedMaxLabelNode;\n  }\n\n  getValidators(): ModeValidator[] {\n    return this.root.reduceTopFirst<ModeValidator[]>(\n      (accumulator, node) => {\n        const validator = node.mode.getValidator();\n        return validator !== undefined ?\n          accumulator.concat(validator) : accumulator;\n      }, []);\n  }\n\n  /**\n   * Call on each decorator to add its event handlers.\n   */\n  addDecoratorHandlers(): void {\n    this.root.eachTopFirst((node) => {\n      node.decorator.addHandlers();\n    });\n  }\n\n  /**\n   * Call on each decorator to start listening.\n   */\n  startListening(): void {\n    this.root.eachTopFirst((node) => {\n      node.decorator.startListening();\n    });\n  }\n}\n\n//  LocalWords:  MPL submodes submode combinedErrors nd preprocessed\n//  LocalWords:  stylesheets\n"]}