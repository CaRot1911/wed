{"version":3,"sources":["../../../wed/undo.ts"],"names":[],"mappings":"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","file":"undo.js","sourcesContent":["/**\n * Basic undo/redo framework.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\n\n/**\n * Records operations that may be undone or redone. It maintains a single list\n * of [[Undo]] objects in the order by which they are passed to the\n * [[UndoList.record]] method.\n *\n * This object maintains a single history. So if operations A, B, C, D are\n * recorded, C and D are undone and then E is recorded, the list of recorded\n * operations will then be A, B, E.\n */\nexport class UndoList {\n  private readonly stack: UndoGroup[] = [];\n  private list: Undo[] = [];\n  private index: number = -1;\n  private _undoingOrRedoing: boolean = false;\n\n  /**\n   * This method makes the UndoList object record the object passed to it. Any\n   * operations that had previously been undone are forgotten.\n   *\n   * @param obj An undo object to record.\n   */\n  record(obj: Undo): void {\n    if (this.stack.length > 0) {\n      this.stack[0].record(obj);\n    }\n    else {\n      this.list = this.list.splice(0, this.index + 1);\n      this.list.push(obj);\n      this.index++;\n    }\n  }\n\n  /**\n   * Undoes the latest [[Undo]] that was recorded. If any [[UndoGroup]] objects\n   * were in effect when called, they are terminated. It is an error to call\n   * this method or [[redo]] from within this method. Does nothing if there is\n   * nothing to undo.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  undo(): void {\n    // If undo is invoked in the middle of a group, we must end it first.\n    if (this._undoingOrRedoing) {\n      throw new Error(\"calling undo while undoing or redoing\");\n    }\n    this._undoingOrRedoing = true;\n    while (this.stack.length > 0) {\n      this.endGroup();\n    }\n    if (this.index >= 0) {\n      this.list[this.index--].undo();\n    }\n    this._undoingOrRedoing = false;\n  }\n\n  /**\n   * Redoes the latest [[Undo]] object that was undone.  It is an error to call\n   * this method or [[undo]] from within this method. Does nothing if there is\n   * nothing to redo.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  redo(): void {\n    if (this._undoingOrRedoing) {\n      throw new Error(\"calling redo while undoing or redoing\");\n    }\n    this._undoingOrRedoing = true;\n    if (this.index < this.list.length - 1) {\n      this.list[++this.index].redo();\n    }\n    this._undoingOrRedoing = false;\n  }\n\n  /**\n   * @returns True if the object is in the midst of undoing or redoing, false\n   * otherwise.\n   */\n  undoingOrRedoing(): boolean {\n    return this._undoingOrRedoing;\n  }\n\n  /**\n   * @returns True if there is something to undo, false otherwise.\n   */\n  canUndo(): boolean {\n    // If there is a group on the stack, then we have to return true. That's\n    // because when the group is ended when undo() is called, it will be added\n    // at the end of this.list.\n    return this.index > -1 || this.stack.length > 0;\n  }\n\n  /**\n   * @returns True if there is something to redo, false otherwise.\n   */\n  canRedo(): boolean {\n    return this.index < this.list.length - 1;\n  }\n\n  /**\n   * Starts recording a group of undo operations.\n   *\n   * @param group The undo group to start.\n   */\n  startGroup(group: UndoGroup): void {\n    this.stack.unshift(group);\n  }\n\n  /**\n   * Ends recording a group of undo operations. The group currently in effect is\n   * terminated, and made the last recorded operation (as if it had been passed\n   * to [[UndoList.record]]).\n   *\n   * @throws {Error} If there is no current undo group.\n   */\n  endGroup(): void {\n    const group = this.stack.shift();\n    if (group === undefined) {\n      throw new Error(\"ending a non-existent group.\");\n    }\n    group.end();\n    this.record(group);\n  }\n\n  /**\n   * Ends all groups currently in effect. This is the same as calling\n   * [[endGroup]] repeatedly until there are no more groups to end.\n   */\n  endAllGroups(): void {\n    while (this.stack.length > 0) {\n      this.endGroup();\n    }\n  }\n\n  /**\n   * @returns The group currently being recorded.\n   */\n  getGroup(): UndoGroup {\n    return this.stack[0];\n  }\n\n  /**\n   * @returns A string showing all the undo steps and undo groups stored in this\n   * undo list.\n   */\n  toString(): string {\n    const ret = [];\n    ret.push(\"Start of list\\n\");\n    for (const it of this.list) {\n      ret.push(it.toString());\n    }\n    ret.push(\"End of list\\n\");\n    ret.push(\"Unfinished groups:\\n\");\n    for (let i = this.stack.length - 1; i >= 0; --i) {\n      const it = this.stack[i];\n      ret.push(it.toString());\n    }\n    ret.push(\"End of unfinished groups\\n\");\n    return ret.join(\"\");\n  }\n}\n\n/**\n * An undo operation.\n * @param {string} desc The description of this undo operation.\n */\nexport abstract class Undo {\n  constructor(public readonly desc: string) {}\n\n  /**\n   * Called when the operation must be undone.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  abstract undo(): void;\n\n  /**\n   * Called when the operation must be redone.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  abstract redo(): void;\n\n  /**\n   * @returns The description of this object.\n   */\n  toString(): string {\n    return `${this.desc}\\n`;\n  }\n}\n\n/**\n * A group of undo operations.\n */\nexport class UndoGroup extends Undo {\n  protected readonly list: Undo[] = [];\n\n  /**\n   * Undoes this group, which means undoing all the operations that this group\n   * has recorded.\n   */\n  undo(): void {\n    for (let i = this.list.length - 1; i >= 0; --i) {\n      this.list[i].undo();\n    }\n  }\n\n  /**\n   * Redoes this group, which means redoing all the operations that this group\n   * has recorded.\n   */\n  redo(): void {\n    for (const it of this.list) {\n      it.redo();\n    }\n  }\n\n  /**\n   * Records an operation as part of this group.\n   *\n   * @param obj The operation to record.\n   */\n  record(obj: Undo): void {\n    this.list.push(obj);\n  }\n\n  /**\n   * This method is called by [[UndoList.endGroup]] when it ends a group. The\n   * default implementation does nothing.\n   */\n  end(): void {\n    // by default we do nothing\n  }\n\n  toString(): string {\n    const ret = [];\n    ret.push(`Start of ${this.desc}\\n`);\n    for (const it of this.list) {\n      ret.push(it.toString().replace(/(^|\\n)/g, \"$1 \").slice(0, -1));\n    }\n    ret.push(`End of ${this.desc}\\n`);\n    return ret.join(\"\");\n  }\n}\n\n//  LocalWords:  boolean Dubeau MPL Mangalam UndoList desc\n"]}