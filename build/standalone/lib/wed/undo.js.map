{"version":3,"file":"undo.js","sourceRoot":"","sources":["../../../../lib/wed/undo.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Basic undo/redo framework.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { Observable, Subject, Subscription } from \"rxjs\";\n\nexport interface UndoEvent {\n  name: \"Undo\";\n\n  undo: Undo;\n}\n\nexport interface RedoEvent {\n  name: \"Redo\";\n\n  undo: Undo;\n}\n\nexport type UndoEvents = UndoEvent | RedoEvent;\n\ninterface ListItem {\n  undo: Undo;\n\n  subscription: Subscription;\n}\n\n/**\n * Records operations that may be undone or redone. It maintains a single list\n * of [[Undo]] objects in the order by which they are passed to the\n * [[UndoList.record]] method.\n *\n * This object maintains a single history. So if operations A, B, C, D are\n * recorded, C and D are undone and then E is recorded, the list of recorded\n * operations will then be A, B, E.\n */\nexport class UndoList {\n  private readonly stack: UndoGroup[] = [];\n  private list: ListItem[] = [];\n  private index: number = -1;\n  private _undoingOrRedoing: boolean = false;\n\n  private readonly _events: Subject<UndoEvents> = new Subject();\n\n  readonly events: Observable<UndoEvents> = this._events.asObservable();\n\n  /**\n   * Reset the list to its initial state **without** undoing operations. The\n   * list effectively forgets old undo operations.\n   */\n  reset(): void {\n    if (this._undoingOrRedoing) {\n      throw new Error(\"may not reset while undoing or redoing\");\n    }\n\n    this.stack.length = 0; // Yes, this works and clears the stack.\n    this.index = -1;\n\n    // We need to cleanup the old subscriptions.\n    for (const { subscription } of this.list) {\n      subscription.unsubscribe();\n    }\n    this.list = [];\n  }\n\n  /**\n   * This method makes the UndoList object record the object passed to it. Any\n   * operations that had previously been undone are forgotten.\n   *\n   * @param obj An undo object to record.\n   */\n  record(obj: Undo): void {\n    if (this.stack.length > 0) {\n      this.stack[0].record(obj);\n    }\n    else {\n      // We do things in reverse here. We save the original list. Then the call\n      // to splice mutates the original list to contain elements we do *not*\n      // want. The return value are those elements we do want.\n      const oldList = this.list;\n      this.list = this.list.splice(0, this.index + 1);\n\n      // We need to cleanup the old subscriptions.\n      for (const { subscription } of oldList) {\n        subscription.unsubscribe();\n      }\n\n      // This is the only place we need to subscribe. We do not need to\n      // subscribe to individual object that are in undo groups because the\n      // groups forward events that happen on their inner objects. Also, a group\n      // need not be subscribed to until ``record`` is called for it.\n      this.list.push({\n        undo: obj,\n        subscription: obj.events.subscribe(this._events),\n      });\n      this.index++;\n    }\n  }\n\n  /**\n   * Undoes the latest [[Undo]] that was recorded. If any [[UndoGroup]] objects\n   * were in effect when called, they are terminated. It is an error to call\n   * this method or [[redo]] from within this method. Does nothing if there is\n   * nothing to undo.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  undo(): void {\n    // If undo is invoked in the middle of a group, we must end it first.\n    if (this._undoingOrRedoing) {\n      throw new Error(\"calling undo while undoing or redoing\");\n    }\n    this._undoingOrRedoing = true;\n    while (this.stack.length > 0) {\n      this.endGroup();\n    }\n    if (this.index >= 0) {\n      this.list[this.index--].undo.undo();\n    }\n    this._undoingOrRedoing = false;\n  }\n\n  /**\n   * Redoes the latest [[Undo]] object that was undone.  It is an error to call\n   * this method or [[undo]] from within this method. Does nothing if there is\n   * nothing to redo.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  redo(): void {\n    if (this._undoingOrRedoing) {\n      throw new Error(\"calling redo while undoing or redoing\");\n    }\n    this._undoingOrRedoing = true;\n    if (this.index < this.list.length - 1) {\n      this.list[++this.index].undo.redo();\n    }\n    this._undoingOrRedoing = false;\n  }\n\n  /**\n   * @returns True if the object is in the midst of undoing or redoing, false\n   * otherwise.\n   */\n  undoingOrRedoing(): boolean {\n    return this._undoingOrRedoing;\n  }\n\n  /**\n   * @returns True if there is something to undo, false otherwise.\n   */\n  canUndo(): boolean {\n    // If there is a group on the stack, then we have to return true. That's\n    // because when the group is ended when undo() is called, it will be added\n    // at the end of this.list.\n    return this.index > -1 || this.stack.length > 0;\n  }\n\n  /**\n   * @returns True if there is something to redo, false otherwise.\n   */\n  canRedo(): boolean {\n    return this.index < this.list.length - 1;\n  }\n\n  /**\n   * Starts recording a group of undo operations.\n   *\n   * @param group The undo group to start.\n   */\n  startGroup(group: UndoGroup): void {\n    this.stack.unshift(group);\n  }\n\n  /**\n   * Ends recording a group of undo operations. The group currently in effect is\n   * terminated, and made the last recorded operation (as if it had been passed\n   * to [[UndoList.record]]).\n   *\n   * @throws {Error} If there is no current undo group.\n   */\n  endGroup(): void {\n    const group = this.stack.shift();\n    if (group === undefined) {\n      throw new Error(\"ending a non-existent group.\");\n    }\n    group.end();\n    this.record(group);\n  }\n\n  /**\n   * Ends all groups currently in effect. This is the same as calling\n   * [[endGroup]] repeatedly until there are no more groups to end.\n   */\n  endAllGroups(): void {\n    while (this.stack.length > 0) {\n      this.endGroup();\n    }\n  }\n\n  /**\n   * @returns The group currently being recorded.\n   */\n  getGroup(): UndoGroup {\n    return this.stack[0];\n  }\n\n  /**\n   * @returns A string showing all the undo steps and undo groups stored in this\n   * undo list.\n   */\n  toString(): string {\n    const ret = [];\n    ret.push(\"Start of list\\n\");\n    for (const it of this.list) {\n      ret.push(it.toString());\n    }\n    ret.push(\"End of list\\n\");\n    ret.push(\"Unfinished groups:\\n\");\n    for (let i = this.stack.length - 1; i >= 0; --i) {\n      const it = this.stack[i];\n      ret.push(it.toString());\n    }\n    ret.push(\"End of unfinished groups\\n\");\n    return ret.join(\"\");\n  }\n}\n\n/**\n * An undo operation.\n * @param {string} desc The description of this undo operation.\n */\nexport abstract class Undo {\n  protected readonly _events: Subject<UndoEvents> = new Subject();\n\n  readonly events: Observable<UndoEvents> = this._events.asObservable();\n\n  constructor(public readonly desc: string) {}\n\n  /**\n   * Called when the operation must be undone.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  undo(): void {\n    this.performUndo();\n    this._events.next({\n      name: \"Undo\",\n      undo: this,\n    });\n  }\n\n  /**\n   * This is the function that performs the specific operations required by this\n   * undo object, when undoing.\n   */\n  protected abstract performUndo(): void;\n\n  /**\n   * Called when the operation must be redone.\n   *\n   * @throws {Error} If an undo is attempted when an undo or redo is already in\n   * progress.\n   */\n  redo(): void {\n    this.performRedo();\n    this._events.next({\n      name: \"Redo\",\n      undo: this,\n    });\n  }\n\n  /**\n   * This is the function that performs the specific operations required by this\n   * undo object, when redoing.\n   */\n  protected abstract performRedo(): void;\n\n  /**\n   * @returns The description of this object.\n   */\n  toString(): string {\n    return `${this.desc}\\n`;\n  }\n}\n\n/**\n * A group of undo operations.\n */\nexport class UndoGroup extends Undo {\n  protected readonly list: Undo[] = [];\n\n  /**\n   * Undoes this group, which means undoing all the operations that this group\n   * has recorded.\n   */\n  performUndo(): void {\n    for (let i = this.list.length - 1; i >= 0; --i) {\n      this.list[i].undo();\n    }\n  }\n\n  /**\n   * Redoes this group, which means redoing all the operations that this group\n   * has recorded.\n   */\n  performRedo(): void {\n    for (const it of this.list) {\n      it.redo();\n    }\n  }\n\n  /**\n   * Records an operation as part of this group.\n   *\n   * @param obj The operation to record.\n   */\n  record(obj: Undo): void {\n    this.list.push(obj);\n    // We need to forward the events onto this object.\n    obj.events.subscribe(this._events);\n  }\n\n  /**\n   * This method is called by [[UndoList.endGroup]] when it ends a group. The\n   * default implementation does nothing.\n   */\n  end(): void {\n    // by default we do nothing\n  }\n\n  toString(): string {\n    const ret = [];\n    ret.push(`Start of ${this.desc}\\n`);\n    for (const it of this.list) {\n      ret.push(it.toString().replace(/(^|\\n)/g, \"$1 \").slice(0, -1));\n    }\n    ret.push(`End of ${this.desc}\\n`);\n    return ret.join(\"\");\n  }\n}\n\n/**\n * This is an undo object which does nothing but only serves as a marker in the\n * list of undo operations. It could be used for debugging or by modes to record\n * information they need in the undo list.\n */\nexport class UndoMarker extends Undo {\n  /**\n   * @param msg A message to identify the marker.\n   */\n  constructor(msg: string) {\n    super(`*** MARKER *** ${msg}`);\n  }\n\n  // tslint:disable-next-line:no-empty\n  performUndo(): void {}\n  // tslint:disable-next-line:no-empty\n  performRedo(): void {}\n}\n\n//  LocalWords:  boolean Dubeau MPL Mangalam UndoList desc\n"]}