{"version":3,"sources":["../../../wed/wed-options-validation.ts"],"names":[],"mappings":";;;IAeA,IAAI,oBAA0C,CAAC;IAE/C;QACE,EAAE,CAAC,CAAC,oBAAoB,KAAK,SAAS,CAAC,CAAC,CAAC;YACrC,oBAAoB,GAAG,IAAI,GAAG,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;QAC/D,CAAC;QAED,MAAM,CAAC,oBAAoB,CAAC;IAC9B,CAAC;IAED;;;;;;;OAOG;IACH,2BAAkC,OAAmB;QAEnD,IAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,IAAM,UAAU,GAAG,YAAY,EAAE,CAAC;QAClC,IAAM,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;QAClC,EAAE,CAAC,CAAC,CAAE,KAAiB,CAAC,CAAC,CAAC;YACxB,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;gBACpC,GAAG,CAAC,CAAgB,UAAiB,EAAjB,KAAA,UAAU,CAAC,MAAM,EAAjB,cAAiB,EAAjB,IAAiB;oBAAhC,IAAM,KAAK,SAAA;oBACd,MAAM,CAAC,IAAI,CAAI,KAAK,CAAC,QAAQ,SAAI,KAAK,CAAC,OAAS,CAAC,CAAC;iBACnD;YACH,CAAC;YAED,MAAM,CAAC,MAAM,CAAC;QAChB,CAAC;QAED,IAAM,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC;QAErC,IAAM,OAAO,GAAG,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC;QAE7C,yCAAyC;QACzC,EAAE,CAAC,CAAC,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC,kDAAkD,CAAC,CAAC;QAClE,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC,CAAC;YACrC,OAAO,CAAC,UAAU,GAAG,MAAM,CAAC;QAC9B,CAAC;QAED,8CAA8C;QAC9C,EAAE,CAAC,CAAC,OAAO,OAAO,CAAC,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC;YAC3C,IAAM,GAAG,GAAG,OAAO,CAAC,UAAU,CAAC;YAC/B,yEAAyE;YACzE,0CAA0C;YAC1C,OAAO,CAAC,UAAU,GAAG;gBACnB,QAAQ,EAAE,GAAG;aAC0C,CAAC;QAC5D,CAAC;QAED,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,MAAM,CAAC;QAChB,CAAC;QAED,MAAM,CAAC,OAA4B,CAAC;IACtC,CAAC;IA5CD,8CA4CC;;AAED,oBAAoB","file":"wed-options-validation.js","sourcesContent":["/**\n * Validate wed options.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport * as Ajv from \"ajv\";\n\nimport { ComplexAttributesSpec, WedOptions } from \"./wed-options\";\nimport * as wedOptionsSchema from \"./wed-options-schema.json\";\n\nexport interface CleanedWedOptions extends WedOptions {\n  attributes: ComplexAttributesSpec;\n}\n\nlet _wedOptionsValidator: Ajv.ValidateFunction;\n\nfunction getValidator(): Ajv.ValidateFunction {\n  if (_wedOptionsValidator === undefined) {\n      _wedOptionsValidator = new Ajv().compile(wedOptionsSchema);\n  }\n\n  return _wedOptionsValidator;\n}\n\n/**\n * Validates and normalizes the options to a specific format.\n *\n * @param options The raw options obtained from the mode.\n *\n * @returns The cleaned options if successful. If there were error the return\n * value is an array of error messages.\n */\nexport function processWedOptions(options: WedOptions):\nCleanedWedOptions | string[] {\n  const errors: string[] = [];\n\n  const ovalidator = getValidator();\n  const valid = ovalidator(options);\n  if (!(valid as boolean)) {\n    if (ovalidator.errors !== undefined) {\n      for (const error of ovalidator.errors) {\n        errors.push(`${error.dataPath} ${error.message}`);\n      }\n    }\n\n    return errors;\n  }\n\n  const max = options.label_levels.max;\n\n  const initial = options.label_levels.initial;\n\n  // We cannot validate this with a schema.\n  if (initial > max) {\n    errors.push(\"label_levels.initial must be <= label_levels.max\");\n  }\n\n  if (options.attributes === undefined) {\n    options.attributes = \"hide\";\n  }\n\n  // Normalize the format of options.attributes.\n  if (typeof options.attributes === \"string\") {\n    const tmp = options.attributes;\n    // We need the type cast at the end because otherwise TS infers a type of\n    // { handling: \"hide\" | \"show\" | \"edit\" }.\n    options.attributes = {\n      handling: tmp,\n    } as { handling: \"hide\" } | { handling: \"show\" | \"edit\" };\n  }\n\n  if (errors.length !== 0) {\n    return errors;\n  }\n\n  return options as CleanedWedOptions;\n}\n\n//  LocalWords:  MPL\n"]}