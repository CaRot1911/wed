{"version":3,"file":"wed-options-validation.js","sourceRoot":"","sources":["../../../../lib/wed/wed-options-validation.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;IAeA,IAAI,oBAA0C,CAAC;IAE/C;QACE,IAAI,oBAAoB,KAAK,SAAS,EAAE;YACpC,oBAAoB,GAAG,IAAI,aAAG,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;SAC9D;QAED,OAAO,oBAAoB,CAAC;IAC9B,CAAC;IAED;;;;;;;OAOG;IACH,2BAAkC,OAAmB;QAEnD,IAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,IAAM,UAAU,GAAG,YAAY,EAAE,CAAC;QAClC,IAAM,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;QAClC,IAAI,CAAE,KAAiB,EAAE;YACvB,IAAI,UAAU,CAAC,MAAM,IAAI,IAAI,EAAE;gBAC7B,KAAoB,UAAiB,EAAjB,KAAA,UAAU,CAAC,MAAM,EAAjB,cAAiB,EAAjB,IAAiB;oBAAhC,IAAM,KAAK,SAAA;oBACd,MAAM,CAAC,IAAI,CAAI,KAAK,CAAC,QAAQ,SAAI,KAAK,CAAC,OAAS,CAAC,CAAC;iBACnD;aACF;YAED,OAAO,MAAM,CAAC;SACf;QAED,IAAM,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC;QAErC,IAAM,OAAO,GAAG,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC;QAE7C,yCAAyC;QACzC,IAAI,OAAO,GAAG,GAAG,EAAE;YACjB,MAAM,CAAC,IAAI,CAAC,kDAAkD,CAAC,CAAC;SACjE;QAED,IAAI,OAAO,CAAC,UAAU,KAAK,SAAS,EAAE;YACpC,OAAO,CAAC,UAAU,GAAG,MAAM,CAAC;SAC7B;QAED,8CAA8C;QAC9C,IAAI,OAAO,OAAO,CAAC,UAAU,KAAK,QAAQ,EAAE;YAC1C,IAAM,GAAG,GAAG,OAAO,CAAC,UAAU,CAAC;YAC/B,yEAAyE;YACzE,0CAA0C;YAC1C,4DAA4D;YAC5D,OAAO,CAAC,UAAU,GAAG;gBACnB,QAAQ,EAAE,GAAG;aAC0C,CAAC;SAC3D;QAED,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,MAAM,CAAC;SACf;QAED,OAAO,OAA4B,CAAC;IACtC,CAAC;IA7CD,8CA6CC;;AAED,oBAAoB","sourcesContent":["/**\n * Validate wed options.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport Ajv from \"ajv\";\n\nimport { ComplexAttributesSpec, WedOptions } from \"./wed-options\";\nimport * as wedOptionsSchema from \"./wed-options-schema.json\";\n\nexport interface CleanedWedOptions extends WedOptions {\n  attributes: ComplexAttributesSpec;\n}\n\nlet _wedOptionsValidator: Ajv.ValidateFunction;\n\nfunction getValidator(): Ajv.ValidateFunction {\n  if (_wedOptionsValidator === undefined) {\n      _wedOptionsValidator = new Ajv().compile(wedOptionsSchema);\n  }\n\n  return _wedOptionsValidator;\n}\n\n/**\n * Validates and normalizes the options to a specific format.\n *\n * @param options The raw options obtained from the mode.\n *\n * @returns The cleaned options if successful. If there were error the return\n * value is an array of error messages.\n */\nexport function processWedOptions(options: WedOptions):\nCleanedWedOptions | string[] {\n  const errors: string[] = [];\n\n  const ovalidator = getValidator();\n  const valid = ovalidator(options);\n  if (!(valid as boolean)) {\n    if (ovalidator.errors != null) {\n      for (const error of ovalidator.errors) {\n        errors.push(`${error.dataPath} ${error.message}`);\n      }\n    }\n\n    return errors;\n  }\n\n  const max = options.label_levels.max;\n\n  const initial = options.label_levels.initial;\n\n  // We cannot validate this with a schema.\n  if (initial > max) {\n    errors.push(\"label_levels.initial must be <= label_levels.max\");\n  }\n\n  if (options.attributes === undefined) {\n    options.attributes = \"hide\";\n  }\n\n  // Normalize the format of options.attributes.\n  if (typeof options.attributes === \"string\") {\n    const tmp = options.attributes;\n    // We need the type cast at the end because otherwise TS infers a type of\n    // { handling: \"hide\" | \"show\" | \"edit\" }.\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    options.attributes = {\n      handling: tmp,\n    } as { handling: \"hide\" } | { handling: \"show\" | \"edit\" };\n  }\n\n  if (errors.length !== 0) {\n    return errors;\n  }\n\n  return options as CleanedWedOptions;\n}\n\n//  LocalWords:  MPL\n"]}