{"version":3,"file":"tree-updater.js","sourceRoot":"","sources":["../../../../lib/wed/tree-updater.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;;;;;;;;;;;;;;;;;IAQH,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IA2EhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAoCG;IACH;QAKE;;WAEG;QACH,qBAA+B,IAAwB;YAAxB,SAAI,GAAJ,IAAI,CAAoB;YACrD,IAAM,IAAI,GAAG,eAAQ,CAAC,IAAI,CAAC,CAAC;YAC5B,IAAI,IAAI,KAAK,SAAS,EAAE;gBACtB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;aAClD;YAED,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,OAAO,GAAG,IAAI,cAAO,EAAE,CAAC;YAE7B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QAC5C,CAAC;QAES,2BAAK,GAAf,UAAgB,KAAwB;YACtC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,SAAS,EAAC,CAAC,CAAC;QACvC,CAAC;QAqBD,8BAAQ,GAAR,UAAS,GAAgB,EAAE,MAA2B,EAC7C,IAAiB;YACxB,IAAI,MAAY,CAAC;YACjB,IAAI,KAAa,CAAC;YAClB,IAAI,GAAG,YAAY,WAAI,EAAE;gBACvB,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC;gBAClB,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC;gBACnB,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;oBAC9B,MAAM,IAAI,KAAK,CACb,uDAAuD,CAAC,CAAC;iBAC5D;gBACD,IAAI,GAAG,MAAM,CAAC;aACf;iBACI;gBACH,MAAM,GAAG,GAAG,CAAC;gBACb,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;oBAC9B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;iBACxE;gBACD,KAAK,GAAG,MAAM,CAAC;aAChB;YAED,IAAI,IAAI,YAAY,KAAK,IAAI,IAAI,YAAY,QAAQ,EAAE;gBACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,EAAE,KAAK,EAAE;oBAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;oBACrB,IAAI,CAAC,CAAC,OAAO,IAAI,KAAK,QAAQ,IAAI,yBAAS,CAAC,IAAI,CAAC,IAAI,sBAAM,CAAC,IAAI,CAAC,CAAC,EAAE;wBAClE,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;qBAChE;oBACD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;iBACpC;aACF;iBACI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;gBACjC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;aACtC;iBACI,IAAI,sBAAM,CAAC,IAAI,CAAC,EAAE;gBACrB,QAAQ,MAAM,CAAC,QAAQ,EAAE;oBACzB,KAAK,IAAI,CAAC,SAAS;wBACjB,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;wBAC1C,MAAM;oBACR,KAAK,IAAI,CAAC,YAAY;wBACpB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;wBACvC,MAAM;oBACR;wBACE,MAAM,IAAI,KAAK,CAAC,2BAAyB,MAAM,CAAC,QAAU,CAAC,CAAC;iBAC7D;aACF;iBACI,IAAI,yBAAS,CAAC,IAAI,CAAC,EAAE;gBACxB,QAAQ,MAAM,CAAC,QAAQ,EAAE;oBACzB,KAAK,IAAI,CAAC,SAAS;wBACjB,IAAI,CAAC,cAAc,CAAC,MAAc,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;wBACjD,MAAM;oBACR,KAAK,IAAI,CAAC,aAAa,CAAC;oBACxB,KAAK,IAAI,CAAC,YAAY;wBACpB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;wBACvC,MAAM;oBACR;wBACE,MAAM,IAAI,KAAK,CAAC,2BAAyB,MAAM,CAAC,QAAU,CAAC,CAAC;iBAE7D;aACF;iBACI;gBACH,MAAM,IAAI,KAAK,CAAC,gCAA8B,IAAM,CAAC,CAAC;aACvD;QACH,CAAC;QAuBD,6BAAO,GAAP,UAAQ,GAAS,EAAE,GAAgB,EAAE,KAAc;YACjD,IAAI,IAAI,CAAC;YACT,IAAI,GAAG,YAAY,WAAI,EAAE;gBACvB,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;gBAChB,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC;aACpB;iBACI;gBACH,IAAI,GAAG,GAAG,CAAC;aACZ;YAED,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;aAC5D;YAED,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,SAAS,EAAE;gBACpD,MAAM,IAAI,KAAK,CAAC,+CAA+C;oBAC/C,yBAAyB,CAAC,CAAC;aAC5C;YAED,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACvB,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;aACrD;YAED,IAAM,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YACtC,IAAM,UAAU,GAAG,OAAO,CAAC,iBAAiB,CAAC,GAAG,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;YAEnE,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;YACjD,IAAA,eAAK,EAAE,gBAAM,CAAU;YAE/B,IAAM,MAAM,GAAG,GAAG,CAAC,UAAU,CAAC;YAC9B,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;aAC7C;YACD,IAAM,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;YAC3C,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAErB,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;aACtC;YAED,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;aAC3C;YACD,OAAO,IAAI,CAAC;QACd,CAAC;QAED;;;;;;;;;;;;WAYG;QACO,8BAAQ,GAAlB,UAAmB,GAAS,EAAE,IAAU,EAAE,KAAa;YACrD,0EAA0E;YAC1E,qBAAqB;YACrB,IAAM,IAAI,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC;YAE5B,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;YAC/B,IAAI,GAAgB,CAAC;YACrB,IAAI,sBAAM,CAAC,IAAI,CAAC,EAAE;gBAChB,IAAI,KAAK,KAAK,CAAC,EAAE;oBACf,GAAG,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;iBACpB;qBACI,IAAI,KAAK,KAAK,IAAI,CAAC,MAAM,EAAE;oBAC9B,GAAG,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;iBACpB;qBACI;oBACH,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBACzC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;oBAC5C,IAAI,MAAM,KAAK,IAAI,EAAE;wBACnB,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,aAAa,CAAC,cAAc,CAAC,SAAS,CAAC,EAC9C,IAAI,CAAC,WAAW,CAAC,CAAC;qBACvC;oBACD,GAAG,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;iBAChC;aACF;iBACI,IAAI,yBAAS,CAAC,IAAI,CAAC,EAAE;gBACxB,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,KAAK,GAAG,CAAC,CAAC;iBACX;qBACI,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;oBACvC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;iBAChC;gBAED,IAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBACnC,uCAAuC;gBACvC,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE;oBACrC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC1C;gBAED,gCAAgC;gBAChC,OAAO,KAAK,EAAE,KAAK,CAAC,EAAE;oBACpB,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,UAAW,CAAC,CAAC;iBACtC;gBAED,IAAI,MAAM,KAAK,IAAI,EAAE;oBACnB,MAAM,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;iBAC9C;gBAED,GAAG,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACrB;iBACI;gBACH,MAAM,IAAI,KAAK,CAAC,2BAAyB,IAAI,CAAC,QAAU,CAAC,CAAC;aAC3D;YAED,IAAI,IAAI,EAAE,EAAE,2CAA2C;gBACrD,OAAO,GAAG,CAAC;aACZ;YAED,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;aAC5C;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAC1E,CAAC;QAED;;;;;;;;;;;;WAYG;QACH,kCAAY,GAAZ,UAAa,MAAe,EAAE,QAAwB,EACzC,UAAuB;YAClC,uCAAuC;YACvC,IAAM,KAAK,GAAG,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBAC3D,OAAO,CAAC,MAAM,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YACzC,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;gBAChB,MAAM,IAAI,KAAK,CAAC,8CAA8C;oBAC9C,gCAAgC,CAAC,CAAC;aACnD;YACD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzC,CAAC;QA0BD,gCAAU,GAAV,UAAW,GAAgB,EAAE,KAAsB,EACxC,IAA6B,EAC7B,UAA0B;YAD1B,qBAAA,EAAA,WAA6B;YAC7B,2BAAA,EAAA,iBAA0B;YACnC,IAAI,IAAI,CAAC;YACT,IAAI,GAAG,YAAY,WAAI,EAAE;gBACvB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;oBAC7B,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;iBAC1C;gBAED,IAAI,OAAO,IAAI,KAAK,SAAS,EAAE;oBAC7B,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;iBACjD;gBAED,UAAU,GAAG,IAAI,CAAC;gBAClB,IAAI,GAAG,KAAK,CAAC;gBACb,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;gBAChB,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC;aACpB;iBACI;gBACH,IAAI,GAAG,GAAG,CAAC;aACZ;YAED,IAAM,MAAM,GAAG,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EACvB,UAAU,CAAC,CAAC;YAE1D,oBACK,MAAM,IACT,KAAK,EAAE,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IACrC;QACJ,CAAC;QAgBD,gCAAU,GAAV,UAAW,GAAgB,EAAE,KAAa,EAAE,MAAe;YACzD,IAAI,IAAI,CAAC;YACT,IAAI,GAAG,YAAY,WAAI,EAAE;gBACvB,MAAM,GAAG,KAAK,CAAC;gBACf,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;gBAChB,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC;aACpB;iBACI;gBACH,IAAI,GAAG,GAAG,CAAC;gBACX,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;iBAC/C;aACF;YAED,IAAI,CAAC,sBAAM,CAAC,IAAI,CAAC,EAAE;gBACjB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;aAClD;YAED,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC;gBAC/B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC;QACpD,CAAC;QA4BD,oCAAc,GAAd,UAAe,GAAgB,EAAE,KAAoB,EACtC,IAAW;YACxB,IAAI,MAAM,CAAC;YACX,IAAI,GAAG,YAAY,WAAI,EAAE;gBACvB,IAAI,CAAC,sBAAM,CAAC,KAAK,CAAC,EAAE;oBAClB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;iBACzD;gBACD,IAAI,GAAG,KAAK,CAAC;gBACb,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC;gBACnB,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC;aACnB;iBACI;gBACH,MAAM,GAAG,GAAG,CAAC;aACd;YACD,IAAM,GAAG,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAC1E,OAAO,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBACpC,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,CAAC;QAkBD,kCAAY,GAAZ,UAAa,GAAgB,EAAE,KAAoB,EAAE,IAAW;YAC9D,IAAI,MAAM,CAAC;YACX,IAAI,GAAG,YAAY,WAAI,EAAE;gBACvB,IAAI,CAAC,sBAAM,CAAC,KAAK,CAAC,EAAE;oBAClB,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;iBACpD;gBACD,IAAI,GAAG,KAAK,CAAC;gBACb,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC;gBACnB,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC;aACnB;iBACI;gBACH,MAAM,GAAG,GAAG,CAAC;gBACb,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;oBAC7B,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;iBAC3C;aACF;YAED,IAAI,IAAI,IAAI,IAAI,EAAE;gBAChB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;aACzD;YAED,IAAI,kCAAkB,CAAC,IAAI,CAAC,EAAE;gBAC5B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;aACxE;YAED,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,oBAAoB,EAAE,MAAM,QAAA,EAAE,KAAK,OAAA,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;YAChE,IAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACvC,MAAM,CAAC,YAAY,CAAC,IAAI,EAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YACzD,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,cAAc,EAAE,MAAM,QAAA,EAAE,KAAK,OAAA,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;QAC5D,CAAC;QAED;;;;;;;;WAQG;QACH,iCAAW,GAAX,UAAY,IAAU,EAAE,KAAa;YACnC,IAAI,CAAC,sBAAM,CAAC,IAAI,CAAC,EAAE;gBACjB,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;aACnD;YAED,IAAI,KAAK,KAAK,EAAE,EAAE;gBAChB,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACpC;iBACI;gBACH,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;aACvB;QACH,CAAC;QAED;;;;;;;;;;;;;;;WAeG;QACH,sCAAgB,GAAhB,UAAiB,IAAU,EAAE,KAAa;YACxC,IAAI,CAAC,sBAAM,CAAC,IAAI,CAAC,EAAE;gBACjB,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;aACxD;YAED,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;YAC3B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;YAClB,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,kBAAkB,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAE,QAAQ,UAAA,EAAE,CAAC,CAAC;QAClE,CAAC;QAED;;;;;;;;;;;WAWG;QACH,gCAAU,GAAV,UAAW,IAA6B;YACtC,IAAI,IAAI,IAAI,IAAI,EAAE;gBAChB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;aAChD;YACD,IAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC;YAClC,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;YAE/B,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAC9C;YAED,IAAM,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YAC5C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YACtB,IAAI,IAAI,KAAK,IAAI,EAAE;gBACjB,OAAO,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;aACjD;YACD,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAED;;;;;;;;;;WAUG;QACH,kCAAY,GAAZ,UAAa,IAA6B;YACxC,IAAI,IAAI,IAAI,IAAI,EAAE;gBAChB,OAAO,SAAS,CAAC;aAClB;YAED,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC/B,CAAC;QAED;;;;;;;;;;;;WAYG;QACH,iCAAW,GAAX,UAAY,KAAa;YACvB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;gBACtB,OAAO,SAAS,CAAC;aAClB;YACD,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC;YACtC,IAAM,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;YAEnC,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAC9C;YAED,IAAM,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBACrC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACjE,MAAM,IAAI,KAAK,CAAC,0CAA0C;wBAC1C,gBAAgB,CAAC,CAAC;iBACnC;gBACD,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;aAC3B;YAED,IAAI,IAAI,KAAK,IAAI,EAAE;gBACjB,OAAO,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;aAC7C;YACD,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAED;;;;;;;;;;;;;WAaG;QACH,yBAAG,GAAH,UAAI,KAAW,EAAE,GAAS;YACxB,IAAM,GAAG,GAAG,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,EACJ,KAAK,CAAC,OAAO,EAAE,EAAE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC5E,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5B,OAAO,GAAG,CAAC;QACb,CAAC;QAED;;;;;;;;;;;WAWG;QACH,oCAAc,GAAd,UAAe,IAAU;YACvB,IAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;YAC9B,IAAI,sBAAM,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,IAAI,IAAI,sBAAM,CAAC,IAAI,CAAC,EAAE;gBACjD,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;gBAC3B,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;gBACnD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBACtB,OAAO,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;aACnD;YAED,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;YAC/B,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAC9C;YAED,OAAO,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EACjB,OAAO,CAAC,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACjE,CAAC;QAED;;;;;;;;;;WAUG;QACH,sCAAgB,GAAhB,UAAiB,IAA6B;YAC5C,IAAI,IAAI,IAAI,IAAI,EAAE;gBAChB,OAAO,SAAS,CAAC;aAClB;YACD,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAED;;;;;;;;;;;;;WAaG;QACH,gCAAU,GAAV,UAAW,IAAU;YACnB,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,kBAAkB,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;YACrD,yEAAyE;YACzE,gBAAgB;YAChB,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;YAC/B,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAC9C;YAED,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YACzB,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,MAAA,EAAE,YAAY,EAAE,MAAM,EAAE,CAAC,CAAC;QACjE,CAAC;QAED;;;;;;;;;;;;;WAaG;QACH,kCAAY,GAAZ,UAAa,IAAa,EAAE,SAAiB,EAChC,KAAgC;YAC3C,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,EAAE,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC;QAED;;;;;;;;;;;;;;WAcG;QACH,oCAAc,GAAd,UAAe,IAAa,EAAE,EAAU,EAAE,SAAiB,EAC5C,KAAgC;YAC7C,qBAAqB;YACrB,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,KAAK,GAAG,IAAI,CAAC;aACd;YAED,IAAI,CAAC,yBAAS,CAAC,IAAI,CAAC,EAAE;gBACpB,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;aACvD;YAED,IAAI,QAAQ,GAAkB,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;YACjE,wEAAwE;YACxE,aAAa;YACb,IAAI,QAAQ,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,SAAS,CAAC,EAAE;gBAC1D,QAAQ,GAAG,IAAI,CAAC;aACjB;YAED,IAAI,KAAK,IAAI,IAAI,EAAE;gBACjB,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;aAC3C;iBACI;gBACH,IAAI,CAAC,iBAAiB,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;aACvC;YAED,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,gBAAgB,EAAE,IAAI,MAAA,EAAE,EAAE,IAAA,EAAE,SAAS,WAAA,EAAE,QAAQ,UAAA;gBACrD,QAAQ,EAAE,KAAK,EAAE,CAAC,CAAC;QAClC,CAAC;QAED;;;;;;;WAOG;QACH,gCAAU,GAAV,UAAW,IAAU;YACnB,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;QAED;;;;;;WAMG;QACH,gCAAU,GAAV,UAAW,IAAY;YACrB,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;QACH,kBAAC;IAAD,CAAC,AA3wBD,IA2wBC;IA3wBY,kCAAW;;AA6wBxB,+EAA+E;AAC/E,+EAA+E;AAC/E,+EAA+E;AAC/E,8EAA8E;AAC9E,6EAA6E;AAC7E,4EAA4E;AAC5E,2BAA2B","sourcesContent":["/**\n * Facility for updating a DOM tree and issue synchronous events on changes.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { Observable, Subject } from \"rxjs\";\n\nimport { DLoc, DLocRoot, findRoot } from \"./dloc\";\nimport { isDocumentFragment, isElement, isNode, isText } from \"./domtypeguards\";\nimport * as domutil from \"./domutil\";\n\nconst indexOf = domutil.indexOf;\n\nexport interface TreeUpdaterEvent {\n  name: string;\n}\n\nexport interface ChangedEvent extends TreeUpdaterEvent {\n  name: \"Changed\";\n}\n\nexport interface BeforeInsertNodeAtEvent extends TreeUpdaterEvent {\n  name: \"BeforeInsertNodeAt\";\n  parent: Node;\n  index: number;\n  node: Node;\n}\n\nexport interface InsertNodeAtEvent extends TreeUpdaterEvent {\n  name: \"InsertNodeAt\";\n  parent: Node;\n  index: number;\n  node: Node;\n}\n\nexport interface SetTextNodeValueEvent extends TreeUpdaterEvent {\n  name: \"SetTextNodeValue\";\n  node: Text;\n  value: string;\n  oldValue: string;\n}\n\nexport interface BeforeDeleteNodeEvent extends TreeUpdaterEvent {\n  name: \"BeforeDeleteNode\";\n  node: Node;\n}\n\nexport interface DeleteNodeEvent extends TreeUpdaterEvent {\n  name: \"DeleteNode\";\n  node: Node;\n  formerParent: Node;\n}\n\nexport interface SetAttributeNSEvent extends TreeUpdaterEvent {\n  name: \"SetAttributeNS\";\n  node: Element;\n  ns: string;\n  attribute: string;\n  oldValue: string | null;\n  newValue: string | null;\n}\n\nexport type TreeUpdaterEvents = ChangedEvent | BeforeInsertNodeAtEvent |\n  InsertNodeAtEvent | SetTextNodeValueEvent | BeforeDeleteNodeEvent |\n  DeleteNodeEvent | SetAttributeNSEvent;\n\nexport type InsertableAtom = string | Element | Text;\nexport type Insertable = InsertableAtom | InsertableAtom[] | NodeList;\n\nexport type SplitResult = [Node | null, Node | null];\n\n/**\n * Records the results of inserting text into the tree.\n */\nexport interface TextInsertionResult {\n  /** The node that contains the added text. */\n  node: Text | undefined;\n\n  /** Whether [[node]] is a new node. If ``false``, it was modified. */\n  isNew: boolean;\n\n  /** The caret position after the insertion. */\n  caret: DLoc;\n}\nexport type InsertionBoundaries = [DLoc, DLoc];\n\n/**\n * A TreeUpdater is meant to serve as the sole point of modification for a DOM\n * tree. As methods are invoked on the TreeUpdater to modify the tree, events\n * are issued synchronously, which allows a listener to know what is happening\n * on the tree.\n *\n * Methods are divided into primitive and complex methods. Primitive methods\n * perform one and only one modification and issue an event of the same name as\n * their own name. Complex methods use primitive methods to perform a series of\n * modifications on the tree. Or they delegate the actual modification work to\n * the primitive methods. They may emit one or more events of a name different\n * from their own name. Events are emitted **after** their corresponding\n * operation is performed on the tree.\n *\n * For primitive methods, the list of events which they are documented to be\n * firing is exhaustive. For complex methods, the list is not exhaustive.\n *\n * Many events have a name identical to a corresponding method. Such events are\n * accompanied by event objects which have the same properties as the parameters\n * of the corresponding method, with the same meaning. Therefore, their\n * properties are not further documented.\n *\n * There is a generic [[ChangedEvent]] that is emitted with every other\n * event. This event does not carry information about what changed exactly.\n *\n * The [[TreeUpdater.deleteNode]] operation is the one major exception to the\n * basic rules given above:\n *\n * - [[BeforeDeleteNodeEvent]] is emitted **before** the deletion is\n * performed. This allows performing operations based on the node's location\n * before it is removed. For instance, calling the DOM method ``matches`` on a\n * node that has been removed from its DOM tree is generally going to fail to\n * perform the intended check.\n *\n * - [[DeleteNodeEvent]] has the additional ``formerParent`` property.\n *\n */\nexport class TreeUpdater {\n  protected readonly dlocRoot: DLocRoot;\n  protected readonly _events: Subject<TreeUpdaterEvents>;\n\n  public readonly events: Observable<TreeUpdaterEvents>;\n  /**\n   * @param tree The node which contains the tree to update.\n   */\n  constructor(protected readonly tree: Element | Document) {\n    const root = findRoot(tree);\n    if (root === undefined) {\n      throw new Error(\"the tree must have a DLocRoot\");\n    }\n\n    this.dlocRoot = root;\n    this._events = new Subject();\n\n    this.events = this._events.asObservable();\n  }\n\n  protected _emit(event: TreeUpdaterEvents): void {\n    this._events.next(event);\n    this._events.next({name: \"Changed\"});\n  }\n\n  /**\n   * A complex method. This is a convenience method that will call primitive\n   * methods to insert the specified item at the specified location. Note that\n   * this method returns nothing even if the primitives it uses return some\n   * information.\n   *\n   * @param loc The location where to insert.\n   *\n   * @param node The node where to insert. If ``loc`` is not used.\n   *\n   * @param offset The offset where to insert. If ``loc`` is not used.\n   *\n   * @param what The data to insert.\n   *\n   * @throws {Error} If ``loc`` is not in an element or text node or if\n   * ``what`` is not an element or text node.\n   */\n  insertAt(loc: DLoc, what: Insertable): void;\n  insertAt(node: Node, offset: number, what: Insertable): void;\n  insertAt(loc: DLoc | Node, offset: number | Insertable,\n           what?: Insertable): void {\n    let parent: Node;\n    let index: number;\n    if (loc instanceof DLoc) {\n      parent = loc.node;\n      index = loc.offset;\n      if (typeof offset === \"number\") {\n        throw new Error(\n          \"incorrect call on insertAt: offset cannot be a number\");\n      }\n      what = offset;\n    }\n    else {\n      parent = loc;\n      if (typeof offset !== \"number\") {\n        throw new Error(\"incorrect call on insertAt: offset must be a number\");\n      }\n      index = offset;\n    }\n\n    if (what instanceof Array || what instanceof NodeList) {\n      for (let i = 0; i < what.length; ++i, ++index) {\n        const item = what[i];\n        if (!(typeof item === \"string\" || isElement(item) || isText(item))) {\n          throw new Error(\"Array or NodeList element of the wrong type\");\n        }\n        this.insertAt(parent, index, item);\n      }\n    }\n    else if (typeof what === \"string\") {\n      this.insertText(parent, index, what);\n    }\n    else if (isText(what)) {\n      switch (parent.nodeType) {\n      case Node.TEXT_NODE:\n        this.insertText(parent, index, what.data);\n        break;\n      case Node.ELEMENT_NODE:\n        this.insertNodeAt(parent, index, what);\n        break;\n      default:\n        throw new Error(`unexpected node type: ${parent.nodeType}`);\n      }\n    }\n    else if (isElement(what)) {\n      switch (parent.nodeType) {\n      case Node.TEXT_NODE:\n        this.insertIntoText(parent as Text, index, what);\n        break;\n      case Node.DOCUMENT_NODE:\n      case Node.ELEMENT_NODE:\n        this.insertNodeAt(parent, index, what);\n        break;\n      default:\n        throw new Error(`unexpected node type: ${parent.nodeType}`);\n\n      }\n    }\n    else {\n      throw new Error(`unexpected value for what: ${what}`);\n    }\n  }\n\n  /**\n   * A complex method. Splits a DOM tree into two halves.\n   *\n   * @param top The node at which the splitting operation should end. This node\n   * will be split but the function won't split anything above this node.\n   *\n   * @param loc The location where to start the split.\n   *\n   * @param node The node at which to start the split, if ``loc`` is not used.\n   *\n   * @param index The index at which to start in the node, if ``loc`` is not\n   * used.\n   *\n   * @returns An array containing in order the first and second half of the\n   * split.\n   *\n   * @throws {Error} If the split location is not inside the top node or if the\n   * call would merely split a text node in two.\n   */\n  splitAt(top: Node, loc: DLoc): SplitResult;\n  splitAt(top: Node, node: Node, index: number): SplitResult;\n  splitAt(top: Node, loc: DLoc | Node, index?: number): SplitResult {\n    let node;\n    if (loc instanceof DLoc) {\n      node = loc.node;\n      index = loc.offset;\n    }\n    else {\n      node = loc;\n    }\n\n    if (index === undefined) {\n      throw new Error(\"splitAt was called with undefined index\");\n    }\n\n    if (node === top && node.nodeType === Node.TEXT_NODE) {\n      throw new Error(\"splitAt called in a way that would result in \" +\n                      \"two adjacent text nodes\");\n    }\n\n    if (!top.contains(node)) {\n      throw new Error(\"split location is not inside top\");\n    }\n\n    const clonedTop = top.cloneNode(true);\n    const clonedNode = domutil.correspondingNode(top, clonedTop, node);\n\n    const pair = this._splitAt(clonedTop, clonedNode, index);\n    const [ first, second ] = pair;\n\n    const parent = top.parentNode;\n    if (parent === null) {\n      throw new Error(\"called with detached top\");\n    }\n    const at = indexOf(parent.childNodes, top);\n    this.deleteNode(top);\n\n    if (first !== null) {\n      this.insertNodeAt(parent, at, first);\n    }\n\n    if (second !== null) {\n      this.insertNodeAt(parent, at + 1, second);\n    }\n    return pair;\n  }\n\n  /**\n   * Splits a DOM tree into two halves.\n   *\n   * @param top The node at which the splitting operation should end. This node\n   * will be split but the function won't split anything above this node.\n   *\n   * @param node The node at which to start.\n   *\n   * @param index The index at which to start in the node.\n   *\n   * @returns An array containing in order the first and second half of the\n   * split.\n   */\n  protected _splitAt(top: Node, node: Node, index: number): SplitResult {\n    // We need to check this now because some operations below may remove node\n    // from the DOM tree.\n    const stop = (node === top);\n\n    const parent = node.parentNode;\n    let ret: SplitResult;\n    if (isText(node)) {\n      if (index === 0) {\n        ret = [null, node];\n      }\n      else if (index === node.length) {\n        ret = [node, null];\n      }\n      else {\n        const textAfter = node.data.slice(index);\n        node.deleteData(index, node.length - index);\n        if (parent !== null) {\n          parent.insertBefore(parent.ownerDocument.createTextNode(textAfter),\n                              node.nextSibling);\n        }\n        ret = [node, node.nextSibling];\n      }\n    }\n    else if (isElement(node)) {\n      if (index < 0) {\n        index = 0;\n      }\n      else if (index > node.childNodes.length) {\n        index = node.childNodes.length;\n      }\n\n      const clone = node.cloneNode(true);\n      // Remove all nodes at index and after.\n      while (node.childNodes[index] != null) {\n        node.removeChild(node.childNodes[index]);\n      }\n\n      // Remove all nodes before index\n      while (index-- !== 0) {\n        clone.removeChild(clone.firstChild!);\n      }\n\n      if (parent !== null) {\n        parent.insertBefore(clone, node.nextSibling);\n      }\n\n      ret = [node, clone];\n    }\n    else {\n      throw new Error(`unexpected node type: ${node.nodeType}`);\n    }\n\n    if (stop) { // We've just split the top, so end here...\n      return ret;\n    }\n\n    if (parent === null) {\n      throw new Error(\"unable to reach the top\");\n    }\n\n    return this._splitAt(top, parent, indexOf(parent.childNodes, node) + 1);\n  }\n\n  /**\n   * A complex method. Inserts the specified item before another one. Note that\n   * the order of operands is the same as for the ``insertBefore`` DOM method.\n   *\n   * @param parent The node that contains the two other parameters.\n   *\n   * @param toInsert The node to insert.\n   *\n   * @param beforeThis The node in front of which to insert. A value of\n   * ``null`` results in appending to the parent node.\n   *\n   * @throws {Error} If ``beforeThis`` is not a child of ``parent``.\n   */\n  insertBefore(parent: Element, toInsert: Element | Text,\n               beforeThis: Node | null): void {\n    // Convert it to an insertAt operation.\n    const index = beforeThis == null ? parent.childNodes.length :\n      indexOf(parent.childNodes, beforeThis);\n    if (index === -1) {\n      throw new Error(\"insertBefore called with a beforeThis value \" +\n                      \"which is not a child of parent\");\n    }\n    this.insertAt(parent, index, toInsert);\n  }\n\n  /**\n   * A complex method. Inserts text into a node. This function will use already\n   * existing text nodes whenever possible rather than create a new text node.\n   *\n   * @param loc The location at which to insert the text.\n   *\n   * @param node The node at which to insert the text, if ``loc`` is not used.\n   *\n   * @param index The location in the node at which to insert the text, if\n   * ``loc`` is not used.\n   *\n   * @param text The text to insert.\n   *\n   * @param caretAtEnd Whether the returned caret should be at the end of the\n   * inserted text or the start. If not specified, the default is ``true``.\n   *\n   * @returns The result of inserting text.\n   *\n   * @throws {Error} If ``node`` is not an element or text Node type.\n   */\n  insertText(loc: DLoc, text: string,\n             caretAtEnd?: boolean): TextInsertionResult;\n  insertText(node: Node, index: number, text: string,\n             caretAtEnd?: boolean): TextInsertionResult;\n  insertText(loc: DLoc | Node, index: number | string,\n             text: string | boolean = true,\n             caretAtEnd: boolean = true): TextInsertionResult {\n    let node;\n    if (loc instanceof DLoc) {\n      if (typeof index !== \"string\") {\n        throw new Error(\"text must be a string\");\n      }\n\n      if (typeof text !== \"boolean\") {\n        throw new Error(\"caretAtEnd must be a boolean\");\n      }\n\n      caretAtEnd = text;\n      text = index;\n      node = loc.node;\n      index = loc.offset;\n    }\n    else {\n      node = loc;\n    }\n\n    const result = domutil.genericInsertText.call(this, node, index, text,\n                                                  caretAtEnd);\n\n    return {\n      ...result,\n      caret: DLoc.makeDLoc(this.dlocRoot, result.caret[0],\n                           result.caret[1]),\n    };\n  }\n\n  /**\n   * A complex method. Deletes text from a text node. If the text node becomes\n   * empty, it is deleted.\n   *\n   * @param loc Where to delete.\n   *\n   * @param node The text node from which to delete text.\n   *\n   * @param index The index at which to delete text.\n   *\n   * @param length The length of text to delete.\n   */\n  deleteText(loc: DLoc, length: number): void;\n  deleteText(node: Text, index: number, length: number): void;\n  deleteText(loc: DLoc | Text, index: number, length?: number): void {\n    let node;\n    if (loc instanceof DLoc) {\n      length = index;\n      node = loc.node;\n      index = loc.offset;\n    }\n    else {\n      node = loc;\n      if (length === undefined) {\n        throw new Error(\"length cannot be undefined\");\n      }\n    }\n\n    if (!isText(node)) {\n      throw new Error(\"deleteText called on non-text\");\n    }\n\n    this.setTextNode(node, node.data.slice(0, index) +\n                     node.data.slice(index + length));\n  }\n\n  /**\n   * A complex method. Inserts an element into text, effectively splitting the\n   * text node in two. This function takes care to modify the DOM tree only\n   * once.\n   *\n   * @param loc The location at which to cut.\n   *\n   * @param parent The text node that will be cut in two by the new element.\n   *\n   * @param index The offset into the text node where the new element is to be\n   * inserted.\n   *\n   * @param node The node to insert.\n   *\n   * @returns The first element of the array is a ``DLoc`` at the boundary\n   * between what comes before the material inserted and the material\n   * inserted. The second element of the array is a ``DLoc`` at the boundary\n   * between the material inserted and what comes after. If I insert \"foo\" at\n   * position 2 in \"abcd\", then the final result would be \"abfoocd\" and the\n   * first location would be the boundary between \"ab\" and \"foo\" and the second\n   * location the boundary between \"foo\" and \"cd\".\n   *\n   * @throws {Error} If the node to insert is undefined or null.\n   */\n  insertIntoText(loc: DLoc, node: Node): InsertionBoundaries;\n  insertIntoText(parent: Text, index: number, node: Node): InsertionBoundaries;\n  insertIntoText(loc: DLoc | Text, index: number | Node,\n                 node?: Node): InsertionBoundaries {\n    let parent;\n    if (loc instanceof DLoc) {\n      if (!isNode(index)) {\n        throw new Error(\"must pass a node as the 2nd argument\");\n      }\n      node = index;\n      index = loc.offset;\n      parent = loc.node;\n    }\n    else {\n      parent = loc;\n    }\n    const ret = domutil.genericInsertIntoText.call(this, parent, index, node);\n    return [DLoc.mustMakeDLoc(this.tree, ret[0]),\n            DLoc.mustMakeDLoc(this.tree, ret[1])];\n  }\n\n  /**\n   * A primitive method. Inserts a node at the specified position.\n   *\n   * @param loc The location at which to insert.\n   * @param node The node to insert.\n   * @param parent The node which will become the parent of the\n   * inserted node.\n   * @param index The position at which to insert the node\n   * into the parent.\n   *\n   * @emits InsertNodeAtEvent\n   * @emits ChangedEvent\n   * @throws {Error} If ``node`` is a document fragment Node type.\n   */\n  insertNodeAt(loc: DLoc, node: Node): void;\n  insertNodeAt(parent: Node, index: number, node: Node): void;\n  insertNodeAt(loc: DLoc | Node, index: number | Node, node?: Node): void {\n    let parent;\n    if (loc instanceof DLoc) {\n      if (!isNode(index)) {\n        throw new Error(\"the 2nd argument must be a Node\");\n      }\n      node = index;\n      index = loc.offset;\n      parent = loc.node;\n    }\n    else {\n      parent = loc;\n      if (typeof index !== \"number\") {\n        throw new Error(\"index must be a number\");\n      }\n    }\n\n    if (node == null) {\n      throw new Error(\"called insertNodeAt with absent node\");\n    }\n\n    if (isDocumentFragment(node)) {\n      throw new Error(\"document fragments cannot be passed to insertNodeAt\");\n    }\n\n    this._emit({ name: \"BeforeInsertNodeAt\", parent, index, node });\n    const child = parent.childNodes[index];\n    parent.insertBefore(node,  child != null ? child : null);\n    this._emit({ name: \"InsertNodeAt\", parent, index, node });\n  }\n\n  /**\n   * A complex method. Sets a text node to a specified value.\n   *\n   * @param node The node to modify.\n   *\n   * @param value The new value of the node.\n   *\n   * @throws {Error} If called on a non-text Node type.\n   */\n  setTextNode(node: Text, value: string): void {\n    if (!isText(node)) {\n      throw new Error(\"setTextNode called on non-text\");\n    }\n\n    if (value !== \"\") {\n      this.setTextNodeValue(node, value);\n    }\n    else {\n      this.deleteNode(node);\n    }\n  }\n\n  /**\n   * A primitive method. Sets a text node to a specified value. This method must\n   * not be called directly by code that performs changes of the DOM tree at a\n   * high level, because it does not prevent a text node from becoming\n   * empty. Call [[TreeUpdater.setTextNode]] instead. This method is meant to be\n   * used by other complex methods of TreeUpdater and by some low-level\n   * facilities of wed.\n   *\n   * @param node The node to modify. Must be a text node.\n   *\n   * @param value The new value of the node.\n   *\n   * @emits SetTextNodeValueEvent\n   * @emits ChangedEvent\n   * @throws {Error} If called on a non-text Node type.\n   */\n  setTextNodeValue(node: Text, value: string): void {\n    if (!isText(node)) {\n      throw new Error(\"setTextNodeValue called on non-text\");\n    }\n\n    const oldValue = node.data;\n    node.data = value;\n    this._emit({ name: \"SetTextNodeValue\", node, value, oldValue });\n  }\n\n  /**\n   * A complex method. Removes a node from the DOM tree. If two text nodes\n   * become adjacent, they are merged.\n   *\n   * @param node The node to remove. This method will fail with an exception if\n   * this parameter is ``undefined`` or ``null``. Use [[removeNodeNF]] if you\n   * want a method that will silently do nothing if ``undefined`` or ``null``\n   * are expected values.\n   *\n   * @returns A location between the two parts that were merged, or between the\n   * two nodes that were not merged (because they were not both text).\n   */\n  removeNode(node: Node | undefined | null): DLoc {\n    if (node == null) {\n      throw new Error(\"called without a node value\");\n    }\n    const prev = node.previousSibling;\n    const parent = node.parentNode;\n\n    if (parent === null) {\n      throw new Error(\"called with detached node\");\n    }\n\n    const ix = indexOf(parent.childNodes, node);\n    this.deleteNode(node);\n    if (prev === null) {\n      return DLoc.mustMakeDLoc(this.tree, parent, ix);\n    }\n    return this.mergeTextNodes(prev);\n  }\n\n  /**\n   * A complex method. Removes a node from the DOM tree. If two text nodes\n   * become adjacent, they are merged.\n   *\n   * @param node The node to remove. This method will do nothing if the node to\n   * remove is ``undefined`` or ``null``.\n   *\n   * @returns A location between the two parts that were merged, or between the\n   * two nodes that were not merged (because they were not both text). This will\n   * be ``undefined`` if there was no node to remove.\n   */\n  removeNodeNF(node: Node | undefined | null): DLoc | undefined {\n    if (node == null) {\n      return undefined;\n    }\n\n    return this.removeNode(node);\n  }\n\n  /**\n   * A complex method. Removes a list of nodes from the DOM tree. If two text\n   * nodes become adjacent, they are merged.\n   *\n   * @param nodes These nodes must be immediately contiguous siblings in\n   * document order.\n   *\n   * @returns The location between the two parts that were merged, or between\n   * the two nodes that were not merged (because they were not both\n   * text). Undefined if the list of nodes is empty.\n   *\n   * @throws {Error} If nodes are not contiguous siblings.\n   */\n  removeNodes(nodes: Node[]): DLoc | undefined {\n    if (nodes.length === 0) {\n      return undefined;\n    }\n    const prev = nodes[0].previousSibling;\n    const parent = nodes[0].parentNode;\n\n    if (parent === null) {\n      throw new Error(\"called with detached node\");\n    }\n\n    const ix = indexOf(parent.childNodes, nodes[0]);\n    for (let i = 0; i < nodes.length; ++i) {\n      if (i < nodes.length - 1 && nodes[i].nextSibling !== nodes[i + 1]) {\n        throw new Error(\"nodes are not immediately contiguous in \" +\n                        \"document order\");\n      }\n      this.deleteNode(nodes[i]);\n    }\n\n    if (prev === null) {\n      return DLoc.makeDLoc(this.tree, parent, ix);\n    }\n    return this.mergeTextNodes(prev);\n  }\n\n  /**\n   * A complex method. Removes the contents between the start and end carets\n   * from the DOM tree. If two text nodes become adjacent, they are merged.\n   *\n   * @param start The start position.\n   *\n   * @param end The end position.\n   *\n   * @returns A pair of items. The first item is a ``DLoc`` object indicating\n   * the position where the cut happened. The second item is a list of nodes,\n   * the cut contents.\n   *\n   * @throws {Error} If Nodes in the range are not in the same element.\n   */\n  cut(start: DLoc, end: DLoc): [DLoc, Node[]] {\n    const ret = domutil.genericCutFunction.call(this,\n                                                start.toArray(), end.toArray());\n    ret[0] = start.make(ret[0]);\n    return ret;\n  }\n\n  /**\n   * A complex method. If the node is a text node and followed by a text node,\n   * this method will combine them.\n   *\n   * @param node The node to check. This method will fail with an exception if\n   * this parameter is ``undefined`` or ``null``. Use [[mergeTextNodesNF]] if\n   * you want a method that will silently do nothing if ``undefined`` or\n   * ``null`` are expected values.\n   *\n   * @returns A position between the two parts that were merged, or between the\n   * two nodes that were not merged (because they were not both text).\n   */\n  mergeTextNodes(node: Node): DLoc {\n    const next = node.nextSibling;\n    if (isText(node) && next !== null && isText(next)) {\n      const offset = node.length;\n      this.setTextNodeValue(node, node.data + next.data);\n      this.deleteNode(next);\n      return DLoc.mustMakeDLoc(this.tree, node, offset);\n    }\n\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"called with detached node\");\n    }\n\n    return DLoc.mustMakeDLoc(this.tree, parent,\n                             indexOf(parent.childNodes, node) + 1);\n  }\n\n  /**\n   * A complex method. If the node is a text node and followed by a text node,\n   * this method will combine them.\n   *\n   * @param node The node to check. This method will do nothing if the node to\n   * remove is ``undefined`` or ``null``.\n   *\n   * @returns A position between the two parts that were merged, or between the\n   * two nodes that were not merged (because they were not both text). This will\n   * be ``undefined`` if there was no node to remove.\n   */\n  mergeTextNodesNF(node: Node | null | undefined): DLoc | undefined {\n    if (node == null) {\n      return undefined;\n    }\n    return this.mergeTextNodes(node);\n  }\n\n  /**\n   * A primitive method. Removes a node from the DOM tree. This method must not\n   * be called directly by code that performs changes of the DOM tree at a high\n   * level, because it does not prevent two text nodes from being contiguous\n   * after deletion of the node. Call [[removeNode]] instead. This method is\n   * meant to be used by other complex methods of TreeUpdater and by some\n   * low-level facilities of wed.\n   *\n   * @param node The node to remove\n   *\n   * @emits DeleteNodeEvent\n   * @emits BeforeDeleteNodeEvent\n   * @emits ChangedEvent\n   */\n  deleteNode(node: Node): void {\n    this._emit({ name: \"BeforeDeleteNode\", node: node });\n    // The following is functionally equivalent to $(node).detach(), which is\n    // what we want.\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"called with detached node\");\n    }\n\n    parent.removeChild(node);\n    this._emit({ name: \"DeleteNode\", node, formerParent: parent });\n  }\n\n  /**\n   * A complex method. Sets an attribute to a value. Setting to the value\n   * ``null`` or ``undefined`` deletes the attribute. This method sets\n   * attributes outside of any namespace.\n   *\n   * @param node The node to modify.\n   *\n   * @param attribute The name of the attribute to modify.\n   *\n   * @param value The value to give to the attribute.\n   *\n   * @emits SetAttributeNSEvent\n   * @emits ChangedEvent\n   */\n  setAttribute(node: Element, attribute: string,\n               value: string | null | undefined): void {\n    this.setAttributeNS(node, \"\", attribute, value);\n  }\n\n  /**\n   * A primitive method. Sets an attribute to a value. Setting to the value\n   * ``null`` or ``undefined`` deletes the attribute.\n   *\n   * @param node The node to modify.\n   *\n   * @param ns The URI of the namespace of the attribute.\n   *\n   * @param attribute The name of the attribute to modify.\n   *\n   * @param value The value to give to the attribute.\n   *\n   * @emits SetAttributeNSEvent\n   * @emits ChangedEvent\n   */\n  setAttributeNS(node: Element, ns: string, attribute: string,\n                 value: string | null | undefined): void {\n    // Normalize to null.\n    if (value === undefined) {\n      value = null;\n    }\n\n    if (!isElement(node)) {\n      throw new Error(\"setAttribute called on non-element\");\n    }\n\n    let oldValue: string | null = node.getAttributeNS(ns, attribute);\n    // Chrome 32 returns an empty string if the attribute is not present, so\n    // normalize.\n    if (oldValue === \"\" && !node.hasAttributeNS(ns, attribute)) {\n      oldValue = null;\n    }\n\n    if (value != null) {\n      node.setAttributeNS(ns, attribute, value);\n    }\n    else {\n      node.removeAttributeNS(ns, attribute);\n    }\n\n    this._emit({ name: \"SetAttributeNS\", node, ns, attribute, oldValue,\n                 newValue: value });\n  }\n\n  /**\n   * Converts a node to a path.\n   *\n   * @param node The node for which to return a path.\n   *\n   * @returns The path of the node relative to the root of the tree we are\n   * updating.\n   */\n  nodeToPath(node: Node): string {\n    return this.dlocRoot.nodeToPath(node);\n  }\n\n  /**\n   * Converts a path to a node.\n   *\n   * @param path The path to convert.\n   *\n   * @returns The node corresponding to the path passed.\n   */\n  pathToNode(path: string): Node | null {\n    return this.dlocRoot.pathToNode(path);\n  }\n}\n\n//  LocalWords:  domutil splitAt insertAt insertText insertBefore deleteText cd\n//  LocalWords:  removeNode setTextNodeValue param TreeUpdater insertNodeAt MPL\n//  LocalWords:  abcd abfoocd setTextNode deleteNode pathToNode nodeToPath prev\n//  LocalWords:  insertIntoText mergeTextNodes nextSibling previousSibling DOM\n//  LocalWords:  Dubeau Mangalam BeforeInsertNodeAt BeforeDeleteNode DLocRoot\n//  LocalWords:  SetAttributeNS NodeList nodeType beforeThis nd setAttribute\n//  LocalWords:  caretAtEnd\n"]}