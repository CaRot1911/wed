{"version":3,"sources":["../../../wed/mode.ts"],"names":[],"mappings":";IAAA;;;;;;OAMG;IACH,YAAY,CAAC;;IA2Jb;;;;;OAKG;IACH;QAeE;;;;;WAKG;QACH,kBAA+B,MAAc,EACvB,OAAoB;YADX,WAAM,GAAN,MAAM,CAAQ;YACvB,YAAO,GAAP,OAAO,CAAa;YArBhC,eAAU,GAAe;gBACjC,QAAQ,EAAE;oBACR,IAAI,EAAE,0CAA0C;oBAChD,WAAW,EAAE,qDAAqD;oBAClE,OAAO,EAAE,CAAC,wBAAwB,CAAC;oBACnC,OAAO,EAAE,SAAS;oBAClB,SAAS,EAAE,iDAAiD;iBAC7D;gBACD,YAAY,EAAE;oBACZ,GAAG,EAAE,CAAC;oBACN,OAAO,EAAE,CAAC;iBACX;aACF,CAAC;QAS2C,CAAC;QAE9C;;;WAGG;QACH,iCAAc,GAAd;YACE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;QACtB,CAAC;QAED;;;;WAIG;QACH,gCAAa,GAAb;YACE,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACzB,CAAC;QAED;;WAEG;QACH,iCAAc,GAAd;YACE,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;QAED,8CAA2B,GAA3B,UAA4B,OAAgB;YAC1C,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,IAAI,OAAO,CAAC;YACZ,IAAI,GAAG,GAAG,IAAI,CAAC;YACf,IAAI,KAAK,CAAC;YAEV,IAAI,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC;YAC/B,IAAI,OAAO,GAAG,CAAC,CAAC;YAChB,OAAO,KAAK,KAAK,IAAI,EAAE,CAAC;gBACtB,EAAE,CAAC,CAAC,yBAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACrB,EAAE,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;wBAC/C,OAAO,GAAG,OAAO,CAAC;wBAClB,KAAK,GAAG,KAAK,CAAC;oBAChB,CAAC;oBAED,EAAE,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;wBAC7C,KAAK,GAAG,OAAO,CAAC;wBAChB,GAAG,GAAG,KAAK,CAAC;wBAEZ,sEAAsE;wBACtE,KAAK,CAAC;oBACR,CAAC;gBACH,CAAC;gBAED,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;gBAC1B,OAAO,EAAE,CAAC;YACZ,CAAC;YAED,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,IAAI,OAAO,CAAC,CAAC,CAAC;gBACrE,MAAM,IAAI,KAAK,CAAC,kDAAkD;oBAClD,oDAAoD;oBACpD,SAAS,CAAC,CAAC;YAC7B,CAAC;YAED,MAAM,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACtB,CAAC;QAED,qCAAkB,GAAlB,UAAmB,OAAgB;YACjC,MAAM,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;QACnC,CAAC;QAED;;;;;;WAMG;QACH,sCAAmB,GAAnB,UAAoB,IAAY;YAC9B,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QAED;;;;;;WAMG;QACH,uCAAoB,GAApB,UAAqB,IAAY;YAC/B,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QAED;;;WAGG;QACH,+BAAY,GAAZ;YACE,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QAED;;WAEG;QACH,0CAAuB,GAAvB,UAAwB,SAAe;YACrC,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;QASH,eAAC;IAAD,CArIA,AAqIC,IAAA;IArIqB,4BAAQ;;AAuI9B,mEAAmE;AACnE,wCAAwC","file":"mode.js","sourcesContent":["/**\n * The base types for modes.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\n\nimport * as Promise from \"bluebird\";\nimport { NameResolver } from \"salve\";\n\nimport { Action } from \"./action\";\nimport { Decorator } from \"./decorator\";\nimport { isElement } from \"./domtypeguards\";\nimport * as domutil from \"./domutil\";\nimport { ModeValidator } from \"./validator\";\nimport { WedOptions } from \"./wed-options\";\n\n// tslint:disable-next-line:no-any\nexport type Editor = any;\n\nexport type ModeOptions = {};\n\nexport interface Mode<ModeOptions> {\n  /**\n   * This is called by the editor when a mode is ready to be initialized. The\n   * mode could use this to add a toolbar above the editor or add listeners to\n   * key events, etc.\n   *\n   * @returns A promise that resolves once the mode is done initializing.\n   */\n  init(): Promise<void>;\n\n  /**\n   * Gets the mode options.\n   */\n  getModeOptions(): ModeOptions;\n\n  /**\n   * Gets the options that the mode wants wed to use with this mode.\n   *\n   * @returns The options. Callers are not allowed to modify the value returned.\n   */\n  getWedOptions(): WedOptions;\n\n  /**\n   * This method returns a name resolver that is setup to resolve names outside\n   * the context of an XML tree. It is sometimes useful to use qualified names\n   * that do not depend on how a specific XML document is structured, this\n   * method provides for such functionality.\n   */\n  getAbsoluteResolver(): NameResolver;\n\n  /**\n   * Make a decorator that this mode will use.\n   */\n  makeDecorator(): Decorator;\n\n  /**\n   * Modes must implement this method to specify what transformations they allow\n   * based on state. The implementation should rely on the ``container`` and\n   * ``offset`` position rather than use the caret because the editor may be\n   * seeking information about possible actions near to the caret.\n   *\n   * @param transformationType The type or types of transformations to return.\n   *\n   * @param tag The tag name we are interested in.\n   *\n   * @param container The position in the data tree.\n   *\n   * @param offset The position in the data tree.\n   *\n   * @returns The actions.\n   */\n  getContextualActions(transformationType: string | string[],\n                       tag: string,\n                       container: Node,\n                       offset: number): Action<{}>[];\n\n  /**\n   * Provide the possible value completions for an attribute. This allows a mode\n   * to support dynamic computations for completions.\n   *\n   * @param attribute The attribute for which we want completions.\n   *\n   * @returns The possible completions.\n   */\n  getAttributeCompletions(attribute: Attr): string[];\n\n  /**\n   * Get additional stylesheets to use to render the HTML.\n   *\n   * @returns An array of paths to the stylesheets to\n   * load for this mode.\n   */\n  getStylesheets(): string[];\n\n  /**\n   * Find the nodes that are children of ``element`` and that are just before\n   * and just after the content of element that is editable.\n   *\n   * @param element This is the element to examine. **MUST BE PART OF THE GUI\n   * TREE.**\n   *\n   * @returns An array of two elements. The first is the node before editable\n   * contents, the second is the node after. Either node can be null if there is\n   * nothing before or after editable contents. Both are null if there is\n   * nothing around the editable content.\n   */\n  nodesAroundEditableContents(element: Element): [Node | null, Node | null];\n\n  /**\n   * This method can be overriden by modes to provide the editor with different\n   * placeholders for different elements. The default implementation returns a\n   * default placeholder for all elements.\n   *\n   * @param element This is the element for which to make a placeholder.\n   *\n   * @returns A placeholder for the element.\n   */\n  makePlaceholderFor(element: Element): Element;\n\n  /**\n   * Returns a short description for an element. The element should be named\n   * according to the mappings reported by the resolve returned by\n   * [[getAbsoluteResolver]].\n   *\n   * @param name The name of the element.\n   *\n   * @returns The description. If the value returned is ``undefined``, then\n   * description is not available. If the value returned is ``null``, the\n   * description has not been loaded yet.\n   */\n  shortDescriptionFor(name: string): string | null | undefined;\n\n  /**\n   * Returns a URL to the documentation for an element. The element should be\n   * named according to the mappings reported by the resolve returned by\n   * [[getAbsoluteResolver]]. The default implementation returns ``undefined``\n   * for everything.\n   *\n   * @param name The name of the element.\n   *\n   * @returns The URL. If the value returned is ``undefined``, then the URL is\n   * not available. If the value returned is ``null``, the URL has not been\n   * loaded yet.\n   */\n  documentationLinkFor(name: string): string | null | undefined;\n\n  /**\n   * Allows the mode to perform mode-specific checks on the document. This\n   * method will be called by wed to obtain a mode-specific validator to give to\n   * wed's own validator. Mode-specific validators are meant to provide checks\n   * that **cannot** be provided by a schema. It would be conceivable for\n   * instance to call a schematron processor.\n   *\n   * @returns The validator if this mode has one.\n   */\n  getValidator(): ModeValidator | undefined;\n}\n\n/**\n * A mode for wed should be implemented as a module which exports a\n * class derived from this class.\n *\n *\n */\nexport abstract class BaseMode<ModeOptions> implements Mode<ModeOptions> {\n  protected wedOptions: WedOptions = {\n    metadata: {\n      name: \"Base Mode (you should not be using this)\",\n      description: \"The base mode. You should not be using it directly.\",\n      authors: [\"Louis-Dominique Dubeau\"],\n      license: \"MPL 2.0\",\n      copyright: \"Mangalam Research Center for Buddhist Languages\",\n    },\n    label_levels: {\n      max: 1,\n      initial: 1,\n    },\n  };\n\n  /**\n   * @param editor The editor with which the mode is being associated.\n   *\n   * @param options The options for the mode. Each mode defines\n   * what fields this object contains.\n   */\n  constructor(protected readonly editor: Editor,\n              protected options: ModeOptions) {}\n\n  /**\n   * Gets the mode options. The returned object should be considered frozen. You\n   * may inspect it, not modify it.\n   */\n  getModeOptions(): ModeOptions {\n    return this.options;\n  }\n\n  /**\n   * Gets the options that the mode wants wed to use with this mode.\n   *\n   * @returns The options. Callers are not allowed to modify the value returned.\n   */\n  getWedOptions(): WedOptions {\n    return this.wedOptions;\n  }\n\n  /**\n   * @returns The base implementation returns an empty array.\n   */\n  getStylesheets(): string[] {\n    return [];\n  }\n\n  nodesAroundEditableContents(element: Element): [Node | null, Node | null] {\n    let start = null;\n    let startIx;\n    let end = null;\n    let endIx;\n\n    let child = element.firstChild;\n    let childIx = 0;\n    while (child !== null) {\n      if (isElement(child)) {\n        if (child.classList.contains(\"_start_wrapper\")) {\n          startIx = childIx;\n          start = child;\n        }\n\n        if (child.classList.contains(\"_end_wrapper\")) {\n          endIx = childIx;\n          end = child;\n\n          // We want the first end_wrapper we hit. There is no need to continue.\n          break;\n        }\n      }\n\n      child = child.nextSibling;\n      childIx++;\n    }\n\n    if (startIx !== undefined && endIx !== undefined && endIx <= startIx) {\n      throw new Error(\"end wrapper element unexpectedly appears before \" +\n                      \"start wrapper element, or is also a start wrapper \" +\n                      \"element\");\n    }\n\n    return [start, end];\n  }\n\n  makePlaceholderFor(element: Element): Element {\n    return domutil.makePlaceholder();\n  }\n\n  /**\n   * While this API provides for the case where descriptions have not been\n   * loaded yet or cannot be loaded, this class does not allow such eventuality\n   * to occur. Derived classes could allow it.\n   *\n   * @returns This default implementation always returns ``undefined``.\n   */\n  shortDescriptionFor(name: string): string | null | undefined {\n    return undefined;\n  }\n\n  /**\n   * While this API provides for the case such URL have not been loaded\n   * yet or cannot be loaded, this class does not allow such eventuality\n   * to occur. Derived classes could allow it.\n   *\n   * @returns The default implementation always returns ``undefined``.\n   */\n  documentationLinkFor(name: string): string | null | undefined {\n    return undefined;\n  }\n\n  /**\n   * @returns ``undefined``. The default implementation has no mode-specific\n   * checks and thus not return a validator.\n   */\n  getValidator(): ModeValidator | undefined {\n    return undefined;\n  }\n\n  /**\n   * The default implementation returns an empty array.\n   */\n  getAttributeCompletions(attribute: Attr): string[] {\n    return [];\n  }\n\n  abstract init(): Promise<void>;\n  abstract getAbsoluteResolver(): NameResolver;\n  abstract makeDecorator(): Decorator;\n  abstract getContextualActions(transformationType: string | string[],\n                                tag: string,\n                                container: Node,\n                                offset: number): Action<{}>[];\n}\n\n//  LocalWords:  RequireJS stylesheets subarrays overriden html MPL\n//  LocalWords:  Mangalam Dubeau domutil\n"]}