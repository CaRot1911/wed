{"version":3,"file":"mode.js","sourceRoot":"","sources":["../../../../lib/wed/mode.ts"],"names":[],"mappings":";IAAA;;;;;;OAMG;IACH,YAAY,CAAC;;IAkMb;;;OAGG;IACH;QAeE;;;;;WAKG;QACH,kBAA+B,MAAiB,EAC1B,OAAoB;YADX,WAAM,GAAN,MAAM,CAAW;YAC1B,YAAO,GAAP,OAAO,CAAa;YArBhC,eAAU,GAAe;gBACjC,QAAQ,EAAE;oBACR,IAAI,EAAE,0CAA0C;oBAChD,WAAW,EAAE,qDAAqD;oBAClE,OAAO,EAAE,CAAC,wBAAwB,CAAC;oBACnC,OAAO,EAAE,SAAS;oBAClB,SAAS,EAAE,iDAAiD;iBAC7D;gBACD,YAAY,EAAE;oBACZ,GAAG,EAAE,CAAC;oBACN,OAAO,EAAE,CAAC;iBACX;aACF,CAAC;QAS2C,CAAC;QAE9C;;;WAGG;QACH,iCAAc,GAAd;YACE,OAAO,IAAI,CAAC,OAAO,CAAC;QACtB,CAAC;QAED;;;;WAIG;QACH,gCAAa,GAAb;YACE,OAAO,IAAI,CAAC,UAAU,CAAC;QACzB,CAAC;QAED;;WAEG;QACH,iCAAc,GAAd;YACE,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,8CAA2B,GAA3B,UAA4B,OAAgB;YAC1C,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,IAAI,OAAO,CAAC;YACZ,IAAI,GAAG,GAAG,IAAI,CAAC;YACf,IAAI,KAAK,CAAC;YAEV,IAAI,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC;YAC/B,IAAI,OAAO,GAAG,CAAC,CAAC;YAChB,OAAO,KAAK,KAAK,IAAI,EAAE;gBACrB,IAAI,mBAAa,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;oBAClC,IAAI,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,gBAAgB,CAAC,EAAE;wBAC9C,OAAO,GAAG,OAAO,CAAC;wBAClB,KAAK,GAAG,KAAK,CAAC;qBACf;oBAED,IAAI,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;wBAC5C,KAAK,GAAG,OAAO,CAAC;wBAChB,GAAG,GAAG,KAAK,CAAC;wBAEZ,sEAAsE;wBACtE,MAAM;qBACP;iBACF;gBAED,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;gBAC1B,OAAO,EAAE,CAAC;aACX;YAED,IAAI,OAAO,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,IAAI,OAAO,EAAE;gBACpE,MAAM,IAAI,KAAK,CAAC,kDAAkD;oBAClD,oDAAoD;oBACpD,SAAS,CAAC,CAAC;aAC5B;YAED,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACtB,CAAC;QAED,qCAAkB,GAAlB,UAAmB,QAAiB;YAClC,OAAO,aAAO,CAAC,eAAe,EAAE,CAAC;QACnC,CAAC;QAED;;;;;;WAMG;QACH,sCAAmB,GAAnB,UAAoB,KAAa;YAC/B,OAAO,SAAS,CAAC;QACnB,CAAC;QAED;;;;;;WAMG;QACH,uCAAoB,GAApB,UAAqB,KAAa;YAChC,OAAO,SAAS,CAAC;QACnB,CAAC;QAED;;;WAGG;QACH,+BAAY,GAAZ;YACE,OAAO,SAAS,CAAC;QACnB,CAAC;QAED;;WAEG;QACH,0CAAuB,GAAvB,UAAwB,UAAgB;YACtC,OAAO,EAAE,CAAC;QACZ,CAAC;QAED;;WAEG;QACH,oCAAiB,GAAjB;YACE,OAAO,EAAE,CAAC;QACZ,CAAC;QAWH,eAAC;IAAD,CAAC,AA9ID,IA8IC;IA9IqB,4BAAQ;;AAgJ9B,yEAAyE;AACzE,4BAA4B","sourcesContent":["/**\n * The base types for modes.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\n\nimport { EName, NameResolver } from \"salve\";\n\nimport { Action, Decorator, domtypeguards, domutil, EditorAPI, gui,\n         ModeValidator, WedOptions } from \"wed\";\n\nimport Button = gui.button.Button;\n\n/**\n * These are mode options that are supported by default by all modes. Wed is\n * responsible for providing support for them.\n */\nexport interface CommonModeOptions {\n  /** Whether to turn on autoinsertion of elements. */\n  autoinsert?: boolean;\n}\n\nexport interface Mode<ModeOptions extends\nCommonModeOptions = CommonModeOptions> {\n  /**\n   * This is called by the editor when a mode is ready to be initialized. The\n   * mode could use this to add a toolbar above the editor or add listeners to\n   * key events, etc.\n   *\n   * @returns A promise that resolves once the mode is done initializing.\n   */\n  init(): Promise<void>;\n\n  /**\n   * Gets the mode options.\n   */\n  getModeOptions(): ModeOptions;\n\n  /**\n   * Gets the options that the mode wants wed to use with this mode.\n   *\n   * @returns The options. Callers are not allowed to modify the value returned.\n   */\n  getWedOptions(): WedOptions;\n\n  /**\n   * This method returns a mappings of prefix to namespace URI that are set to\n   * resolve names outside the context of an XML tree. It is sometimes useful to\n   * use qualified names that do not depend on how a specific XML document is\n   * structured, this method provides for such functionality.\n   *\n   * @returns The mappings. This is a new copy which you can modify at will.\n   */\n  getAbsoluteNamespaceMappings(): Record<string, string>;\n\n  /**\n   * Unresolve a name according to the absolute reverse mapping.\n   *\n   * If the forward mappings define multiple prefixes pointing to the same URI,\n   * the unresolving algorithm will arbitrarily select one of the prefixes as\n   * the value corresponding to the URI. Modes may impose whatever rules they\n   * desire to select which prefix they should privilege.\n   *\n   * @param name The name to unresolve.\n   *\n   * @returns The unresolved name or ``undefined`` if the name cannot be\n   * unresolved.\n   */\n  unresolveName(name: EName): string | undefined;\n\n  /**\n   * This method returns a name resolver that uses the map returned by\n   * [[getAbsoluteNamespaceMappings]]. The resolver is created once and for\n   * all. So code using the resolver should not modify it because it will modify\n   * the resolver for all clients. If you need a resolver you can modify, use\n   * [[getAbsoluteNamespaceMappings]] and initialize a resolver from it.\n   *\n   * @returns The resolver.\n   */\n  getAbsoluteResolver(): NameResolver;\n\n  /**\n   * Make a decorator that this mode will use.\n   */\n  makeDecorator(): Decorator;\n\n  /**\n   * Get the toolbar actions that this mode wants the editor to present.\n   *\n   * @returns The toolbar actions for this mode.\n   */\n  getToolbarButtons(): Button[];\n\n  /**\n   * Modes must implement this method to specify what transformations they allow\n   * based on state. The implementation should rely on the ``container`` and\n   * ``offset`` position rather than use the caret because the editor may be\n   * seeking information about possible actions near to the caret.\n   *\n   * @param transformationType The type or types of transformations to return.\n   *\n   * @param tag The tag name we are interested in. This should be in a\n   * prefix:localName format where \"prefix\" is one of the prefixes defined in\n   * the absolute mappings known to the mode.\n   *\n   * @param container The position in the data tree.\n   *\n   * @param offset The position in the data tree.\n   *\n   * @returns The actions.\n   */\n  getContextualActions(transformationType: string | string[],\n                       tag: string,\n                       container: Node,\n                       offset?: number): Action<{}>[];\n\n  /**\n   * Provide the possible value completions for an attribute. This allows a mode\n   * to support dynamic computations for completions.\n   *\n   * @param attribute The attribute for which we want completions.\n   *\n   * @returns The possible completions.\n   */\n  getAttributeCompletions(attribute: Attr): string[];\n\n  /**\n   * Get additional stylesheets to use to render the HTML.\n   *\n   * @returns An array of paths to the stylesheets to load for this mode. The\n   * paths must not require any additional interpretation from wed.\n   */\n  getStylesheets(): string[];\n\n  /**\n   * Find the nodes that are children of ``element`` and that are just before\n   * and just after the content of element that is editable.\n   *\n   * @param element This is the element to examine. **MUST BE PART OF THE GUI\n   * TREE.**\n   *\n   * @returns An array of two elements. The first is the node before editable\n   * contents, the second is the node after. Either node can be null if there is\n   * nothing before or after editable contents. Both are null if there is\n   * nothing around the editable content.\n   */\n  nodesAroundEditableContents(element: Element): [Node | null, Node | null];\n\n  /**\n   * This method can be overriden by modes to provide the editor with different\n   * placeholders for different elements. The default implementation returns a\n   * default placeholder for all elements.\n   *\n   * @param element This is the element for which to make a placeholder.\n   *\n   * @returns A placeholder for the element.\n   */\n  makePlaceholderFor(element: Element): Element;\n\n  /**\n   * Returns a short description for an element. The element should be named\n   * according to the mappings reported by the resolve returned by\n   * [[getAbsoluteResolver]].\n   *\n   * @param name The name of the element.\n   *\n   * @returns The description. If the value returned is ``undefined``, then\n   * description is not available. If the value returned is ``null``, the\n   * description has not been loaded yet.\n   */\n  shortDescriptionFor(name: string): string | null | undefined;\n\n  /**\n   * Returns a URL to the documentation for an element. The element should be\n   * named according to the mappings reported by the resolve returned by\n   * [[getAbsoluteResolver]]. The default implementation returns ``undefined``\n   * for everything.\n   *\n   * @param name The name of the element.\n   *\n   * @returns The URL. If the value returned is ``undefined``, then the URL is\n   * not available. If the value returned is ``null``, the URL has not been\n   * loaded yet.\n   */\n  documentationLinkFor(name: string): string | null | undefined;\n\n  /**\n   * Allows the mode to perform mode-specific checks on the document. This\n   * method will be called by wed to obtain a mode-specific validator to give to\n   * wed's own validator. Mode-specific validators are meant to provide checks\n   * that **cannot** be provided by a schema. It would be conceivable for\n   * instance to call a schematron processor.\n   *\n   * @returns The validator if this mode has one.\n   */\n  getValidator(): ModeValidator | undefined;\n}\n\n/**\n * A mode for wed should be implemented as a module which exports a\n * class derived from this class.\n */\nexport abstract class BaseMode<ModeOptions> implements Mode<ModeOptions> {\n  protected wedOptions: WedOptions = {\n    metadata: {\n      name: \"Base Mode (you should not be using this)\",\n      description: \"The base mode. You should not be using it directly.\",\n      authors: [\"Louis-Dominique Dubeau\"],\n      license: \"MPL 2.0\",\n      copyright: \"Mangalam Research Center for Buddhist Languages\",\n    },\n    label_levels: {\n      max: 1,\n      initial: 1,\n    },\n  };\n\n  /**\n   * @param editor The editor for which this mode is created.\n   *\n   * @param options The options for the mode. Each mode defines\n   * what fields this object contains.\n   */\n  constructor(protected readonly editor: EditorAPI,\n              protected options: ModeOptions) {}\n\n  /**\n   * Gets the mode options. The returned object should be considered frozen. You\n   * may inspect it, not modify it.\n   */\n  getModeOptions(): ModeOptions {\n    return this.options;\n  }\n\n  /**\n   * Gets the options that the mode wants wed to use with this mode.\n   *\n   * @returns The options. Callers are not allowed to modify the value returned.\n   */\n  getWedOptions(): WedOptions {\n    return this.wedOptions;\n  }\n\n  /**\n   * @returns The base implementation returns an empty array.\n   */\n  getStylesheets(): string[] {\n    return [];\n  }\n\n  nodesAroundEditableContents(element: Element): [Node | null, Node | null] {\n    let start = null;\n    let startIx;\n    let end = null;\n    let endIx;\n\n    let child = element.firstChild;\n    let childIx = 0;\n    while (child !== null) {\n      if (domtypeguards.isElement(child)) {\n        if (child.classList.contains(\"_start_wrapper\")) {\n          startIx = childIx;\n          start = child;\n        }\n\n        if (child.classList.contains(\"_end_wrapper\")) {\n          endIx = childIx;\n          end = child;\n\n          // We want the first end_wrapper we hit. There is no need to continue.\n          break;\n        }\n      }\n\n      child = child.nextSibling;\n      childIx++;\n    }\n\n    if (startIx !== undefined && endIx !== undefined && endIx <= startIx) {\n      throw new Error(\"end wrapper element unexpectedly appears before \" +\n                      \"start wrapper element, or is also a start wrapper \" +\n                      \"element\");\n    }\n\n    return [start, end];\n  }\n\n  makePlaceholderFor(_element: Element): Element {\n    return domutil.makePlaceholder();\n  }\n\n  /**\n   * While this API provides for the case where descriptions have not been\n   * loaded yet or cannot be loaded, this class does not allow such eventuality\n   * to occur. Derived classes could allow it.\n   *\n   * @returns This default implementation always returns ``undefined``.\n   */\n  shortDescriptionFor(_name: string): string | null | undefined {\n    return undefined;\n  }\n\n  /**\n   * While this API provides for the case such URL have not been loaded\n   * yet or cannot be loaded, this class does not allow such eventuality\n   * to occur. Derived classes could allow it.\n   *\n   * @returns The default implementation always returns ``undefined``.\n   */\n  documentationLinkFor(_name: string): string | null | undefined {\n    return undefined;\n  }\n\n  /**\n   * @returns ``undefined``. The default implementation has no mode-specific\n   * checks and thus not return a validator.\n   */\n  getValidator(): ModeValidator | undefined {\n    return undefined;\n  }\n\n  /**\n   * The default implementation returns an empty array.\n   */\n  getAttributeCompletions(_attribute: Attr): string[] {\n    return [];\n  }\n\n  /**\n   * The default implementaiton returns an empty array.\n   */\n  getToolbarButtons(): Button[] {\n    return [];\n  }\n\n  abstract init(): Promise<void>;\n  abstract getAbsoluteNamespaceMappings(): Record<string, string>;\n  abstract unresolveName(name: EName): string | undefined;\n  abstract getAbsoluteResolver(): NameResolver;\n  abstract makeDecorator(): Decorator;\n  abstract getContextualActions(transformationType: string | string[],\n                                tag: string,\n                                container: Node,\n                                offset: number): Action<{}>[];\n}\n\n//  LocalWords:  autoinsertion domutil Dubeau Mangalam MPL html overriden\n//  LocalWords:  stylesheets\n"]}