{"version":3,"sources":["../../../wed/modes/generic/generic-tr.ts"],"names":[],"mappings":"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","file":"generic-tr.js","sourcesContent":["/**\n * Transformation registry for the generic mode.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\n\nimport * as salve from \"salve\";\nimport { ErrorData } from \"salve-dom\";\n\nimport { DLoc } from \"wed/dloc\";\nimport { isAttr, isElement } from \"wed/domtypeguards\";\nimport { childByClass, indexOf } from \"wed/domutil\";\nimport { Mode } from \"wed/mode\";\nimport { insertElement, Transformation, TransformationData, unwrap,\n         wrapInElement } from \"wed/transformation\";\nimport { Validator } from \"wed/validator\";\n\nexport interface Editor {\n  validator: Validator;\n  // tslint:disable-next-line:no-any\n  mode: Mode<any>;\n  // tslint:disable-next-line:no-any\n  [key: string]: any;\n}\n\nfunction errFilter(err: ErrorData): boolean {\n  const errMsg = err.error.toString();\n  return errMsg.lastIndexOf(\"tag required: \", 0) === 0;\n}\n\n/**\n * Perform the autoinsertion algorithm on an element.\n *\n * @param el The element that should be subject to the autoinsertion algorithm.\n *\n * @param editor The editor which owns the element.\n */\nfunction _autoinsert(el: Element, editor: Editor): void {\n  // tslint:disable-next-line:no-constant-condition strict-boolean-expressions\n  while (true) {\n    let errors = editor.validator.getErrorsFor(el);\n\n    errors = errors.filter(errFilter);\n    if (errors.length === 0) {\n      break;\n    }\n\n    const ename = errors[0].error.getNames()[0];\n    const names = ename.toArray();\n    // If names is null the pattern is not simple and we cannot autoinsert. If\n    // there is more than one option, we also cannot autoinsert.\n    if (names === null || names.length > 1) {\n      break;\n    }\n    const name = names[0];\n\n    const locations = editor.validator.possibleWhere(\n      el, new salve.Event(\"enterStartTag\", name.ns, name.name));\n\n    if (locations.length !== 1) {\n      break;\n    }\n\n    const unresolved = editor.resolver.unresolveName(name.ns, name.name);\n    const actions = editor.mode.getContextualActions(\"insert\", unresolved,\n                                                     el, locations[0]);\n\n    // Don't auto insert if it happens that the operation would be ambiguous\n    // (ie. if there is more than one way to insert the element).\n    if (actions.length !== 1) {\n      break;\n    }\n\n    // Don't auto insert if the operation needs input from the user.\n    if (actions[0].needsInput) {\n      break;\n    }\n\n    //\n    // We move the caret ourselves rather than using moveCaretTo. In this\n    // context, it does not matter because autoinsert is meant to be called by a\n    // transformation anyway.\n    //\n    editor.caretManager.setCaret(el, locations[0]);\n    actions[0].execute({ name: unresolved });\n  }\n}\n\nfunction executeInsert(editor: Editor, data: TransformationData): void {\n  const caret = editor.caretManager.getDataCaret();\n  const absoluteResolver = editor.mode.getAbsoluteResolver();\n  const ename = absoluteResolver.resolveName(data.name);\n  if (ename === undefined) {\n    throw new Error(`cannot resolve ${data.name}`);\n  }\n  const unresolved = editor.validator.unresolveNameAt(caret.node, caret.offset,\n                                                      ename.ns, ename.name);\n  const el = insertElement(editor.data_updater, caret.node,\n                           caret.offset, ename.ns, data.name);\n  if (unresolved === undefined) {\n    // The namespace used by the element has not been defined yet. So we need to\n    // define it.\n    const prefix = absoluteResolver.prefixFromURI(ename.ns);\n    const name = (prefix === \"\") ? \"xmlns\" : `xmlns:${prefix}`;\n    // The next name is necessarily resolvable so we assert that it is not\n    // resolving to undefined.\n    const xmlnsURI = absoluteResolver.resolveName(\"xmlns:q\")!.ns;\n    editor.data_updater.setAttributeNS(el, xmlnsURI, name, ename.ns);\n  }\n\n  let caretNode: Node | null = el;\n  if (editor.mode.getModeOptions().autoinsert as boolean) {\n    _autoinsert(el, editor);\n\n    // Set el to the deepest first child, so that the caret is put in the right\n    // position.\n    while (caretNode !== null) {\n      const child: Node | null = caretNode.firstChild;\n      if (child === null) {\n        break;\n      }\n      caretNode = child;\n    }\n  }\n  editor.caretManager.setCaret(caretNode, 0);\n}\n\nfunction executeUnwrap(editor: Editor, data: TransformationData): void {\n  const node = data.node;\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n  const parent = node.parentNode!;\n  const index = indexOf(parent.childNodes, node);\n  unwrap(editor.data_updater, node);\n  editor.caretManager.setCaret(parent, index);\n}\n\nfunction executeWrap(editor: Editor, data: TransformationData): void {\n  const sel = editor.caretManager.sel;\n  if (sel == null) {\n    throw new Error(\"wrap transformation called with undefined range\");\n  }\n\n  if (sel.collapsed as boolean) {\n    throw new Error(\"wrap transformation called with collapsed range\");\n  }\n  const [startCaret, endCaret] = sel.asDataCarets();\n  const ename = editor.mode.getAbsoluteResolver().resolveName(data.name);\n  if (ename === undefined) {\n    throw new Error(`cannot resolve ${data.name}`);\n  }\n  const el = wrapInElement(editor.data_updater, startCaret.node,\n                           startCaret.offset, endCaret.node, endCaret.offset,\n                           ename.ns, data.name);\n  const parent = el.parentNode!;\n  editor.caretManager.setCaret(startCaret.make(parent,\n                                  indexOf(parent.childNodes, el) + 1));\n}\n\nfunction executeWrapContent(editor: Editor, data: TransformationData): void {\n  const toWrap = data.node;\n\n  if (!isElement(toWrap)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const ename = editor.mode.getAbsoluteResolver().resolveName(data.name);\n  if (ename === undefined) {\n    throw new Error(`cannot resolve ${data.name}`);\n  }\n  wrapInElement(editor.data_updater, toWrap, 0, toWrap,\n                toWrap.childNodes.length, ename.ns, data.name);\n}\n\nfunction executeDeleteElement(editor: Editor, data: TransformationData): void {\n  const node = data.node;\n\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const parent = node.parentNode!;\n  const index = indexOf(parent.childNodes, node);\n  const guiLoc = editor.caretManager.fromDataLocation(node, 0) as DLoc;\n  // If the node we start with is an Element, then the node in guiLoc is\n  // necessarily an Element too.\n  if (!(guiLoc.node as Element).classList.contains(\"_readonly\")) {\n    editor.data_updater.removeNode(node);\n    editor.caretManager.setCaret(parent, index);\n  }\n}\n\nfunction executeDeleteParent(editor: Editor, data: TransformationData): void {\n  const node = data.node;\n\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const parent = node.parentNode!;\n  const index = indexOf(parent.childNodes, node);\n  const guiLoc = editor.caretManager.fromDataLocation(node, 0);\n  // If the node we start with is an Element, then the node in guiLoc is\n  // necessarily an Element too.\n  if (!(guiLoc.node as Element).classList.contains(\"_readonly\")) {\n    editor.data_updater.removeNode(node);\n    editor.caretManager.setCaret(parent, index);\n  }\n}\n\nfunction executeAddAttribute(editor: Editor, data: TransformationData): void {\n  const node = data.node;\n\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const guiLoc = editor.caretManager.fromDataLocation(node, 0);\n  // If the node we start with is an Element, then the node in guiLoc is\n  // necessarily an Element too.\n  if (!(guiLoc.node as Element).classList.contains(\"_readonly\")) {\n    editor.data_updater.setAttribute(node, data.name, \"\");\n    const attr = node.getAttributeNode(data.name);\n    editor.caretManager.setCaret(attr, 0);\n  }\n}\n\nfunction executeDeleteAttribute(editor: Editor,\n                                data: TransformationData): void {\n  const node = data.node;\n\n  if (node == null || !isAttr(node)) {\n    throw new Error(\"node must be an attribute\");\n  }\n\n  const element = node.ownerElement;\n  const caretManager = editor.caretManager;\n  const guiOwnerLoc = caretManager.fromDataLocation(element, 0);\n  // If the node we start with is an Element, then the node in guiOwnerLoc\n  // is necessarily an Element too.\n  const guiOwner = guiOwnerLoc.node as Element;\n  if (!guiOwner.classList.contains(\"_readonly\")) {\n    const encoded = node.name;\n    const startLabel = childByClass(guiOwner, \"__start_label\")!;\n\n    // An earlier version of this code relied on the order of attributres in the\n    // data tree. However, this order is not consistent from platform to\n    // platform. Using the order of attributes in the GUI is\n    // consistent. Therefore we go to the GUI to find the next attribute.\n\n    const values = startLabel.getElementsByClassName(\"_attribute_value\");\n\n    // We have to get the parent node because fromDataLocation brings us to the\n    // text node that contains the value.\n    const guiNode = caretManager.fromDataLocation(node, 0).node.parentNode;\n    const index = indexOf(values, guiNode);\n    const nextGUIValue = values[index + 1];\n    const nextAttr = nextGUIValue != null ?\n      editor.toDataNode(nextGUIValue) : null;\n\n    editor.data_updater.setAttribute(element, encoded, null);\n\n    // We set the caret inside the next attribute, or if it does not exist,\n    // inside the label.\n    if (nextAttr !== null) {\n      editor.caretManager.setCaret(nextAttr, 0);\n    }\n    else {\n      editor.caretManager.setCaret(\n        guiOwnerLoc.node.getElementsByClassName(\"_element_name\")[0], 0);\n    }\n  }\n}\n\n/**\n * @param forEditor The editor for which to create transformations.\n */\nexport function makeTagTr(forEditor: Editor):\nRecord<string, Transformation<TransformationData>> {\n  const ret: Record<string, Transformation<TransformationData>> =\n    Object.create(null);\n  ret.insert = new Transformation(forEditor, \"insert\", \"Create new <name>\",\n                                  \"\", executeInsert);\n  ret.unwrap = new Transformation(forEditor, \"unwrap\",\n                                  \"Unwrap the content of this element\",\n                                  undefined, executeUnwrap);\n  ret.wrap = new Transformation(forEditor, \"wrap\", \"Wrap in <name>\",\n                                undefined, executeWrap);\n  ret[\"wrap-content\"] = new Transformation(forEditor, \"wrap-content\",\n                                           \"Wrap content in <name>\", undefined,\n                                           executeWrapContent);\n  ret[\"delete-element\"] = new Transformation(forEditor, \"delete-element\",\n                                             \"Delete this element\", undefined,\n                                             executeDeleteElement);\n  ret[\"delete-parent\"] = new Transformation(forEditor, \"delete-parent\",\n                                            \"Delete <name>\", undefined,\n                                            executeDeleteParent);\n  ret[\"add-attribute\"] = new Transformation(forEditor, \"add-attribute\",\n                                            \"Add @<name>\", undefined,\n                                            executeAddAttribute);\n  ret[\"delete-attribute\"] = new Transformation(forEditor, \"delete-attribute\",\n                                               \"Delete this attribute\",\n                                               undefined,\n                                               executeDeleteAttribute);\n  ret[\"insert-text\"] = new Transformation(forEditor, \"insert-text\",\n                                          \"Insert \\\"<name>\\\"\", undefined,\n                                          (editor: Editor, data) => {\n                                            editor.type(data.name);\n                                          });\n  ret.split = forEditor.split_node_tr;\n\n  return ret;\n}\n\n//  LocalWords:  TransformationRegistry Mangalam MPL Dubeau\n"]}