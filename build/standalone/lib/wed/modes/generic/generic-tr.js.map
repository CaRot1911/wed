{"version":3,"file":"generic-tr.js","sourceRoot":"","sources":["../../../../../../lib/wed/modes/generic/generic-tr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Transformation registry for the generic mode.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\n\nimport * as salve from \"salve\";\nimport { ErrorData } from \"salve-dom\";\n\nimport { DLoc, domtypeguards, domutil, EditorAPI,\n         transformation } from \"wed\";\n\nconst { insertElement, unwrap, wrapInElement } = transformation;\nimport Transformation = transformation.Transformation;\nimport TransformationData = transformation.TransformationData;\nimport NamedTransformationData = transformation.NamedTransformationData;\n\nconst { childByClass, indexOf } = domutil;\nconst { isAttr, isElement } = domtypeguards;\n\nfunction errFilter(err: ErrorData): boolean {\n  const errMsg = err.error.toString();\n  return errMsg.lastIndexOf(\"tag required: \", 0) === 0;\n}\n\n/**\n * Perform the autoinsertion algorithm on an element.\n *\n * @param el The element that should be subject to the autoinsertion algorithm.\n *\n * @param editor The editor which owns the element.\n */\nfunction _autoinsert(el: Element, editor: EditorAPI): void {\n  // tslint:disable-next-line:no-constant-condition strict-boolean-expressions\n  while (true) {\n    let errors = editor.validator.getErrorsFor(el);\n\n    errors = errors.filter(errFilter);\n    if (errors.length === 0) {\n      break;\n    }\n\n    const ename = errors[0].error.getNames()[0];\n    const names = ename.toArray();\n    // If names is null the pattern is not simple and we cannot autoinsert. If\n    // there is more than one option, we also cannot autoinsert.\n    if (names === null || names.length > 1) {\n      break;\n    }\n    const name = names[0];\n\n    const locations = editor.validator.possibleWhere(\n      el, new salve.Event(\"enterStartTag\", name.ns, name.name));\n\n    if (locations.length !== 1) {\n      break;\n    }\n\n    const mode = editor.modeTree.getMode(el);\n    const unresolved =\n      mode.getAbsoluteResolver().unresolveName(name.ns, name.name);\n    if (unresolved === undefined) {\n      throw new Error(`cannot unresolve {${name.ns}}${name.name}`);\n    }\n    const actions = mode.getContextualActions(\"insert\", unresolved,\n                                              el, locations[0]);\n\n    // Don't auto insert if it happens that the operation would be ambiguous\n    // (ie. if there is more than one way to insert the element).\n    if (actions.length !== 1) {\n      break;\n    }\n\n    // Don't auto insert if the operation needs input from the user.\n    if (actions[0].needsInput) {\n      break;\n    }\n\n    //\n    // We move the caret ourselves rather than using moveCaretTo. In this\n    // context, it does not matter because autoinsert is meant to be called by a\n    // transformation anyway.\n    //\n    editor.caretManager.setCaret(el, locations[0]);\n    actions[0].execute({ name: unresolved });\n  }\n}\n\nfunction executeInsert(editor: EditorAPI, data: NamedTransformationData): void {\n  const caret = editor.caretManager.getDataCaret();\n  if (caret === undefined) {\n    throw new Error(\"inserting without a defined caret!\");\n  }\n\n  const mode = editor.modeTree.getMode(caret.node);\n  const absoluteResolver = mode.getAbsoluteResolver();\n  const ename = absoluteResolver.resolveName(data.name);\n  if (ename === undefined) {\n    throw new Error(`cannot resolve ${data.name}`);\n  }\n  const unresolved = editor.validator.unresolveNameAt(caret.node, caret.offset,\n                                                      ename.ns, ename.name);\n  const el = insertElement(editor.dataUpdater, caret.node,\n                           caret.offset, ename.ns, data.name);\n  if (unresolved === undefined) {\n    // The namespace used by the element has not been defined yet. So we need to\n    // define it.\n    const prefix = absoluteResolver.prefixFromURI(ename.ns);\n    const name = (prefix === \"\") ? \"xmlns\" : `xmlns:${prefix}`;\n    // The next name is necessarily resolvable so we assert that it is not\n    // resolving to undefined.\n    const xmlnsURI = absoluteResolver.resolveName(\"xmlns:q\")!.ns;\n    editor.dataUpdater.setAttributeNS(el, xmlnsURI, name, ename.ns);\n  }\n\n  let caretNode: Node | null = el;\n  if (mode.getModeOptions().autoinsert as boolean) {\n    _autoinsert(el, editor);\n\n    // Set el to the deepest first child, so that the caret is put in the right\n    // position.\n    while (caretNode !== null) {\n      const child: Node | null = caretNode.firstChild;\n      if (child === null) {\n        break;\n      }\n      caretNode = child;\n    }\n  }\n  editor.caretManager.setCaret(caretNode, 0);\n}\n\nfunction executeUnwrap(editor: EditorAPI, data: TransformationData): void {\n  const node = data.node;\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n  const parent = node.parentNode!;\n  const index = indexOf(parent.childNodes, node);\n  unwrap(editor.dataUpdater, node);\n  editor.caretManager.setCaret(parent, index);\n}\n\nfunction executeWrap(editor: EditorAPI, data: NamedTransformationData): void {\n  const sel = editor.caretManager.sel;\n  if (sel == null) {\n    throw new Error(\"wrap transformation called with undefined range\");\n  }\n\n  if (sel.collapsed as boolean) {\n    throw new Error(\"wrap transformation called with collapsed range\");\n  }\n  const [startCaret, endCaret] = sel.mustAsDataCarets();\n  const mode = editor.modeTree.getMode(startCaret.node);\n  const ename = mode.getAbsoluteResolver().resolveName(data.name);\n  if (ename === undefined) {\n    throw new Error(`cannot resolve ${data.name}`);\n  }\n  const el = wrapInElement(editor.dataUpdater, startCaret.node,\n                           startCaret.offset, endCaret.node, endCaret.offset,\n                           ename.ns, data.name);\n  const parent = el.parentNode!;\n  editor.caretManager.setCaret(startCaret.make(parent,\n                                  indexOf(parent.childNodes, el) + 1));\n}\n\nfunction executeWrapContent(editor: EditorAPI,\n                            data: NamedTransformationData): void {\n  const toWrap = data.node;\n\n  if (!isElement(toWrap)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const mode = editor.modeTree.getMode(toWrap);\n  const ename = mode.getAbsoluteResolver().resolveName(data.name);\n  if (ename === undefined) {\n    throw new Error(`cannot resolve ${data.name}`);\n  }\n  wrapInElement(editor.dataUpdater, toWrap, 0, toWrap,\n                toWrap.childNodes.length, ename.ns, data.name);\n}\n\nfunction executeDeleteElement(editor: EditorAPI,\n                              data: TransformationData): void {\n  const node = data.node;\n\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const parent = node.parentNode!;\n  const index = indexOf(parent.childNodes, node);\n  const guiLoc = editor.caretManager.fromDataLocation(node, 0) as DLoc;\n  // If the node we start with is an Element, then the node in guiLoc is\n  // necessarily an Element too.\n  if (!(guiLoc.node as Element).classList.contains(\"_readonly\")) {\n    editor.dataUpdater.removeNode(node);\n    editor.caretManager.setCaret(parent, index);\n  }\n}\n\nfunction executeDeleteParent(editor: EditorAPI,\n                             data: TransformationData): void {\n  const node = data.node;\n\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const parent = node.parentNode!;\n  const index = indexOf(parent.childNodes, node);\n  const guiLoc = editor.caretManager.mustFromDataLocation(node, 0);\n  // If the node we start with is an Element, then the node in guiLoc is\n  // necessarily an Element too.\n  if (!(guiLoc.node as Element).classList.contains(\"_readonly\")) {\n    editor.dataUpdater.removeNode(node);\n    editor.caretManager.setCaret(parent, index);\n  }\n}\n\nfunction executeAddAttribute(editor: EditorAPI,\n                             data: NamedTransformationData): void {\n  const node = data.node;\n\n  if (!isElement(node)) {\n    throw new Error(\"node must be an element\");\n  }\n\n  const guiLoc = editor.caretManager.mustFromDataLocation(node, 0);\n  // If the node we start with is an Element, then the node in guiLoc is\n  // necessarily an Element too.\n  if (!(guiLoc.node as Element).classList.contains(\"_readonly\")) {\n    editor.dataUpdater.setAttribute(node, data.name, \"\");\n    const attr = node.getAttributeNode(data.name);\n    editor.caretManager.setCaret(attr, 0);\n  }\n}\n\nfunction executeDeleteAttribute(editor: EditorAPI,\n                                data: TransformationData): void {\n  const node = data.node;\n\n  if (node == null || !isAttr(node)) {\n    throw new Error(\"node must be an attribute\");\n  }\n\n  const element = node.ownerElement;\n  const caretManager = editor.caretManager;\n  const guiOwnerLoc = caretManager.mustFromDataLocation(element, 0);\n  // If the node we start with is an Element, then the node in guiOwnerLoc\n  // is necessarily an Element too.\n  const guiOwner = guiOwnerLoc.node as Element;\n  if (!guiOwner.classList.contains(\"_readonly\")) {\n    const encoded = node.name;\n    const startLabel = childByClass(guiOwner, \"__start_label\")!;\n\n    // An earlier version of this code relied on the order of attributes in the\n    // data tree. However, this order is not consistent from platform to\n    // platform. Using the order of attributes in the GUI is\n    // consistent. Therefore we go to the GUI to find the next attribute.\n\n    const values = startLabel.getElementsByClassName(\"_attribute_value\");\n\n    // We have to get the parent node because fromDataLocation brings us to the\n    // text node that contains the value.\n    const guiNode = caretManager.mustFromDataLocation(node, 0).node.parentNode;\n    const index = indexOf(values, guiNode!);\n    const nextGUIValue = values[index + 1];\n    const nextAttr = nextGUIValue != null ?\n      editor.toDataNode(nextGUIValue) : null;\n\n    editor.dataUpdater.setAttribute(element, encoded, null);\n\n    // We set the caret inside the next attribute, or if it does not exist,\n    // inside the label.\n    if (nextAttr !== null) {\n      editor.caretManager.setCaret(nextAttr, 0);\n    }\n    else {\n      editor.caretManager.setCaret(\n        guiOwner.getElementsByClassName(\"_element_name\")[0], 0);\n    }\n  }\n}\n\n/**\n * @param forEditorAPI The editor for which to create transformations.\n */\nexport function makeTagTr(forEditor: EditorAPI):\nRecord<string, Transformation<TransformationData>> {\n  const ret: Record<string, Transformation<TransformationData>> =\n    Object.create(null);\n  ret.insert = new Transformation(forEditor, \"insert\", \"Create new <name>\",\n                                  \"\", executeInsert);\n  ret.unwrap = new Transformation(forEditor, \"unwrap\",\n                                  \"Unwrap the content of this element\",\n                                  undefined, executeUnwrap);\n  ret.wrap = new Transformation(forEditor, \"wrap\", \"Wrap in <name>\",\n                                undefined, executeWrap);\n  ret[\"wrap-content\"] = new Transformation(forEditor, \"wrap-content\",\n                                           \"Wrap content in <name>\", undefined,\n                                           executeWrapContent);\n  ret[\"delete-element\"] = new Transformation(forEditor, \"delete-element\",\n                                             \"Delete this element\", undefined,\n                                             executeDeleteElement);\n  ret[\"delete-parent\"] = new Transformation(forEditor, \"delete-parent\",\n                                            \"Delete <name>\", undefined,\n                                            executeDeleteParent);\n  ret[\"add-attribute\"] = new Transformation(forEditor, \"add-attribute\",\n                                            \"Add @<name>\", undefined,\n                                            executeAddAttribute);\n  ret[\"delete-attribute\"] = new Transformation(forEditor, \"delete-attribute\",\n                                               \"Delete this attribute\",\n                                               undefined,\n                                               executeDeleteAttribute);\n  ret[\"insert-text\"] = new Transformation(\n       forEditor, \"insert-text\",\n     \"Insert \\\"<name>\\\"\", undefined,\n    (editor: EditorAPI, data: NamedTransformationData) => {\n      editor.insertText(data.name);\n    });\n  ret.split = forEditor.splitNodeTr;\n\n  return ret;\n}\n\n//  LocalWords:  TransformationRegistry Mangalam MPL Dubeau autoinsertion ie el\n//  LocalWords:  autoinsert enterStartTag moveCaretTo xmlns guiLoc readonly\n//  LocalWords:  guiOwnerLoc fromDataLocation\n"]}