/**
 * Search and replace engine common to quick search and more complex searches.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright Mangalam Research Center for Buddhist Languages
 */
import { CaretManager } from "../caret-manager";
import { DLoc, DLocRange } from "../dloc";
import { isWellFormedRange} from "../domutil";
import { Context, Direction, Search } from "../search";
import { Editor } from "../wed";
import { Scroller } from "./scroller";

export { Context, Direction };

export interface SearchOptions {
  direction: Direction;
  context: Context;
};

export class SearchReplace {
  private search: Search;
  private readonly caretManager: CaretManager;
  private highlight: Element | undefined;
  private lastMatch: DLocRange | null = null;

  constructor(private readonly editor: Editor,
              private readonly scroller: Scroller) {
    this.caretManager = this.editor.caretManager;
    const sel = this.caretManager.sel;
    const scope = (sel !== undefined && !sel.collapsed) ?
      new DLocRange(sel.anchor, sel.focus) : undefined;
    const start = this.caretManager.caret;
    if (start === undefined) {
      throw new Error("search without a caret!");
    }
    this.search = new Search(this.caretManager, editor.guiRoot, start, scope);
  }

  get current(): DLocRange | undefined | null {
    return this.search.current;
  }

  get canReplace(): boolean {
    const current = this.search.current;
    if (current == null) {
      return false;
    }

    return isWellFormedRange(current.mustGetDOMRange());
  }

  updatePattern(value: string, options: SearchOptions): void {
    this.search.pattern = value;
    this.search.direction = options.direction;
    this.search.context = options.context;
    this.updateHighlight(this.search.updateCurrent());
  }

  next(options: SearchOptions): void {
    this.search.direction = options.direction;
    this.search.context = options.context;
    this.updateHighlight(this.search.next());
  }

  updateHighlight(match: DLocRange | null): void {
    if (this.highlight !== undefined) {
      this.highlight.parentNode!.removeChild(this.highlight);
      this.highlight = undefined;
    }

    if (match !== null) {
      this.lastMatch = match;
      const range = match.start.mustMakeDLocRange(match.end);
      const domRange = range.mustGetDOMRange();
      this.highlight = this.caretManager.highlightRange(range);
      const scRect = this.scroller.getBoundingClientRect();
      const rect = domRange.nativeRange.getBoundingClientRect();
      const leftOffset = this.scroller.scrollLeft - scRect.left;
      const topOffset = this.scroller.scrollTop - scRect.top;

      this.scroller.scrollIntoView(rect.left + leftOffset,
                                   rect.top + topOffset,
                                   rect.right + leftOffset,
                                   rect.bottom + topOffset);
    }
  }

  setCaretToMatch(): void {
    if (this.lastMatch !== null) {
      let loc: DLoc;
      const direction = this.search.direction;
      switch (direction) {
      case Direction.FORWARD:
        loc = this.lastMatch.end;
        break;
      case Direction.BACKWARDS:
        loc = this.lastMatch.start;
        break;
      default:
        const d: never = direction;
        throw new Error(`unknown direction: ${d}`);
      }

      this.caretManager.setCaret(loc);
    }
  }

  replace(value: string): void {
    if (!this.canReplace) {
      throw new Error("tried to replace when it is not possible");
    }

    const textUndo = this.editor.initiateTextUndo();
    const { start, end } = this.current;
    const dataStart = this.editor.caretManager.toDataLocation(start)!;
    const dataEnd = this.editor.caretManager.toDataLocation(end)!;
    const cutRet = this.editor.dataUpdater.cut(dataStart, dataEnd)[0];
    this.caretManager.setCaret(cutRet, { textEdit: true });
    textUndo.recordCaretAfter();
  }
}
