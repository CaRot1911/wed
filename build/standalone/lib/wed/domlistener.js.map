{"version":3,"sources":["../../../wed/domlistener.ts"],"names":[],"mappings":"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","file":"domlistener.js","sourcesContent":["/**\n * Listener for DOM tree changes.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { isElement } from \"./domtypeguards\";\nimport { BeforeDeleteNodeEvent, DeleteNodeEvent, InsertNodeAtEvent,\n         SetAttributeNSEvent, SetTextNodeValueEvent,\n         TreeUpdater } from \"./tree-updater\";\n\nexport type Handler = () => void;\nexport type SelectorHandlerPair<H> = [string, H];\n\n/**\n * Called when a **tree fragment** is added which contains the element matched\n * by the selector that was passed to [[Listener.addHandler]].\n *\n * @param root The root of the tree being listened on.\n *\n * @param tree The node which is at the root of the tree *fragment* that was\n * added to trigger the event.\n *\n * @param parent The parent of the tree.\n *\n * @param previousSibling The sibling that precedes ``tree``.\n *\n * @param nextSibling The sibling that follows ``tree``.\n *\n * @param element The element that was matched.\n */\nexport type IncludedElementHandler = (root: Node, tree: Node, parent: Node,\n                                      previousSibling: Node | null,\n                                      nextSibling: Node | null,\n                                      element: Element) => void;\n\n/**\n * Called when a **tree fragment** is removed which contains the element matched\n * by the selector that was passed to [[Listener.addHandler]].\n *\n * @param root The root of the tree being listened on.\n *\n * @param tree The node which is at the root of the tree *fragment* that was\n * removed to trigger the event.\n *\n * @param parent ``null`` because the tree no longer has a parent.\n *\n * @param previousSibling ``null`` because the tree no longer has siblings.\n *\n * @param nextSibling ``null`` because the tree no longer has siblings.\n *\n * @param element The element that was matched.\n */\nexport type ExcludedElementHandler = (root: Node, tree: Node, parent: null,\n                                      previousSibling: null,\n                                      nextSibling: null,\n                                      element: Element) => void;\n\n/**\n * Called when a **tree fragment** is about to be removed and contains the\n * element matched by the selector that was passed to [[Listener.addHandler]].\n *\n * @param root The root of the tree being listened on.\n *\n * @param tree The node which is at the root of the tree *fragment* that is\n * being removed.\n *\n * @param parent The parent of the tree.\n *\n * @param previousSibling The sibling that precedes ``tree``.\n *\n * @param nextSibling The sibling that follows ``tree``.\n *\n * @param element The element that was matched.\n */\nexport type ExcludingElementHandler = (root: Node, tree: Node, parent: null,\n                                       previousSibling: null,\n                                       nextSibling: null,\n                                       element: Element) => void;\n\n/**\n * Called when an element has been directly added to the tree.  There is no\n * reason to provide ``parent``, ``previousSibling``, ``nextSibling`` for an\n * ``added-element`` event but having the same signature for additions and\n * removals allows use of the same function for both cases.\n *\n * @param root The root of the tree being listened on.\n *\n * @param parent The parent of the element that was added.\n *\n * @param previousSibling The sibling that precedes the element.\n *\n * @param nextSibling The sibling that follows the element.\n *\n * @param element The element that was matched.\n */\nexport type AddedElementHandler = (root: Node, parent: Node,\n                                   previousSibling: Node, nextSibling: Node,\n                                   element: Element) => void;\n\n/**\n * Called when an element is about to be directly removed from the tree.\n *\n * @param root The root of the tree being listened on.\n *\n * @param parent The parent of the element that was added.\n *\n * @param previousSibling The sibling that precedes the element.\n *\n * @param nextSibling The sibling that follows the element.\n *\n * @param element The element that was matched.\n */\nexport type RemovingElementHandler = (root: Node, parent: Node,\n                                      previousSibling: Node, nextSibling: Node,\n                                      element: Element) => void;\n\n/**\n * Called when an element is has been directly removed from the tree.\n *\n * @param root The root of the tree being listened on.\n *\n * @param parent ``null`` because the element is no longer in the tree.\n *\n * @param previousSibling ``null`` because the element is no longer in the tree.\n *\n * @param nextSibling ``null`` because the element is no longer in the tree.\n *\n * @param element The element that was matched.\n */\nexport type RemovedElementHandler = (root: Node, parent: null,\n                                     previousSibling: null, nextSibling: null,\n                                     element: Element) => void;\n\n/**\n * Called when children are about to be *removed* from an element. Note the\n * asymmetry: **these handlers are not called when nodes are added!!**\n *\n * @param root The root of the tree being listened on.\n *\n * @param added The nodes that are about to be added. This will always be an\n * empty list.\n *\n * @param removed The nodes that are about to be removed.\n *\n * @param previousSibling: The node before the list of nodes to be removed.\n *\n * @param nextSibling: The node after the list of nodes to be removed.\n *\n * @param element: The element whose children are being removed.\n */\nexport type ChildrenChangingHandler = (root: Node, added: Node[],\n                                       removed: Node[],\n                                       previousSibling: Node | null,\n                                       nextSibling: Node | null,\n                                       element: Element) => void;\n\n/**\n * Called when children of an element have been added to or removed from the\n * element. Note that the listener will call handlers with at most one of\n * ``added`` or ``removed`` non-empty.\n *\n * @param root The root of the tree being listened on.\n *\n * @param added The nodes that were added.\n *\n * @param removed The nodes that were removed.\n *\n * @param previousSibling: The node before the list of nodes added or\n * removed. When the handler is called after a removal of children, this is\n * necessarily ``null``.\n *\n * @param nextSibling: The node after the list of nodes added or removed. When\n * the handler is called after a removal of children, this is necessarily\n * ``null``.\n *\n * @param element: The element whose children were modified.\n */\nexport type ChildrenChangedHandler = (root: Node, added: Node[],\n                                      removed: Node[],\n                                      previousSibling: Node | null,\n                                      nextSibling: Node | null,\n                                      element: Element) => void;\n\n/**\n * Called when a text node has its value changed.  A ``text-changed`` event is\n * not generated when Node objects of type ``TEXT_NODE`` are added or\n * removed. They trigger ``children-changed`` events.\n *\n * @param root The root of the tree being listened on.\n *\n * @param node The text node that was changed.\n *\n * @param oldValue The value the node had before this change.\n */\nexport type TextChangedHandler = (root: Node, node: Text,\n                                  oldValue: string) => void;\n\n/**\n * Called when an attribute value has been changed.\n *\n * @param root The root of the tree being listened on.\n *\n * @param element The element whose attribute changed.\n *\n * @param ns The URI of the namespace of the attribute.\n *\n * @param name The name of the attribute.\n *\n * @param oldValue The value of the attribute before this change.\n */\nexport type AttributeChangedHandler = (root: Node, element: Element, ns: string,\n                                       name: string, oldValue: string) => void;\n\n/**\n * A ``trigger`` event with name ``[name]`` is fired when ``trigger([name])`` is\n * called. Trigger events are meant to be triggered by event handlers called by\n * the Listener, not by other code.\n */\nexport type TriggerHandler = (root: Node) => void;\n\nexport interface EventHandlers {\n  \"included-element\": IncludedElementHandler;\n  \"excluded-element\": ExcludedElementHandler;\n  \"excluding-element\": ExcludingElementHandler;\n  \"added-element\": AddedElementHandler;\n  \"removing-element\": RemovingElementHandler;\n  \"removed-element\": RemovedElementHandler;\n  \"children-changing\": ChildrenChangingHandler;\n  \"children-changed\": ChildrenChangedHandler;\n  \"text-changed\": TextChangedHandler;\n  \"attribute-changed\": AttributeChangedHandler;\n}\n\nexport interface Handlers extends EventHandlers {\n  \"trigger\": TriggerHandler;\n}\n\nexport type Events = keyof EventHandlers;\n\nexport type EventsOrTrigger = keyof Handlers;\n\nexport type EventHandlerMap =\n  { [name in Events]: SelectorHandlerPair<EventHandlers[name]>[] };\n\ntype ChildEvents = \"children-changing\" | \"children-changed\";\ntype AddRemEvents = \"added-element\" | \"removed-element\" | \"removing-element\";\ntype IncludeExcludeEvents = \"included-element\" | \"excluded-element\" |\n  \"excluding-element\";\n\ninterface CallSpec<T extends Events> {\n  fn: EventHandlers[T];\n  // tslint:disable-next-line:no-any\n  params: any[];\n}\n\n/**\n * This class models a listener designed to listen to changes to a DOM tree and\n * fire events on the basis of the changes that it detects.\n *\n * An  ``included-element``  event is  fired  when  an  element appears  in  the\n * observed tree  whether it is directly  added or added because  its parent was\n * added.     The    opposite     events    are     ``excluding-element``    and\n * ``excluded-element``.  The event  ``excluding-element`` is  generated *before\n * the tree fragment is removed, and ``excluded-element`` *after*.\n *\n * An ``added-element`` event is fired when an element is directly added to the\n * observed tree. The opposite events are ``excluding-element`` and\n * ``removed-element``.\n *\n * A ``children-changing`` and ``children-changed`` event are fired when an\n * element's children are being changed.\n *\n * A ``text-changed`` event is fired when a text node has changed.\n *\n * An ``attribute-changed`` is fired when an attribute has changed.\n *\n * A ``trigger`` event with name ``[name]`` is fired when ``trigger([name])`` is\n * called. Trigger events are meant to be triggered by event handlers called by\n * the Listener, not by other code.\n *\n * <h2>Example</h2>\n *\n * Consider the following HTML fragment:\n *\n *     <ul>\n *      <li>foo</li>\n *     </ul>\n *\n * If the fragment is added to a ``<div>`` element, an ``included-element``\n * event will be generated for ``<ul>`` and ``<li>`` but an ``added-element``\n * event will be generated only for ``<ul>``. A ``changed-children`` event will\n * be generated for the parent of ``<ul>``.\n *\n * If the fragment is removed, an ``excluding-element`` and ``excluded-element``\n * event will be generated for ``<ul>`` and ``<li>`` but a ``removing-element``\n * and ``remove-element`` event will be generated only for ``<ul>``. A\n * ``children-changing`` and ``children-changed`` event will be generated for\n * the parent of ``<ul>``.\n *\n * The order in which handlers are added matters. The Listener provides the\n * following guarantee: for any given type of event, the handlers will be called\n * in the order that they were added to the listener.\n *\n * <h2>Warnings:</h2>\n *\n * - Keep in mind that the the ``children-changed``, ``excluded-element`` and\n *   ``removed-element`` events are generated **after** the DOM operation that\n *   triggers them. This has some consequences. In particular, a selector that\n *   will work perfectly with ``removing-element`` or ``excluding-element`` may\n *   not work with ``removed-element`` and ``excluded-element``. This would\n *   happen if the selector tests for ancestors of the element removed or\n *   excluded. By the time the ``-ed`` events are generated, the element is gone\n *   from the DOM tree and such selectors will fail.\n *\n *   The ``-ed`` version of these events are still useful. For instance, a wed\n *   mode in use for editing scholarly articles listens for ``excluded-element``\n *   with a selector that is a tag name so that it can remove references to\n *   these elements when they are removed. Since it does not need anything more\n *   complex then ``excluded-element`` works perfectly.\n *\n * - A Listener does not verify whether the parameters passed to handlers are\n *   part of the DOM tree. For instance, handler A could operate on element X so\n *   that it is removed from the DOM tree. If there is already another mutation\n *   on X in the pipeline by the time A is called and handler B is called to\n *   deal with it, then by the time B is run X will no longer be part of the\n *   tree.\n *\n *   To put it differently, even if when an event is generated element X was\n *   part of the DOM tree, it is possible that by the time the handlers that\n *   must be run for that mutation are run, X is no longer part of the DOM tree.\n *\n *   Handlers that care about whether they are operating on elements that are in\n *   the DOM tree should perform a test themselves to check whether what is\n *   passed to them is still in the tree.\n *\n *   The handlers fired on removed-elements events work on nodes that have been\n *   removed from the DOM tree. To know what was before and after these nodes\n *   **before** they were removed use events that have ``previous_sibling`` and\n *   ``next_sibling`` parameters, because it is likely that the nodes themselves\n *   will have both their ``previousSibling`` and ``nextSibling`` set to\n *   ``null``.\n *\n * - Handlers that are fired on children-changed events, **and** which modify\n *   the DOM tree can easily result in infinite loops. Care should be taken\n *   early in any such handler to verify that the kind of elements added or\n *   removed **should** result in a change to the DOM tree, and ignore those\n *   changes that are not relevant.\n */\n\nexport class Listener {\n  private readonly eventHandlers: EventHandlerMap = {\n      \"included-element\": [],\n      \"added-element\": [],\n      \"excluded-element\": [],\n      \"excluding-element\": [],\n      \"removed-element\": [],\n      \"removing-element\": [],\n      \"children-changed\": [],\n      \"children-changing\": [],\n      \"text-changed\": [],\n      \"attribute-changed\": [],\n  };\n\n  private readonly triggerHandlers: { [key: string]: TriggerHandler[] }\n    = Object.create(null);\n  private triggersToFire: { [key: string]: number } = Object.create(null);\n  private stopped: boolean = true;\n  private scheduledProcessTriggers: number | undefined;\n\n  /**\n   * @param root The root of the DOM tree about which the listener should listen\n   * to changes.\n   */\n  constructor(private readonly root: Node,\n              private readonly updater: TreeUpdater) {\n    this.updater.events.subscribe((ev) => {\n      switch (ev.name) {\n      case \"InsertNodeAt\":\n        this._insertNodeAtHandler(ev);\n        break;\n      case \"SetTextNodeValue\":\n        this._setTextNodeValueHandler(ev);\n        break;\n      case \"BeforeDeleteNode\":\n        this._beforeDeleteNodeHandler(ev);\n        break;\n      case \"DeleteNode\":\n        this._deleteNodeHandler(ev);\n        break;\n      case \"SetAttributeNS\":\n        this._setAttributeNSHandler(ev);\n        break;\n      default:\n        // Do nothing...\n      }\n    });\n  }\n\n  /**\n   * Start listening to changes on the root passed when the object was\n   * constructed.\n   */\n  startListening(): void {\n    this.stopped = false;\n  }\n\n  /**\n   * Stops listening to DOM changes.\n   */\n  stopListening(): void {\n    this.stopped = true;\n  }\n\n  /**\n   * Process all changes immediately.\n   */\n  processImmediately(): void {\n    if (this.scheduledProcessTriggers !== undefined) {\n      this.clearPending();\n      this._processTriggers();\n    }\n  }\n\n  /**\n   * Clear anything that is pending. Some implementations may have triggers\n   * delivered asynchronously.\n   */\n  clearPending(): void {\n    if (this.scheduledProcessTriggers !== undefined) {\n      window.clearTimeout(this.scheduledProcessTriggers);\n      this.scheduledProcessTriggers = undefined;\n    }\n  }\n\n  /**\n   * Adds an event handler or a trigger handler. Note that if you want to add a\n   * trigger handler, the first argument must be a single string, due to how the\n   * 2nd argument is interpreted.\n   *\n   * @param eventTypes Either a string naming the event this handler will\n   * process or an array of strings if multiple types of events are to be\n   * handled.\n   *\n   * @param selector When adding an event handler, this argument is a CSS\n   * selector. When adding a trigger handler, this argument is a trigger name.\n   *\n   *   Note that the meaning of the ``selector`` parameter for ``text-changed``\n   *   events is different than the usual. Whereas for all other handlers, the\n   *   ``selector`` matches the ``element`` parameter passed to the handlers, in\n   *   the case of a ``text-changed`` event the ``selector`` matches the\n   *   **parent** of the ``node`` parameter.\n   *\n   * @param handler The handler to be called by this listener when the events\n   * specified in ``eventTypes`` occur.\n   *\n   * @throws {Error} If an event is unrecognized.\n   */\n  addHandler(eventType: \"trigger\", selector: string,\n             handler: TriggerHandler): void;\n  addHandler<T extends Events>(eventType: T, selector: string,\n                               handler: EventHandlers[T]): void;\n  addHandler<T extends Events>(eventType: T | \"trigger\", selector: string,\n                               handler: EventHandlers[T] | TriggerHandler):\n  void {\n    if (eventType === \"trigger\") {\n      let handlers = this.triggerHandlers[selector];\n      if (handlers === undefined) {\n        handlers = this.triggerHandlers[selector] = [];\n      }\n\n      handlers.push(handler as TriggerHandler);\n    }\n    else {\n      // As of TS 2.2.2, we need to the type annotation in the next line.\n      const pairs: SelectorHandlerPair<EventHandlers[T]>[] =\n        this.eventHandlers[eventType];\n      if (pairs === undefined) {\n        throw new Error(`invalid eventType: ${eventType}`);\n      }\n\n      pairs.push([selector, handler]);\n    }\n  }\n\n  /**\n   * Tells the listener to fire the named trigger as soon as possible.\n   *\n   * @param {string} name The name of the trigger to fire.\n   */\n  trigger(name: string): void {\n    this.triggersToFire[name] = 1;\n  }\n\n  /**\n   * Processes pending triggers.\n   */\n  protected _processTriggers(): void {\n    let keys = Object.keys(this.triggersToFire);\n    while (keys.length > 0) {\n      // We flush the map because the triggers could trigger\n      // more triggers. This also explains why we are in a loop.\n      this.triggersToFire = Object.create(null);\n\n      const triggerMap = this.triggerHandlers;\n      for (const key of keys) {\n        const handlers = triggerMap[key];\n        if (handlers !== undefined) {\n          for (const handler of handlers) {\n            this._callHandler(handler);\n          }\n        }\n      }\n\n      // See whether there is more to trigger.\n      keys = Object.keys(this.triggersToFire);\n    }\n  }\n\n  /**\n   * Utility function for calling event handlers.\n   *\n   * @param handler The handler.\n   *\n   * @param rest The arguments to pass to the handler.\n   */\n  // tslint:disable-next-line:no-any\n  protected _callHandler(handler: Function, ...rest: any[]): void {\n    rest.unshift(this.root);\n    handler.apply(undefined, rest);\n  }\n\n  /**\n   * Handles node additions.\n   *\n   * @param ev The event.\n   */\n  private _insertNodeAtHandler(ev: InsertNodeAtEvent): void {\n    if (this.stopped) {\n      return;\n    }\n\n    const parent = ev.parent as Element;\n    const node = ev.node;\n    const ccCalls = this._childrenCalls(\n      \"children-changed\",\n      parent, [node], [], node.previousSibling, node.nextSibling);\n\n    let arCalls: CallSpec<\"added-element\">[] = [];\n    let ieCalls: CallSpec<\"included-element\">[] = [];\n    if (isElement(node)) {\n      arCalls = this._addRemCalls(\"added-element\", node, parent);\n      ieCalls = this._incExcCalls(\"included-element\", node, parent);\n    }\n\n    const toCall = (ccCalls as CallSpec<Events>[]).concat(arCalls, ieCalls);\n    for (const call of toCall) {\n      this._callHandler.call(this, call.fn, ...call.params);\n    }\n\n    this._scheduleProcessTriggers();\n  }\n\n  /**\n   * Handles node deletions.\n   *\n   * @param ev The event.\n   */\n  private _beforeDeleteNodeHandler(ev: BeforeDeleteNodeEvent): void {\n    if (this.stopped) {\n      return;\n    }\n\n    const node = ev.node;\n    const parent = node.parentNode as Element;\n    const ccCalls = this._childrenCalls(\n      \"children-changing\",\n      parent, [], [node], node.previousSibling, node.nextSibling);\n\n    let arCalls: CallSpec<\"removing-element\">[] = [];\n    let ieCalls: CallSpec<\"excluding-element\">[] = [];\n    if (isElement(node)) {\n      arCalls = this._addRemCalls(\"removing-element\", node, parent);\n      ieCalls = this._incExcCalls(\"excluding-element\", node, parent);\n    }\n\n    const toCall = (ccCalls as CallSpec<Events>[]).concat(arCalls, ieCalls);\n    for (const call of toCall) {\n      this._callHandler.call(this, call.fn, ...call.params);\n    }\n\n    this._scheduleProcessTriggers();\n  }\n\n  /**\n   * Handles node deletion events.\n   *\n   * @param ev The event.\n   */\n  private _deleteNodeHandler(ev: DeleteNodeEvent): void {\n    if (this.stopped) {\n      return;\n    }\n\n    const node = ev.node;\n    const parent = ev.formerParent as Element;\n    const ccCalls = this._childrenCalls(\n      \"children-changed\", parent, [], [node], null, null);\n\n    let arCalls: CallSpec<\"removed-element\">[] = [];\n    let ieCalls: CallSpec<\"excluded-element\">[] = [];\n    if (isElement(node)) {\n      arCalls = this._addRemCalls(\"removed-element\", node, parent);\n      ieCalls = this._incExcCalls(\"excluded-element\", node, parent);\n    }\n\n    const toCall = (ccCalls as CallSpec<Events>[]).concat(arCalls, ieCalls);\n    for (const call of toCall) {\n      this._callHandler.call(this, call.fn, ...call.params);\n    }\n\n    this._scheduleProcessTriggers();\n  }\n\n  /**\n   * Produces the calls for ``children-...`` events.\n   *\n   * @param call The type of call to produce.\n   *\n   * @param parent The parent of the children that have changed.\n   *\n   * @param added Added children.\n   *\n   * @param removed Removed children.\n   *\n   * @param prev Node preceding the children.\n   *\n   * @param next Node following the children.\n   *\n   * @returns A list of call specs.\n   */\n  private _childrenCalls<T extends ChildEvents>(call: T,\n                                                parent: Element,\n                                                added: Node[], removed: Node[],\n                                                prev: Node | null,\n                                                next: Node | null):\n  CallSpec<T>[] {\n    if (added.length !== 0 && removed.length !== 0) {\n      throw new Error(\"we do not support having nodes added \" +\n                      \"and removed in the same event\");\n    }\n\n    const pairs = this.eventHandlers[call];\n    const ret = [];\n\n    // Go over all the elements for which we have handlers\n    for (const [sel, fn] of pairs) {\n      if (parent.matches(sel)) {\n        ret.push({ fn, params: [added, removed, prev, next, parent] });\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Handles text node changes events.\n   *\n   * @param ev The event.\n   */\n  private _setTextNodeValueHandler(ev: SetTextNodeValueEvent): void {\n    if (this.stopped) {\n      return;\n    }\n\n    const pairs = this.eventHandlers[\"text-changed\"];\n    const node = ev.node;\n\n    // Go over all the elements for which we have\n    // handlers\n    const parent = node.parentNode as Element;\n    for (const [sel, fn] of pairs) {\n      if (parent.matches(sel)) {\n        this._callHandler(fn, node, ev.oldValue);\n      }\n    }\n\n    this._scheduleProcessTriggers();\n  }\n\n  /**\n   * Handles attribute change events.\n   *\n   * @param ev The event.\n   */\n  private _setAttributeNSHandler(ev: SetAttributeNSEvent): void {\n    if (this.stopped) {\n      return;\n    }\n\n    const target = ev.node;\n\n    // Go over all the elements for which we have handlers\n    const pairs = this.eventHandlers[\"attribute-changed\"];\n    for (const [sel, fn] of pairs) {\n      if (target.matches(sel)) {\n        this._callHandler(fn, target, ev.ns, ev.attribute, ev.oldValue);\n      }\n    }\n\n    this._scheduleProcessTriggers();\n  }\n\n  /**\n   * Sets a timeout to run the triggers that must be run.\n   */\n  private _scheduleProcessTriggers(): void {\n    if (this.scheduledProcessTriggers !== undefined) {\n      return;\n    }\n    this.scheduledProcessTriggers = window.setTimeout(() => {\n      this.scheduledProcessTriggers = undefined;\n      this._processTriggers();\n    },\n                                                      0);\n  }\n\n  /**\n   * Produces the calls for the added/removed family of events.\n   *\n   * @param name The event name.\n   *\n   * @param node The node added or removed.\n   *\n   * @param target The parent of this node.\n   *\n   * @returns A list of call specs.\n   */\n  private _addRemCalls<T extends AddRemEvents>(name: T, node: Element,\n                                               target: Element): CallSpec<T>[] {\n    const pairs = this.eventHandlers[name];\n    const ret = [];\n\n    const prev = node.previousSibling;\n    const next = node.nextSibling;\n    // Go over all the elements for which we have handlers\n    for (const [sel, fn] of pairs) {\n      if (node.matches(sel)) {\n        ret.push({ fn, params: [target, prev, next, node] });\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Produces the calls for included/excluded family of events.\n   *\n   * @param name The event name.\n   *\n   * @param node The node which was included or excluded and for which we must\n   * issue the events.\n   *\n   * @param target The parent of this node.\n   *\n   * @returns A list of call specs.\n   */\n  private _incExcCalls<T extends IncludeExcludeEvents>(name: T, node: Element,\n                                                       target: Element):\n  CallSpec<T>[] {\n    const pairs = this.eventHandlers[name];\n    const prev = node.previousSibling;\n    const next = node.nextSibling;\n    const ret = [];\n\n    // Go over all the elements for which we have handlers\n    for (const [sel, fn] of pairs) {\n      if (node.matches(sel)) {\n        ret.push({ fn, params: [node, target, prev, next, node] });\n      }\n\n      const targets = node.querySelectorAll(sel);\n      for (const subtarget of Array.prototype.slice.call(targets)) {\n        ret.push({ fn, params: [node, target, prev, next, subtarget] });\n      }\n    }\n    return ret;\n  }\n\n}\n//  LocalWords:  DOM Mangalam MPL Dubeau previousSibling li ul\n//  LocalWords:  nextSibling lt domlistener\n"]}