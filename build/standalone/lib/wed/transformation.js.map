{"version":3,"file":"transformation.js","sourceRoot":"","sources":["../../../../lib/wed/transformation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Transformation framework.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport _ from \"lodash\";\nimport { ObjectUnsubscribedError, Subject } from \"rxjs\";\n\nimport { Action } from \"./action\";\nimport { DLoc } from \"./dloc\";\nimport { isDocument, isText } from \"./domtypeguards\";\nimport { Caret, firstDescendantOrSelf, indexOf,\n         isWellFormedRange } from \"./domutil\";\nimport { AbortTransformationException } from \"./exceptions\";\nimport * as icon from \"./gui/icon\";\nimport { EditorAPI } from \"./mode-api\";\nimport { TreeUpdater } from \"./tree-updater\";\n\nconst TYPE_TO_KIND = _.extend(Object.create(null), {\n  // These are not actually type names. It is possible to use a kind name as a\n  // type name if the transformation is not more specific. In this case the kind\n  // === type.\n  add: \"add\",\n  delete: \"delete\",\n  transform: \"transform\",\n\n  insert: \"add\",\n  \"delete-element\": \"delete\",\n  \"delete-parent\": \"delete\",\n  wrap: \"wrap\",\n  \"wrap-content\": \"wrap\",\n  \"merge-with-next\": \"transform\",\n  \"merge-with-previous\": \"transform\",\n  \"swap-with-next\": \"transform\",\n  \"swap-with-previous\": \"transform\",\n  split: \"transform\",\n  append: \"add\",\n  prepend: \"add\",\n  unwrap: \"unwrap\",\n  \"add-attribute\": \"add\",\n  \"delete-attribute\": \"delete\",\n});\n\nconst TYPE_TO_NODE_TYPE = _.extend(Object.create(null), {\n  // These are not actually type names. These are here to handle the\n  // case where the type is actually a kind name. Since they are not\n  // more specific, the node type is set to \"other\". Note that\n  // \"wrap\" and \"unwrap\" are always about elements so there is no\n  // way to have a \"wrap/unwrap\" which has \"other\" for the node\n  // type.\n  add: \"other\",\n  delete: \"other\",\n  transform: \"other\",\n\n  insert: \"element\",\n  \"delete-element\": \"element\",\n  \"delete-parent\": \"element\",\n  wrap: \"element\",\n  \"wrap-content\": \"element\",\n  \"merge-with-next\": \"element\",\n  \"merge-with-previous\": \"element\",\n  \"swap-with-next\": \"element\",\n  \"swap-with-previous\": \"element\",\n  split: \"element\",\n  append: \"element\",\n  prepend: \"element\",\n  unwrap: \"element\",\n  \"add-attribute\": \"attribute\",\n  \"delete-attribute\": \"attribute\",\n});\n\n/**\n * Data passed to the transformation handler. The transformation types expect\n * the following values for the parameters passed to a handler.\n *\n * Transformation Type | `node` is | `name` is the name of the:\n * --------------------|-----------|---------------------------\n * insert | undefined (we insert at caret position) | element to insert\n * delete-element | element to delete | element to delete\n * delete-parent | element to delete | element to delete\n * wrap | undefined (we wrap the current selection) | wrapping element\n * merge-with-next | element to merge | element to merge\n * merge-with-previous | element to merge | element to merge\n * swap-with-next | element to swap | element to swap\n * swap-with-previous | element to swap | element to swap\n * append | element after which to append | element after which to append\n * prepend | element before which to prepend | element before which to append\n * unwrap | node to unwrap | node to unwrap\n * add-attribute | node to which an attribute is added | attribute to add\n * delete-attribute | attribute to delete | attribute to delete\n * insert-text | node to which text is added | text to add\n */\nexport interface TransformationData {\n  /**\n   * The JavaScript event that triggered the transformation, if any.\n   */\n  readonly e?: Event;\n\n  /**\n   * The node to operate on. Should be set by the code that invokes the\n   * transformation. This may be undefined if the transformation should rely on\n   * the caret position.\n   */\n  node?: Node;\n\n  /**\n   * The name of the node to add, remove, etc. Should be set by the code that\n   * invokes the transformation.\n   */\n  name?: string;\n\n  /**\n   * A position to which the caret is moved before the transformation is fired.\n   * **Wed performs the move.** Should be set by the code that invokes the\n   * transformation.\n   */\n  moveCaretTo?: DLoc;\n}\n\nexport interface NamedTransformationData extends TransformationData {\n  name: string;\n}\n\n/**\n * @param editor The editor.\n *\n * @param data The data for the transformation.\n */\nexport type TransformationHandler<Data extends TransformationData> =\n  (editor: EditorAPI, data: Data) => void;\n\nfunction computeIconHtml(iconHtml: string | undefined,\n                         transformationType: string): string | undefined {\n  if (iconHtml !== undefined) {\n    return iconHtml;\n  }\n\n  const kind = TYPE_TO_KIND[transformationType];\n  if (kind !== undefined) {\n    return icon.makeHTML(kind);\n  }\n\n  return undefined;\n}\n\n/**\n * An operation that transforms the data tree.\n */\nexport class Transformation<Data extends TransformationData,\nHandler extends TransformationHandler<Data> = TransformationHandler<Data>>\n  extends Action<Data> {\n  public readonly handler: Handler;\n  public readonly transformationType: string;\n  public readonly kind: string;\n  public readonly nodeType: string;\n\n  /**\n   * @param editor The editor for which this transformation is created.\n   *\n   * @param transformationType The type of transformation.\n   *\n   * @param desc The description of this transformation. A transformation's\n   * [[getDescriptionFor]] method will replace ``<name>`` with the name of the\n   * node actually being processed. So a string like ``Remove <name>`` would\n   * become ``Remove foo`` when the transformation is called for the element\n   * ``foo``.\n   *\n   * @param abbreviatedDesc An abbreviated description of this transformation.\n   *\n   * @param iconHtml An HTML representation of the icon associated with this\n   * transformation.\n   *\n   * @param needsInput Defaults to ``false`` for signatures that do not contain\n   * this parameter. Indicates whether this action needs input from the\n   * user. For instance, an action which brings up a modal dialog to ask\n   * something of the user must have this parameter set to ``true``. It is\n   * important to record whether an action needs input because, to take one\n   * example, the ``autoinsert`` logic will try to insert automatically any\n   * element it can. However, doing this for elements that need user input will\n   * just confuse the user (or could cause a crash). Therefore, it is important\n   * that the insertion operations for such elements be marked with\n   * ``needsInput`` set to ``true`` so that the ``autoinsert`` logic backs off\n   * from trying to insert these elements.\n   *\n   * @param handler The handler to call when this transformation is executed.\n   */\n  constructor(editor: EditorAPI, transformationType: string, desc: string,\n              handler: Handler);\n  constructor(editor: EditorAPI, transformationType: string, desc: string,\n              abbreviatedDesc: string | undefined, handler: Handler);\n  constructor(editor: EditorAPI, transformationType: string, desc: string,\n              abbreviatedDesc: string | undefined, iconHtml: string | undefined,\n              handler: Handler);\n  constructor(editor: EditorAPI, transformationType: string, desc: string,\n              abbreviatedDesc: string | undefined, iconHtml: string | undefined,\n              needsInput: boolean, handler: Handler);\n  constructor(editor: EditorAPI, transformationType: string, desc: string,\n              abbreviatedDesc: string | Handler | undefined,\n              iconHtml?: string | Handler | undefined,\n              needsInput?: boolean | Handler, handler?: Handler) {\n    if (typeof abbreviatedDesc === \"function\") {\n      handler = abbreviatedDesc;\n      super(editor, desc, undefined,\n            computeIconHtml(undefined, transformationType), false);\n    }\n    else {\n      if (!(abbreviatedDesc === undefined ||\n            typeof abbreviatedDesc === \"string\")) {\n        throw new TypeError(\"abbreviatedDesc must be a string or undefined\");\n      }\n\n      if (typeof iconHtml === \"function\") {\n        handler = iconHtml;\n        super(editor, desc, abbreviatedDesc,\n              computeIconHtml(undefined, transformationType), false);\n      }\n      else {\n        if (!(iconHtml === undefined || typeof iconHtml === \"string\")) {\n          throw new TypeError(\"iconHtml must be a string or undefined\");\n        }\n\n        if (typeof needsInput === \"function\") {\n          handler = needsInput;\n\n          super(editor, desc, abbreviatedDesc,\n                computeIconHtml(iconHtml, transformationType), false);\n        }\n        else {\n          if (!(needsInput === undefined || typeof needsInput === \"boolean\")) {\n            throw new TypeError(\"needsInput must be a boolean or undefined\");\n          }\n\n          super(editor, desc, abbreviatedDesc,\n                computeIconHtml(iconHtml, transformationType), needsInput);\n        }\n      }\n    }\n\n    if (handler === undefined) {\n      throw new Error(\"did not specify a handler\");\n    }\n\n    this.handler = handler;\n    this.transformationType = transformationType;\n    this.kind = TYPE_TO_KIND[transformationType];\n    this.nodeType = TYPE_TO_NODE_TYPE[transformationType];\n  }\n\n  getDescriptionFor(data: Data): string {\n    if (data.name === undefined) {\n      return this.desc;\n    }\n\n    return this.desc.replace(/<name>/, data.name);\n  }\n\n  /**\n   * Calls the ``fireTransformation`` method on this transformation's editor.\n   *\n   * @param data The data object to pass.\n   */\n  execute(data: Data): void {\n    this.editor.fireTransformation(this, data);\n  }\n}\n\n/**\n * Transformation events are generated by an editor before and after a\n * transformation is executed. The ``StartTransformation`` event is generated\n * before, and the ``EndTransformation`` is generated after. These events allow\n * modes to perform additional processing before or after a transformation, or\n * to abort a transformation while it is being processed.\n */\nexport class TransformationEvent {\n  private _aborted: boolean = false;\n  private _abortMessage?: string;\n  /**\n   * @param name The name of the event.\n   * @param transformation The transformation to which the event pertains.\n   */\n  constructor(readonly name: \"StartTransformation\" | \"EndTransformation\",\n              readonly transformation: Transformation<TransformationData>) {}\n\n  /** Whether the transformation is aborted. */\n  get aborted(): boolean {\n    return this._aborted;\n  }\n\n  /**\n   * Mark the transformation as aborted. Once aborted, a transformation cannot\n   * be unaborted.\n   */\n  abort(message: string): void {\n    this._aborted = true;\n    this._abortMessage = message;\n  }\n\n  /**\n   * Raise an [[AbortTransformationException]] if the event was marked as\n   * aborted.\n   */\n  throwIfAborted(): void {\n    if (this.aborted) {\n      throw new AbortTransformationException(this._abortMessage!);\n    }\n  }\n}\n\n/**\n * A subject that emits [[TransformationEvent]] objects and immediately stops\n * calling subscribers when the [[TransformationEvent]] object it is processing\n * is aborted.\n */\nexport class TransformationEventSubject extends Subject<TransformationEvent> {\n\n  next(value: TransformationEvent): void {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    if (this.isStopped || value.aborted) {\n      return;\n    }\n\n    for (const observer of this.observers.slice()) {\n      observer.next(value);\n      if (value.aborted) {\n        break;\n      }\n    }\n  }\n}\n\nexport type AttributeTable = Record<string, string>;\n\n/**\n * Makes an element appropriate for a wed data tree.\n *\n * @param doc The document for which to make the element.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name The name of the new element.\n *\n * @param attrs An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n */\nexport function makeElement(doc: Document, ns: string, name: string,\n                            attrs?: AttributeTable): Element {\n  const e = doc.createElementNS(ns, name);\n  if (attrs !== undefined) {\n    // Create attributes\n    const keys = Object.keys(attrs).sort();\n    for (const key of keys) {\n      e.setAttribute(key, attrs[key]);\n    }\n  }\n  return e;\n}\n\n/**\n * Insert an element in a wed data tree.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param parent The parent of the new node.\n *\n * @param index Offset in the parent where to insert the new node.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name The name of the new element.\n *\n * @param attrs An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n */\nexport function insertElement(dataUpdater: TreeUpdater,\n                              parent: Node, index: number, ns: string,\n                              name: string,\n                              attrs?: AttributeTable): Element {\n  const ownerDocument = isDocument(parent) ? parent : parent.ownerDocument;\n  const el = makeElement(ownerDocument, ns, name, attrs);\n  dataUpdater.insertAt(parent, index, el);\n  return el;\n}\n\n/**\n * Wraps a span of text in a new element.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param node The DOM node where to wrap. Must be a text node.\n *\n * @param offset The offset in the node. This parameter specifies where to start\n * wrapping.\n *\n * @param endOffset Offset in the node. This parameter specifies where to end\n * wrapping.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name The name of the wrapping element.\n *\n * @param attrs An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n */\nexport function wrapTextInElement(dataUpdater: TreeUpdater, node: Text,\n                                  offset: number, endOffset: number,\n                                  ns: string, name: string,\n                                  attrs?: AttributeTable): Element {\n  const textToWrap = node.data.slice(offset, endOffset);\n\n  const parent = node.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n  const nodeOffset = indexOf(parent.childNodes, node);\n\n  dataUpdater.deleteText(node, offset, textToWrap.length);\n  const newElement = makeElement(node.ownerDocument, ns, name, attrs);\n\n  if (textToWrap !== \"\") {\n    // It is okay to manipulate the DOM directly as long as the DOM tree being\n    // manipulated is not *yet* inserted into the data tree. That is the case\n    // here.\n    newElement.appendChild(node.ownerDocument.createTextNode(textToWrap));\n  }\n\n  if (node.parentNode === null) {\n    // The entire node was removed.\n    dataUpdater.insertAt(parent, nodeOffset, newElement);\n  }\n  else {\n    dataUpdater.insertAt(node, offset, newElement);\n  }\n\n  return newElement;\n}\n\n/**\n * Utility function for [[wrapInElement]].\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param container The text node to split.\n *\n * @param offset Where to split the node\n *\n * @returns A caret location marking where the split occurred.\n */\nfunction _wie_splitTextNode(dataUpdater: TreeUpdater, container: Text,\n                            offset: number): Caret {\n  const parent = container.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n  const containerOffset = indexOf(parent.childNodes, container);\n  // The first two cases here just return a caret outside of the text node\n  // rather than make a split that will create a useless empty text node.\n  if (offset === 0) {\n    offset = containerOffset;\n  }\n  else if (offset >= container.length) {\n    offset = containerOffset + 1;\n  }\n  else {\n    const text = container.data.slice(offset);\n    dataUpdater.setTextNode(container, container.data.slice(0, offset));\n    dataUpdater.insertNodeAt(parent, containerOffset + 1,\n                             container.ownerDocument.createTextNode(text));\n\n    offset = containerOffset + 1;\n  }\n  return [parent, offset];\n}\n\n/**\n * Wraps a well-formed span in a new element. This span can contain text and\n * element nodes.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param startContainer The node where to start wrapping.\n *\n * @param startOffset The offset where to start wrapping.\n *\n * @param endContainer The node where to end wrapping.\n *\n * @param endOffset The offset where to end wrapping.\n *\n * @param ns The URI of the namespace to use for the new element.\n *\n * @param name The name of the new element.\n *\n * @param [attrs] An object whose fields will become attributes for the new\n * element.\n *\n * @returns The new element.\n *\n * @throws {Error} If the range is malformed or if there is an internal error.\n */\nexport function wrapInElement(dataUpdater: TreeUpdater, startContainer: Node,\n                              startOffset: number, endContainer: Node,\n                              endOffset: number, ns: string, name: string,\n                              attrs?: AttributeTable): Element {\n  if (!isWellFormedRange({ startContainer, startOffset, endContainer,\n                           endOffset })) {\n    throw new Error(\"malformed range\");\n  }\n\n  if (isText(startContainer)) {\n    // We already have an algorithm for this case.\n    if (startContainer === endContainer) {\n      return wrapTextInElement(dataUpdater, startContainer, startOffset,\n                               endOffset, ns, name, attrs);\n    }\n\n    [startContainer, startOffset] =\n      _wie_splitTextNode(dataUpdater, startContainer, startOffset);\n  }\n\n  if (isText(endContainer)) {\n    [endContainer, endOffset] =\n      _wie_splitTextNode(dataUpdater, endContainer, endOffset);\n  }\n\n  if (startContainer !== endContainer) {\n    throw new Error(\"startContainer and endContainer are not the same;\" +\n                    \"probably due to an algorithmic mistake\");\n  }\n\n  const newElement = makeElement(startContainer.ownerDocument, ns, name, attrs);\n  while (--endOffset >= startOffset) {\n    const endNode = endContainer.childNodes[endOffset];\n    dataUpdater.deleteNode(endNode);\n    // Okay to change a tree which is not yet connected to the data tree.\n    newElement.insertBefore(endNode, newElement.firstChild);\n  }\n\n  dataUpdater.insertAt(startContainer, startOffset, newElement);\n\n  return newElement;\n}\n\n/**\n * Replaces an element with its contents.\n *\n * @param dataUpdater A tree updater through which to update the DOM tree.\n *\n * @param node The element to unwrap.\n *\n * @returns The contents of the element.\n */\nexport function unwrap(dataUpdater: TreeUpdater, node: Element): Node[] {\n  const parent = node.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n\n  const children = Array.prototype.slice.call(node.childNodes);\n  const prev = node.previousSibling;\n  const next = node.nextSibling;\n  // This does not merge text nodes, which is what we want. We also want to\n  // remove it first so that we don't generate so many update events.\n  dataUpdater.deleteNode(node);\n\n  // We want to calculate this index *after* removal.\n  let nextIx = (next !== null) ? indexOf(parent.childNodes, next) :\n    parent.childNodes.length;\n\n  const lastChild = node.lastChild;\n\n  // This also does not merge text nodes.\n  while (node.firstChild != null) {\n    dataUpdater.insertNodeAt(parent, nextIx++, node.firstChild);\n  }\n\n  // The order of the next two calls is important. We start at the end because\n  // going the other way around could cause lastChild to leave the DOM tree.\n\n  // Merge possible adjacent text nodes: the last child of the node that was\n  // removed in the unwrapping and the node that was after the node that was\n  // removed in the unwrapping.\n  if (lastChild !== null) {\n    dataUpdater.mergeTextNodes(lastChild);\n  }\n\n  // Merge the possible adjacent text nodes: the one before the start of the\n  // children we unwrapped and the first child that was unwrapped. There may not\n  // be a prev so we use the NF form of the call.\n  dataUpdater.mergeTextNodesNF(prev);\n\n  return children;\n}\n\n/**\n * This function splits a node at the position of the caret. If the caret is not\n * inside the node or its descendants, an exception is raised.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The node to split.\n *\n * @throws {Error} If the caret is not inside the node or its descendants.\n */\nexport function splitNode(editor: EditorAPI, node: Node): void {\n  const caret = editor.caretManager.getDataCaret();\n\n  if (caret === undefined) {\n    throw new Error(\"no caret\");\n  }\n\n  if (!node.contains(caret.node)) {\n    throw new Error(\"caret outside node\");\n  }\n\n  const pair = editor.dataUpdater.splitAt(node, caret);\n  // Find the deepest location at the start of the 2nd element.\n  editor.caretManager.setCaret(firstDescendantOrSelf(pair[1]), 0);\n}\n\n/**\n * This function merges an element with a previous element of the same name. For\n * the operation to go forward, the element must have a previous sibling and\n * this sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to merge with previous.\n */\nexport function mergeWithPreviousHomogeneousSibling(editor: EditorAPI,\n                                                    node: Element): void {\n  const prev = node.previousElementSibling;\n  if (prev === null) {\n    return;\n  }\n\n  if (prev.localName !== node.localName ||\n      prev.namespaceURI !== node.namespaceURI) {\n    return;\n  }\n\n  // We need to record these to set the caret to a good position.\n  const caretPos = prev.childNodes.length;\n  const lastChild = prev.lastChild;\n  const wasText = isText(lastChild);\n  // We need to record this *now* for future use, because it is possible that\n  // the next loop could modify lastChild in place.\n  const textLen = wasText ? (lastChild as Text).length : 0;\n\n  const insertionPoint = prev.childNodes.length;\n  // Reverse order\n  for (let i = node.childNodes.length - 1; i >= 0; --i) {\n    editor.dataUpdater.insertAt(\n      prev, insertionPoint,\n      node.childNodes[i].cloneNode(true) as (Element | Text));\n  }\n\n  if (wasText) {\n    // If wasText is true, lastChild cannot be null.\n    editor.dataUpdater.mergeTextNodes(lastChild!);\n    editor.caretManager.setCaret(prev.childNodes[caretPos - 1], textLen);\n  }\n  else {\n    editor.caretManager.setCaret(prev, caretPos);\n  }\n  editor.dataUpdater.removeNode(node);\n}\n\n/**\n * This function merges an element with a next element of the same name. For the\n * operation to go forward, the element must have a next sibling and this\n * sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to merge with next.\n */\nexport function mergeWithNextHomogeneousSibling(editor: EditorAPI,\n                                                node: Element): void {\n  const next = node.nextElementSibling;\n  if (next === null) {\n    return;\n  }\n\n  mergeWithPreviousHomogeneousSibling(editor, next);\n}\n\n/**\n * This function swaps an element with a previous element of the same name. For\n * the operation to go forward, the element must have a previous sibling and\n * this sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to swap with previous.\n */\nexport function swapWithPreviousHomogeneousSibling(editor: EditorAPI,\n                                                   node: Element): void {\n  const prev = node.previousElementSibling;\n  if (prev === null) {\n    return;\n  }\n\n  if (prev.localName !== node.localName ||\n      prev.namespaceURI !== node.namespaceURI) {\n    return;\n  }\n\n  const parent = prev.parentNode;\n  if (parent === null) {\n    throw new Error(\"detached node\");\n  }\n\n  editor.dataUpdater.removeNode(node);\n  editor.dataUpdater.insertBefore(parent as Element, node, prev);\n  editor.caretManager.setCaret(node);\n}\n\n/**\n * This function swaps an element with a next element of the same name. For the\n * operation to go forward, the element must have a next sibling and this\n * sibling must have the same name as the element being merged.\n *\n * @param editor The editor on which we are to perform the transformation.\n *\n * @param node The element to swap with next.\n */\nexport function swapWithNextHomogeneousSibling(editor: EditorAPI,\n                                               node: Element): void {\n  const next = node.nextElementSibling;\n  if (next === null) {\n    return;\n  }\n\n  swapWithPreviousHomogeneousSibling(editor, next);\n}\n\n/**\n * Remove markup from the current selection. This turns mixed content into pure\n * text. The selection must be well-formed, otherwise the transformation is\n * aborted.\n *\n * @param editor The editor for which we are doing the transformation.\n */\nexport function removeMarkup(editor: EditorAPI): void {\n  const selection = editor.caretManager.sel;\n\n  // Do nothing if we don't have a selection.\n  if (selection === undefined || selection.collapsed) {\n    return;\n  }\n\n  if (!selection.wellFormed) {\n    editor.modals.getModal(\"straddling\").modal();\n    throw new AbortTransformationException(\"selection is not well-formed\");\n  }\n\n  const [start, end] = selection.asDataCarets()!;\n  const cutRet = editor.dataUpdater.cut(start, end);\n  let newText = \"\";\n  const cutNodes = cutRet[1];\n  for (const el of cutNodes) {\n    newText += el.textContent;\n  }\n\n  const insertRet = editor.dataUpdater.insertText(cutRet[0], newText);\n  editor.caretManager.setRange(\n    start.make(insertRet.node!, insertRet.isNew ? cutRet[0].offset : 0),\n    insertRet.caret);\n}\n\n//  LocalWords:  wasText endOffset prepend endContainer startOffset html DOM\n//  LocalWords:  startContainer Mangalam Dubeau previousSibling nextSibling MPL\n//  LocalWords:  insertNodeAt deleteNode mergeTextNodes lastChild prev Prepend\n//  LocalWords:  deleteText domutil\n"]}