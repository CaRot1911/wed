{"version":3,"file":"convert.js","sourceRoot":"","sources":["../../../../lib/wed/convert.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;IAKH,2CAA2C;IAC3C,IAAM,cAAc,GAAW,sCAAsC,CAAC;IAEtE,2CAA2C;IAC3C,IAAM,eAAe,GAAW,+BAA+B,CAAC;IAEhE,qBAAqB,EAAiB;QACpC,IAAI,EAAE,KAAK,IAAI,EAAE;YACf,EAAE,GAAG,EAAE,CAAC;SACT;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA8BG;IACH,oBAA2B,GAAa,EAAE,IAAU;QAClD,IAAI,GAAG,CAAC;QACR,IAAI,yBAAS,CAAC,IAAI,CAAC,EAAE;YACnB,GAAG,GAAG,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YAE/B,GAAG,CAAC,SAAS,GAAM,IAAI,CAAC,OAAO,gBAAW,IAAI,CAAC,SAAS,gBACnD,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,WACjC,CAAC;YACH,EAAE;YACF,kDAAkD;YAClD,EAAE;YACF,sEAAsE;YACtE,+BAA+B;YAC/B,EAAE;YACF,yEAAyE;YACzE,4BAA4B;YAC5B,EAAE;YACF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC/C,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAEhC,GAAG,CAAC,YAAY,CAAC,qBAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;gBACxD,IAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;gBAE7B,oEAAoE;gBACpE,uBAAuB;gBACvB,IAAI,EAAE,KAAK,IAAI,IAAI,EAAE,KAAK,cAAc,IAAI,EAAE,KAAK,eAAe,EAAE;oBAClE,GAAG,CAAC,YAAY,CAAC,qBAAc,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;iBACvD;aACF;YAED,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC5B,OAAO,KAAK,KAAK,IAAI,EAAE;gBACrB,GAAG,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;gBACxC,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;aAC3B;SAEF;aACI,IAAI,sBAAM,CAAC,IAAI,CAAC,EAAE;YACrB,GAAG,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC1C;aACI;YACH,MAAM,IAAI,KAAK,CAAC,0BAAwB,IAAI,CAAC,QAAU,CAAC,CAAC;SAC1D;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IA7CD,gCA6CC;;AAED,6EAA6E;AAC7E,4BAA4B","sourcesContent":["/**\n * Conversion from XML to HTML.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { isElement, isText } from \"./domtypeguards\";\nimport { encodeAttrName } from \"./util\";\n\n// tslint:disable-next-line: no-http-string\nconst XML1_NAMESPACE: string = \"http://www.w3.org/XML/1998/namespace\";\n\n// tslint:disable-next-line: no-http-string\nconst XMLNS_NAMESPACE: string = \"http://www.w3.org/2000/xmlns/\";\n\nfunction normalizeNS(ns: string | null): string {\n  if (ns === null) {\n    ns = \"\";\n  }\n\n  return ns;\n}\n\n/**\n * Convert an XML tree or subtree into an HTML tree suitable to be inserted into\n * the GUI tree.\n *\n * XML Elements are converted to ``div`` elements with a ``class`` that has:\n *\n * - for first class the tag name (qualified name in XML parlance) of the\n *    element,\n *\n * - for second class the ``_local_<local name>`` where ``<local name>`` is the\n *   local name of the element,\n *\n * - for third class ``_xmlns_<namespace uri>`` where ``namespace uri`` is\n *   the URI of the namespace of the XML element,\n *\n * - for fourth class ``_real``.\n *\n * The attributes of the XML element appear on the HTML element with the name\n * ``data-wed-<attribute name>``, where ``attribute name`` is converted by\n * [[encodeAttrName]]. This attribute has for value the original\n * value in the XML. A second attribute ``data-wed--ns-<attribute name>``\n * contains the namespace URI of the attribute. If the attribute was not in a\n * namespace, then ``data-wed--ns-<attribute name>`` is omitted.\n *\n * @param doc The HTML document in which we are going to use the generated\n * tree.\n *\n * @param node The root of the XML tree to convert.\n *\n * @returns The root of the newly created HTML tree.\n */\nexport function toHTMLTree(doc: Document, node: Node): Node {\n  let ret;\n  if (isElement(node)) {\n    ret = doc.createElement(\"div\");\n\n    ret.className = `${node.tagName} _local_${node.localName} \\\n_xmlns_${normalizeNS(node.namespaceURI)} \\\n_real`;\n    //\n    // We encode attributes here in the following way:\n    //\n    // 1. A sequence of three dashes or more gains a dash. So three dashes\n    // becomes 4, 4 becomes 5, etc.\n    //\n    // 2. A colon (which should be present only to mark the prefix) becomes a\n    // sequence of three dashes.\n    //\n    for (let i = 0; i < node.attributes.length; ++i) {\n      const attr = node.attributes[i];\n\n      ret.setAttribute(encodeAttrName(attr.name), attr.value);\n      const ns = attr.namespaceURI;\n\n      // We do not output this attribute if the namespace is for XML v1 or\n      // the xmlns namespace.\n      if (ns !== null && ns !== XML1_NAMESPACE && ns !== XMLNS_NAMESPACE) {\n        ret.setAttribute(encodeAttrName(attr.name, \"ns\"), ns);\n      }\n    }\n\n    let child = node.firstChild;\n    while (child !== null) {\n      ret.appendChild(toHTMLTree(doc, child));\n      child = child.nextSibling;\n    }\n\n  }\n  else if (isText(node)) {\n    ret = document.createTextNode(node.data);\n  }\n  else {\n    throw new Error(`unhandled node type: ${node.nodeType}`);\n  }\n\n  return ret;\n}\n\n//  LocalWords:  MPL subtree tagName localName xmlns normalizeNS namespaceURI\n//  LocalWords:  ns nodeType\n"]}