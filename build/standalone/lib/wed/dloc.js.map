{"version":3,"sources":["../../../wed/dloc.ts"],"names":[],"mappings":"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","file":"dloc.js","sourcesContent":["/**\n * Model for DOM locations.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport * as $ from \"jquery\";\nimport * as rangy from \"rangy\";\nimport { isAttr, isDocument, isElement } from \"./domtypeguards\";\nimport { Caret, indexOf, rangeFromPoints, RangeInfo } from \"./domutil\";\n\nexport type ValidRoots = Document | Element;\n\n/**\n * A class for objects that are used to mark DOM nodes as roots for the purpose\n * of using DLoc objects.\n */\nexport class DLocRoot {\n  /**\n   * @param el The element to which this object is associated.\n   */\n  constructor(public readonly node: ValidRoots) {\n    if ($.data(node, \"wed-dloc-root\") != null) {\n      throw new Error(\"node already marked as root\");\n    }\n\n    $.data(node, \"wed-dloc-root\", this);\n  }\n\n  /**\n   * Converts a node to a path. A path is a string representation of the\n   * location of a node relative to the root.\n   *\n   * @param node The node for which to construct a path.\n   *\n   * @returns The path.\n   */\n  nodeToPath(node: Node | Attr): string {\n    if (node == null) {\n      throw new Error(\"invalid node parameter\");\n    }\n\n    const root = this.node;\n    if (root === node) {\n      return \"\";\n    }\n\n    let checkNode = node;\n    if (isAttr(node)) {\n      checkNode = node.ownerElement;\n    }\n\n    if (!root.contains(checkNode)) {\n      throw new Error(\"node is not a descendant of root\");\n    }\n\n    const ret = [];\n    while (node !== root) {\n      let parent;\n      if (isAttr(node)) {\n        parent = node.ownerElement;\n        ret.unshift(`@${node.name}`);\n      }\n      else {\n        let offset = 0;\n\n        parent = node.parentNode;\n\n        let offsetNode = node.previousSibling;\n        while (offsetNode !== null) {\n          const t = offsetNode.nodeType;\n          if ((t === Node.TEXT_NODE) || (t === Node.ELEMENT_NODE)) {\n            offset++;\n          }\n          offsetNode = offsetNode.previousSibling;\n        }\n\n        ret.unshift(String(offset));\n      }\n\n      // We checked whether the node is contained by root so we should never run\n      // into a null parent.\n      node = parent!;\n    }\n\n    return ret.join(\"/\");\n  }\n\n  /**\n   * This function recovers a DOM node on the basis of a path previously created\n   * by [[nodeToPath]].\n   *\n   * @param path The path to interpret.\n   *\n   * @returns The node corresponding to the path, or ``null`` if no such node\n   * exists.\n   *\n   * @throws {Error} If given a malformed ``path``.\n   */\n  pathToNode(path: string): Node | Attr | null {\n    const root = this.node;\n\n    if (path === \"\") {\n      return root;\n    }\n\n    const parts = path.split(/\\//);\n    let parent: Node = root;\n\n    let attribute;\n    // Set aside the last part if it is an attribute.\n    if (parts[parts.length - 1][0] === \"@\") {\n      attribute = parts.pop();\n    }\n\n    for (const part of parts) {\n      if (/^(\\d+)$/.test(part)) {\n        let index = parseInt(part);\n        let found = null;\n        let node = parent.firstChild;\n        while (node !== null && found === null) {\n          const t = node.nodeType;\n\n          if ((t === Node.TEXT_NODE || (t === Node.ELEMENT_NODE)) &&\n              --index < 0) {\n            found = node;\n          }\n\n          node = node.nextSibling;\n        }\n\n        if (found === null) {\n          return null;\n        }\n\n        parent = found;\n      }\n      else {\n        throw new Error(\"malformed path expression\");\n      }\n    }\n\n    if (attribute === undefined) {\n      return parent;\n    }\n\n    if (!isElement(parent)) {\n      throw new Error(`parent must be an element since we are looking for an \\\nattribute`);\n    }\n\n    return parent.getAttributeNode(attribute.slice(1));\n  }\n}\n\nfunction getTestLength(node: Node | Attr): number {\n  let testLength;\n  if (isAttr(node)) {\n    testLength = node.value.length;\n  }\n  else {\n    switch (node.nodeType) {\n    case Node.TEXT_NODE:\n      testLength = (node as Text).data.length;\n      break;\n    case Node.DOCUMENT_NODE:\n    case Node.ELEMENT_NODE:\n      testLength = node.childNodes.length;\n      break;\n    default:\n      throw new Error(\"unexpected node type\");\n    }\n  }\n  return testLength;\n}\n\n/**\n * ``DLoc`` objects model locations in a DOM tree. Although the current\n * implementation does not enforce this, **these objects are to be treated as\n * immutable**. These objects have ``node`` and ``offset`` properties that are\n * to be interpreted in the same way DOM locations usually are: the ``node`` is\n * the location of a DOM ``Node`` in a DOM tree (or an attribute), and\n * ``offset`` is a location in that node. ``DLoc`` objects are said to have a\n * ``root`` relative to which they are positioned.\n *\n * A DLoc object can point to an offset inside an ``Element``, inside a ``Text``\n * node or inside an ``Attr``.\n *\n * Use [[makeDLoc]] to make ``DLoc`` objects. Calling this constructor directly\n * is not legal.\n *\n */\nexport class DLoc {\n  /**\n   * @param root The root of the DOM tree to which this DLoc applies.\n   *\n   * @param node The node of the location.\n   *\n   * @param offset The offset of the location.\n   */\n  private constructor(public readonly root: ValidRoots,\n                      public readonly node: Node | Attr,\n                      public readonly offset: number) {}\n\n  /**\n   * Creates a copy of the location.\n   */\n  clone(): DLoc {\n    return new DLoc(this.root, this.node, this.offset);\n  }\n\n  /**\n   * Makes a location.\n   *\n   * @param root The root of the DOM tree to which this location belongs.\n   *\n   * @param node The node of the location.\n   *\n   * @param offset The offset of the location. If the offset is omitted, then\n   * the location will point to ``node`` rather than be a location that points\n   * to the node inside of ``node`` at offset ``offset``.\n   *\n   * @param location The location as a node, offset pair.\n   *\n   * @param normalize Normalize the offset to a valid value.\n   *\n   * @returns The location. It returns ``undefined`` if the ``node`` is \"absent\"\n   * because it is ``undefined`` or ``null``. This is true irrespctive of the\n   * signature used. If you use a [[Caret]] and it has an absent node, then the\n   * result is ``undefined``.\n   *\n   * @throws {Error} If ``node`` is not in ``root`` or if ``root`` has not been\n   * marked as a root.\n   *\n   */\n  static makeDLoc(root: ValidRoots | DLocRoot,\n                  node: Node | Attr | undefined | null,\n                  offset?: number, normalize?: boolean): DLoc | undefined;\n  static makeDLoc(root: ValidRoots | DLocRoot, location: Caret,\n                  normalize?: boolean): DLoc | undefined;\n  static makeDLoc(root: ValidRoots | DLocRoot,\n                  node: Node | Attr | Caret | undefined | null,\n                  offset?: number | boolean,\n                  normalize?: boolean): DLoc | undefined {\n    if (node instanceof Array) {\n      normalize = offset as boolean;\n      [node, offset] = node as Caret;\n    }\n\n    if (normalize === undefined) {\n      normalize = false;\n    }\n\n    if (node == null) {\n      return undefined;\n    }\n\n    if (offset === undefined) {\n      const parent = node.parentNode;\n      if (parent === null) {\n        throw new Error(\"trying to get parent of a detached node\");\n      }\n\n      offset = indexOf(parent.childNodes, node);\n      node = parent;\n    }\n    else {\n      if (typeof offset !== \"number\") {\n        throw new Error(\"offset is not a number, somehow\");\n      }\n\n      if (offset < 0) {\n        if (normalize) {\n          offset = 0;\n        }\n        else {\n          throw new Error(\"negative offsets are not allowed\");\n        }\n      }\n    }\n\n    if (root instanceof DLocRoot) {\n      root = root.node;\n    }\n    else if ($.data(root, \"wed-dloc-root\") == null) {\n      throw new Error(\"root has not been marked as a root\");\n    }\n\n    if (isAttr(node)) {\n      if (!root.contains(node.ownerElement)) {\n        throw new Error(\"node not in root\");\n      }\n    }\n    else if (!root.contains(node)) {\n      throw new Error(\"node not in root\");\n    }\n\n    const testLength = getTestLength(node);\n    if (offset > testLength) {\n      if (normalize) {\n        offset = testLength;\n      }\n      else {\n        throw new Error(\"offset greater than allowable value\");\n      }\n    }\n\n    return new DLoc(root, node, offset);\n  }\n\n  /**\n   * Same as [[DLoc.makeDLoc]] but must does not accept an \"absent\" node, and\n   * won't ever return ``undefined``.\n   */\n  static mustMakeDLoc(root: ValidRoots | DLocRoot,\n                      node: Node | Attr | undefined | null,\n                      offset?: number, normalize?: boolean): DLoc;\n  static mustMakeDLoc(root: ValidRoots | DLocRoot, location: Caret,\n                      normalize?: boolean): DLoc;\n  static mustMakeDLoc(root: ValidRoots | DLocRoot,\n                      node: Node | Attr | Caret | undefined | null,\n                      offset?: number | boolean,\n                      normalize?: boolean): DLoc {\n    let nodeToCheck = node;\n    if (nodeToCheck instanceof Array) {\n      nodeToCheck = nodeToCheck[0];\n    }\n\n    if (nodeToCheck == null) {\n      throw new Error(\"called mustMakeDLoc with an absent node\");\n    }\n\n    return this.makeDLoc.apply(this, arguments);\n  }\n\n  /**\n   * Make a new location in the same DOM tree as the current one. This is a\n   * convenience function that enables avoid having to pass ``root`` around.\n   *\n   * @param caret A node, offset pair.\n   *\n   * @param node The node of the new location, if ``caret`` is not used. When a\n   * node is passed without offset, the location created will point to the node.\n   *\n   * @param offset The offset of the new location, if ``caret`` is not used.\n   *\n   * @returns The new location.\n   */\n  make(caret: Caret): DLoc;\n  make(node: Node | Attr, offset?: number): DLoc;\n  make(node: Node | Attr | Caret, offset?: number): DLoc {\n    if (node instanceof Array) {\n      return DLoc.mustMakeDLoc(this.root, node);\n    }\n\n    if (offset !== undefined && typeof offset !== \"number\") {\n      throw new Error(\n        \"if the 1st argument is a node, the 2nd must be a number or undefined\");\n    }\n\n    return DLoc.mustMakeDLoc(this.root, node, offset);\n  }\n\n  /**\n   * Make a new location with the same node as the current location but with a\n   * new offset.\n   *\n   * @param offset The offset of the new location.\n   *\n   * @returns The new location.\n   */\n  makeWithOffset(offset: number): DLoc {\n    if (offset === this.offset) {\n      return this;\n    }\n\n    return this.make(this.node, offset);\n  }\n\n  /**\n   * Make a new location. Let's define \"current node\" as the node of the current\n   * location. The new location points to the current node. (The offset of the\n   * current location is effectively ignored.) That is, the new location has for\n   * node the parent node of the current node, and for offset the offset of the\n   * current node in its parent.\n   *\n   * @returns The location in the parent, as described above.\n   *\n   * @throws {Error} If the current node has no parent.\n   */\n  getLocationInParent(): DLoc {\n    const node = this.node;\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"trying to get parent of a detached node\");\n    }\n\n    return this.make(parent, indexOf(parent.childNodes, node));\n  }\n\n  /**\n   * Same as [[getLocationInParent]] except that the location points *after* the\n   * current node.\n   *\n   * @returns The location in the parent, as described above.\n   *\n   * @throws {Error} If the current node has no parent.\n   */\n  getLocationAfterInParent(): DLoc {\n    const node = this.node;\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"trying to get parent of a detached node\");\n    }\n\n    return this.make(parent, indexOf(parent.childNodes, node) + 1);\n  }\n\n  /**\n   * Converts the location to an array. This array contains only the node and\n   * offset of the location. The root is not included because this method is of\n   * use to pass data to functions that work with raw DOM information. These\n   * functions do not typically expect a root.\n   *\n   * @returns The node and offset pair.\n   */\n  toArray(): Caret {\n    return [this.node, this.offset];\n  }\n\n  /**\n   * Make a range from this location. If ``other`` is not specified, the range\n   * starts and ends with this location, and the return value is a range. If\n   * ``other`` is specified, the range goes from this location to the ``other``\n   * location. If ``other`` comes before ``this``, then the range is\n   * \"reversed\". When ``other`` is specified, the return value is an object (see\n   * below). (An undefined value for ``other`` is interpreted as an unspecified\n   * ``other``.)\n   *\n   * @param other The other location to use.\n   *\n   * @returns The return value is just a range when the method is called without\n   * ``other``. Otherwise, it is a range info object. The return value is\n   * ``undefined`` if either ``this`` or ``other`` is invalid.\n   */\n  makeRange(): rangy.RangyRange | undefined;\n  makeRange(other: DLoc): RangeInfo | undefined;\n  makeRange(other?: DLoc): rangy.RangyRange | RangeInfo | undefined {\n    if (isAttr(this.node)) {\n      throw new Error(\"cannot make range from attribute node\");\n    }\n\n    if (!this.isValid()) {\n      return undefined;\n    }\n\n    if (other === undefined) {\n      const range = rangy.createRange(this.node.ownerDocument);\n      range.setStart(this.node, this.offset);\n      return range;\n    }\n\n    if (isAttr(other.node)) {\n      throw new Error(\"cannot make range from attribute node\");\n    }\n\n    if (!other.isValid()) {\n      return undefined;\n    }\n\n    return rangeFromPoints(this.node, this.offset, other.node, other.offset);\n  }\n\n  /**\n   * Verifies whether the ``DLoc`` object points to a valid location. The\n   * location is valid if its ``node`` is a child of its ``root`` and if its\n   * ``offset`` points inside the range of children of its ``node``.\n   *\n   * @returns {boolean} Whether the object is valid.\n   */\n  isValid(): boolean {\n    const node = this.node;\n    // We do not check that offset is greater than 0 as this would be\n    // done while constructing the object.\n    return this.root.contains(isAttr(node) ? node.ownerElement : node) &&\n      this.offset <= getTestLength(node);\n  }\n\n  /**\n   * Creates a new ``DLoc`` object with an offset that is valid. It does this by\n   * \"normalizing\" the offset, i.e. by setting the offset to its maximum\n   * possible value.\n   *\n   * @returns The normalized location. This will be ``this``, if it so happens\n   * that ``this`` is already valid.\n   */\n  normalizeOffset(): DLoc {\n    const node = this.node;\n\n    const testLength = getTestLength(node);\n    if (this.offset > testLength) {\n      return this.make(node, testLength);\n    }\n\n    return this;\n  }\n\n  /**\n   * @returns Whether ``this`` and ``other`` are equal. They are equal if they\n   * are the same object or if they point to the same location.\n   */\n  equals(other: DLoc | undefined | null): boolean {\n    if (other == null) {\n      return false;\n    }\n\n    return this === other ||\n      (this.node === other.node) &&\n      (this.offset === other.offset);\n  }\n}\n\n/**\n * Finds the root under which a node resides. Note that in cases where an\n * undefined result is useless, you should use [[getRoot]] instead.\n *\n * @param node The node whose root we want.\n *\n * @returns The root object, or ``undefined`` if the root can't be found.\n */\nexport function findRoot(node: Node | Attr | undefined | null):\nDLocRoot | undefined {\n  while (node != null) {\n    if (isElement(node) || isDocument(node)) {\n      const root = $.data(node, \"wed-dloc-root\");\n      if (root != null) {\n        return root;\n      }\n    }\n    node = node.parentNode;\n  }\n  return undefined;\n}\n\n/**\n * Gets the root under which a node resides.\n *\n * @param node The node whose root we want.\n *\n * @returns The root node.\n *\n * @throws {Error} If the root cannot be found.\n */\nexport function getRoot(node: Node | Attr | undefined | null): DLocRoot {\n  const ret = findRoot(node);\n  if (ret == null) {\n    throw new Error(\"no root found\");\n  }\n  return ret;\n}\n\n//  LocalWords:  dloc MPL jquery domutil oop DLoc makeDLoc jshint\n//  LocalWords:  newcap validthis\n"]}