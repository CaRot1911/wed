{"version":3,"sources":["../../../wed/dloc.ts"],"names":[],"mappings":"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","file":"dloc.js","sourcesContent":["/**\n * Model for DOM locations.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport * as $ from \"jquery\";\nimport * as rangy from \"rangy\";\nimport { isAttr, isDocument, isElement } from \"./domtypeguards\";\nimport { Caret, contains, indexOf, rangeFromPoints,\n         RangeInfo } from \"./domutil\";\n\nexport type ValidRoots = Document | Element;\n\n/**\n * A class for objects that are used to mark DOM nodes as roots for the purpose\n * of using DLoc objects.\n */\nexport class DLocRoot {\n  /**\n   * @param el The element to which this object is associated.\n   */\n  constructor(public readonly node: ValidRoots) {\n    if ($.data(node, \"wed-dloc-root\") != null) {\n      throw new Error(\"node already marked as root\");\n    }\n\n    $.data(node, \"wed-dloc-root\", this);\n  }\n\n  /**\n   * Converts a node to a path. A path is a string representation of the\n   * location of a node relative to the root.\n   *\n   * @param node The node for which to construct a path.\n   *\n   * @returns The path.\n   */\n  nodeToPath(node: Node | Attr): string {\n    if (node == null) {\n      throw new Error(\"invalid node parameter\");\n    }\n\n    const root = this.node;\n    if (root === node) {\n      return \"\";\n    }\n\n    if (!contains(root, node)) {\n      throw new Error(\"node is not a descendant of root\");\n    }\n\n    const ret = [];\n    while (node !== root) {\n      let parent;\n      if (isAttr(node)) {\n        parent = node.ownerElement;\n        ret.unshift(`@${node.name}`);\n      }\n      else {\n        let offset = 0;\n\n        parent = node.parentNode;\n\n        let offsetNode = node.previousSibling;\n        while (offsetNode !== null) {\n          const t = offsetNode.nodeType;\n          if ((t === Node.TEXT_NODE) || (t === Node.ELEMENT_NODE)) {\n            offset++;\n          }\n          offsetNode = offsetNode.previousSibling;\n        }\n\n        ret.unshift(String(offset));\n      }\n\n      // We checked whether the node is contained by root so we should never run\n      // into a null parent.\n      node = parent!;\n    }\n\n    return ret.join(\"/\");\n  }\n\n  /**\n   * This function recovers a DOM node on the basis of a path previously created\n   * by [[nodeToPath]].\n   *\n   * @param path The path to interpret.\n   *\n   * @returns The node corresponding to the path, or ``null`` if no such node\n   * exists.\n   *\n   * @throws {Error} If given a malformed ``path``.\n   */\n  pathToNode(path: string): Node | Attr | null {\n    const root = this.node;\n\n    if (path === \"\") {\n      return root;\n    }\n\n    const parts = path.split(/\\//);\n    let parent: Node = root;\n\n    let attribute;\n    // Set aside the last part if it is an attribute.\n    if (parts[parts.length - 1][0] === \"@\") {\n      attribute = parts.pop();\n    }\n\n    for (const part of parts) {\n      if (/^(\\d+)$/.test(part)) {\n        let index = parseInt(part);\n        let found = null;\n        let node = parent.firstChild;\n        while (node !== null && found === null) {\n          const t = node.nodeType;\n\n          if ((t === Node.TEXT_NODE || (t === Node.ELEMENT_NODE)) &&\n              --index < 0) {\n            found = node;\n          }\n\n          node = node.nextSibling;\n        }\n\n        if (found === null) {\n          return null;\n        }\n\n        parent = found;\n      }\n      else {\n        throw new Error(\"malformed path expression\");\n      }\n    }\n\n    if (attribute === undefined) {\n      return parent;\n    }\n\n    if (!isElement(parent)) {\n      throw new Error(`parent must be an element since we are looking for an \\\nattribute`);\n    }\n\n    return parent.getAttributeNode(attribute.slice(1));\n  }\n}\n\nfunction getTestLength(node: Node | Attr): number {\n  let testLength;\n  if (isAttr(node)) {\n    testLength = node.value.length;\n  }\n  else {\n    switch (node.nodeType) {\n    case Node.TEXT_NODE:\n      testLength = (node as Text).data.length;\n      break;\n    case Node.DOCUMENT_NODE:\n    case Node.ELEMENT_NODE:\n      testLength = node.childNodes.length;\n      break;\n    default:\n      throw new Error(\"unexpected node type\");\n    }\n  }\n  return testLength;\n}\n\n/**\n * Compare two locations that have already been determined to be in a\n * parent-child relation. **Important: the relationship must have been formally\n * tested *before* calling this function.**\n *\n * @returns -1 if ``parent`` is before ``child``, 1 otherwise.\n */\nfunction parentChildCompare(parentNode: Node, parentOffset: number,\n                            childNode: Node): 1 | -1 {\n  // Find which child of parent is or contains the other node.\n  let curChild = parentNode.firstChild;\n  let ix = 0;\n  while (curChild !== null) {\n    if (curChild.contains(childNode)) {\n          break;\n    }\n    ix++;\n    curChild = curChild.nextSibling;\n  }\n\n  // This is ``<= 0`` and not just ``< 0`` because if our offset points exactly\n  // to the child we found, then parent location is necessarily before the child\n  // location.\n  return (parentOffset - ix) <= 0 ? -1 : 1;\n}\n\n/**\n * ``DLoc`` objects model locations in a DOM tree. Although the current\n * implementation does not enforce this, **these objects are to be treated as\n * immutable**. These objects have ``node`` and ``offset`` properties that are\n * to be interpreted in the same way DOM locations usually are: the ``node`` is\n * the location of a DOM ``Node`` in a DOM tree (or an attribute), and\n * ``offset`` is a location in that node. ``DLoc`` objects are said to have a\n * ``root`` relative to which they are positioned.\n *\n * A DLoc object can point to an offset inside an ``Element``, inside a ``Text``\n * node or inside an ``Attr``.\n *\n * Use [[makeDLoc]] to make ``DLoc`` objects. Calling this constructor directly\n * is not legal.\n *\n */\nexport class DLoc {\n  /**\n   * @param root The root of the DOM tree to which this DLoc applies.\n   *\n   * @param node The node of the location.\n   *\n   * @param offset The offset of the location.\n   */\n  private constructor(public readonly root: ValidRoots,\n                      public readonly node: Node | Attr,\n                      public readonly offset: number) {}\n\n  /**\n   * This is the node to which this location points. For locations pointing to\n   * attributes and text nodes, that's the same as [[node]]. For locations\n   * pointing to an element, that's the child to which the ``node, offset`` pair\n   * points. Since this pair may point after the last child of an element, the\n   * child obtained may be ``undefined``.\n   */\n  get pointedNode(): Node | Attr | undefined {\n    if (isElement(this.node)) {\n      return this.node.childNodes[this.offset];\n    }\n\n    return this.node;\n  }\n\n  /**\n   * Creates a copy of the location.\n   */\n  clone(): DLoc {\n    return new DLoc(this.root, this.node, this.offset);\n  }\n\n  /**\n   * Makes a location.\n   *\n   * @param root The root of the DOM tree to which this location belongs.\n   *\n   * @param node The node of the location.\n   *\n   * @param offset The offset of the location. If the offset is omitted, then\n   * the location will point to ``node`` rather than be a location that points\n   * to the node inside of ``node`` at offset ``offset``.\n   *\n   * @param location The location as a node, offset pair.\n   *\n   * @param normalize Whether to normalize the offset to a valid value.\n   *\n   * @returns The location. It returns ``undefined`` if the ``node`` is \"absent\"\n   * because it is ``undefined`` or ``null``. This is true irrespective of the\n   * signature used. If you use a [[Caret]] and it has an absent node, then the\n   * result is ``undefined``.\n   *\n   * @throws {Error} If ``node`` is not in ``root`` or if ``root`` has not been\n   * marked as a root.\n   *\n   */\n  static makeDLoc(root: ValidRoots | DLocRoot,\n                  node: Node | Attr | undefined | null,\n                  offset?: number, normalize?: boolean): DLoc | undefined;\n  static makeDLoc(root: ValidRoots | DLocRoot, location: Caret,\n                  normalize?: boolean): DLoc | undefined;\n  static makeDLoc(root: ValidRoots | DLocRoot,\n                  node: Node | Attr | Caret | undefined | null,\n                  offset?: number | boolean,\n                  normalize?: boolean): DLoc | undefined {\n    if (node instanceof Array) {\n      normalize = offset as boolean;\n      [node, offset] = node as Caret;\n    }\n\n    if (normalize === undefined) {\n      normalize = false;\n    }\n\n    if (node == null) {\n      return undefined;\n    }\n\n    if (offset === undefined) {\n      const parent = node.parentNode;\n      if (parent === null) {\n        throw new Error(\"trying to get parent of a detached node\");\n      }\n\n      offset = indexOf(parent.childNodes, node);\n      node = parent;\n    }\n    else {\n      if (typeof offset !== \"number\") {\n        throw new Error(\"offset is not a number, somehow\");\n      }\n\n      if (offset < 0) {\n        if (normalize) {\n          offset = 0;\n        }\n        else {\n          throw new Error(\"negative offsets are not allowed\");\n        }\n      }\n    }\n\n    if (root instanceof DLocRoot) {\n      root = root.node;\n    }\n    else if ($.data(root, \"wed-dloc-root\") == null) {\n      throw new Error(\"root has not been marked as a root\");\n    }\n\n    if (!contains(root, node)) {\n      throw new Error(\"node not in root\");\n    }\n\n    const testLength = getTestLength(node);\n    if (offset > testLength) {\n      if (normalize) {\n        offset = testLength;\n      }\n      else {\n        throw new Error(\"offset greater than allowable value\");\n      }\n    }\n\n    return new DLoc(root, node, offset);\n  }\n\n  /**\n   * Same as [[DLoc.makeDLoc]] but must does not accept an \"absent\" node, and\n   * won't ever return ``undefined``.\n   */\n  static mustMakeDLoc(root: ValidRoots | DLocRoot,\n                      node: Node | Attr | undefined | null,\n                      offset?: number, normalize?: boolean): DLoc;\n  static mustMakeDLoc(root: ValidRoots | DLocRoot, location: Caret,\n                      normalize?: boolean): DLoc;\n  static mustMakeDLoc(root: ValidRoots | DLocRoot,\n                      node: Node | Attr | Caret | undefined | null,\n                      offset?: number | boolean,\n                      normalize?: boolean): DLoc {\n    let nodeToCheck = node;\n    if (nodeToCheck instanceof Array) {\n      nodeToCheck = nodeToCheck[0];\n    }\n\n    if (nodeToCheck == null) {\n      throw new Error(\"called mustMakeDLoc with an absent node\");\n    }\n\n    return this.makeDLoc.apply(this, arguments);\n  }\n\n  /**\n   * Make a new location in the same DOM tree as the current one. This is a\n   * convenience function that enables avoid having to pass ``root`` around.\n   *\n   * @param caret A node, offset pair.\n   *\n   * @param node The node of the new location, if ``caret`` is not used. When a\n   * node is passed without offset, the location created will point to the node.\n   *\n   * @param offset The offset of the new location, if ``caret`` is not used.\n   *\n   * @returns The new location.\n   */\n  make(caret: Caret): DLoc;\n  make(node: Node | Attr, offset?: number): DLoc;\n  make(node: Node | Attr | Caret, offset?: number): DLoc {\n    if (node instanceof Array) {\n      return DLoc.mustMakeDLoc(this.root, node);\n    }\n\n    if (offset !== undefined && typeof offset !== \"number\") {\n      throw new Error(\n        \"if the 1st argument is a node, the 2nd must be a number or undefined\");\n    }\n\n    return DLoc.mustMakeDLoc(this.root, node, offset);\n  }\n\n  /**\n   * Make a new location with the same node as the current location but with a\n   * new offset.\n   *\n   * @param offset The offset of the new location.\n   *\n   * @returns The new location.\n   */\n  makeWithOffset(offset: number): DLoc {\n    if (offset === this.offset) {\n      return this;\n    }\n\n    return this.make(this.node, offset);\n  }\n\n  /**\n   * Make a new location. Let's define \"current node\" as the node of the current\n   * location. The new location points to the current node. (The offset of the\n   * current location is effectively ignored.) That is, the new location has for\n   * node the parent node of the current node, and for offset the offset of the\n   * current node in its parent.\n   *\n   * @returns The location in the parent, as described above.\n   *\n   * @throws {Error} If the current node has no parent.\n   */\n  getLocationInParent(): DLoc {\n    const node = this.node;\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"trying to get parent of a detached node\");\n    }\n\n    return this.make(parent, indexOf(parent.childNodes, node));\n  }\n\n  /**\n   * Same as [[getLocationInParent]] except that the location points *after* the\n   * current node.\n   *\n   * @returns The location in the parent, as described above.\n   *\n   * @throws {Error} If the current node has no parent.\n   */\n  getLocationAfterInParent(): DLoc {\n    const node = this.node;\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"trying to get parent of a detached node\");\n    }\n\n    return this.make(parent, indexOf(parent.childNodes, node) + 1);\n  }\n\n  /**\n   * Converts the location to an array. This array contains only the node and\n   * offset of the location. The root is not included because this method is of\n   * use to pass data to functions that work with raw DOM information. These\n   * functions do not typically expect a root.\n   *\n   * @returns The node and offset pair.\n   */\n  toArray(): Caret {\n    return [this.node, this.offset];\n  }\n\n  /**\n   * Make a range from this location. If ``other`` is not specified, the range\n   * starts and ends with this location, and the return value is a range. If\n   * ``other`` is specified, the range goes from this location to the ``other``\n   * location. If ``other`` comes before ``this``, then the range is\n   * \"reversed\". When ``other`` is specified, the return value is an object (see\n   * below). (An undefined value for ``other`` is interpreted as an unspecified\n   * ``other``.)\n   *\n   * @param other The other location to use.\n   *\n   * @returns The return value is just a range when the method is called without\n   * ``other``. Otherwise, it is a range info object. The return value is\n   * ``undefined`` if either ``this`` or ``other`` is invalid.\n   *\n   * @throws {Error} If trying to make a range from an attribute node. DOM\n   * ranges can only point into elements or text nodes.\n   */\n  makeRange(): rangy.RangyRange | undefined;\n  makeRange(other: DLoc): RangeInfo | undefined;\n  makeRange(other?: DLoc): rangy.RangyRange | RangeInfo | undefined {\n    if (isAttr(this.node)) {\n      throw new Error(\"cannot make range from attribute node\");\n    }\n\n    if (!this.isValid()) {\n      return undefined;\n    }\n\n    if (other === undefined) {\n      const range = rangy.createRange(this.node.ownerDocument);\n      range.setStart(this.node, this.offset);\n      return range;\n    }\n\n    if (isAttr(other.node)) {\n      throw new Error(\"cannot make range from attribute node\");\n    }\n\n    if (!other.isValid()) {\n      return undefined;\n    }\n\n    return rangeFromPoints(this.node, this.offset, other.node, other.offset);\n  }\n\n  /**\n   * Make a range from this location. If ``other`` is not specified, the range\n   * starts and ends with this location. If ``other`` is specified, the range\n   * goes from this location to the ``other`` location.\n   *\n   * @param other The other location to use.\n   *\n   * @returns The range.\n   */\n  makeDLocRange(other?: DLoc): DLocRange | undefined {\n    if (!this.isValid()) {\n      return undefined;\n    }\n\n    if (other === undefined) {\n      // tslint:disable-next-line:no-use-before-declare\n      return new DLocRange(this, this);\n    }\n\n    if (!other.isValid()) {\n      return undefined;\n    }\n\n    // tslint:disable-next-line:no-use-before-declare\n    return new DLocRange(this, other);\n  }\n\n  /**\n   * Like [[makeDLocRange]] but throws if it cannot make a range, rather than\n   * return ``undefined``.\n   */\n  mustMakeDLocRange(other?: DLoc): DLocRange {\n    const ret = other !== undefined ?\n      this.makeDLocRange(other) : this.makeDLocRange();\n    if (ret === undefined) {\n      throw new Error(\"cannot make a range\");\n    }\n\n    return ret;\n  }\n\n  /**\n   * Verifies whether the ``DLoc`` object points to a valid location. The\n   * location is valid if its ``node`` is a child of its ``root`` and if its\n   * ``offset`` points inside the range of children of its ``node``.\n   *\n   * @returns {boolean} Whether the object is valid.\n   */\n  isValid(): boolean {\n    const node = this.node;\n    // We do not check that offset is greater than 0 as this would be\n    // done while constructing the object.\n    return this.root.contains(isAttr(node) ? node.ownerElement : node) &&\n      this.offset <= getTestLength(node);\n  }\n\n  /**\n   * Creates a new ``DLoc`` object with an offset that is valid. It does this by\n   * \"normalizing\" the offset, i.e. by setting the offset to its maximum\n   * possible value.\n   *\n   * @returns The normalized location. This will be ``this``, if it so happens\n   * that ``this`` is already valid.\n   */\n  normalizeOffset(): DLoc {\n    const node = this.node;\n\n    const testLength = getTestLength(node);\n    if (this.offset > testLength) {\n      return this.make(node, testLength);\n    }\n\n    return this;\n  }\n\n  /**\n   * @returns Whether ``this`` and ``other`` are equal. They are equal if they\n   * are the same object or if they point to the same location.\n   */\n  equals(other: DLoc | undefined | null): boolean {\n    if (other == null) {\n      return false;\n    }\n\n    return this === other ||\n      (this.node === other.node) &&\n      (this.offset === other.offset);\n  }\n\n  /**\n   * Compare two locations. Note that for attribute ordering, this class\n   * arbitrarily decides that the order of two attributes on the same element is\n   * the same as the order of their ``name`` fields as if they were sorted in an\n   * array with ``Array.prototype.sort()``. This differs from how\n   * ``Node.compareDocumentPosition`` determines the order of attributes. We\n   * want something stable, which is not implementation dependent. In all other\n   * cases, the nodes are compared in the same way\n   * ``Node.compareDocumentPosition`` does.\n   *\n   * @param other The other location to compare this one with.\n   *\n   * @returns ``0`` if the locations are the same. ``-1`` if this location comes\n   * first. ``1`` if the other location comes first.\n   *\n   * @throws {Error} If the nodes are disconnected.\n   */\n  compare(other: DLoc): -1 | 0 | 1 {\n    if (this.equals(other)) {\n      return 0;\n    }\n\n    let { node: thisNode, offset: thisOffset } = this;\n    let { node: otherNode, offset: otherOffset } = other;\n\n    // We need to handle attributes specially, because\n    // ``compareDocumentPosition`` does not work reliably with attribute nodes.\n    if (isAttr(thisNode)) {\n      if (isAttr(otherNode)) {\n        // We do not want an implementation-specific order when we compare\n        // attributes. So we perform our own test.\n        if (thisNode.ownerElement === otherNode.ownerElement) {\n          // It is not clear what the default comparison function is, so create\n          // a temporary array and sort.\n          const names = [thisNode.name, otherNode.name].sort();\n          // 0 is not a possible value here because it is not possible for\n          // thisNode.name to equal otherNode.name.\n          return names[0] === thisNode.name ? -1 : 1;\n        }\n      }\n\n      const owner = thisNode.ownerElement;\n      if (owner === other.pointedNode) {\n        // This location points into an attribute that belongs to the node\n        // that other points to. So this is later than other.\n        return 1;\n      }\n\n      // If we get here we'll rely on ``compareDocumentPosition`` but using the\n      // position of the element that has the attribute.\n      thisNode = owner.parentNode!;\n      thisOffset = indexOf(thisNode.childNodes, owner);\n    }\n\n    if (isAttr(otherNode)) {\n      const owner = otherNode.ownerElement;\n      if (owner === this.pointedNode) {\n        // The other location points into an attribute that belongs to the node\n        // that this location points to. So this is earlier than other.\n        return -1;\n      }\n\n      // If we get here we'll rely on ``compareDocumentPosition`` but using the\n      // position of the element that has the attribute.\n      otherNode = owner.parentNode!;\n      otherOffset = indexOf(otherNode.childNodes, owner);\n    }\n\n    if (thisNode === otherNode) {\n      const d = thisOffset - otherOffset;\n      if (d === 0) {\n        return 0;\n      }\n\n      return d < 0 ? -1 : 1;\n    }\n\n    const comparison = thisNode.compareDocumentPosition(otherNode);\n    // tslint:disable:no-bitwise\n    if ((comparison & Node.DOCUMENT_POSITION_DISCONNECTED) !== 0) {\n      throw new Error(\"cannot compare disconnected nodes\");\n    }\n\n    if ((comparison & Node.DOCUMENT_POSITION_CONTAINED_BY) !== 0) {\n      return parentChildCompare(thisNode, thisOffset, otherNode);\n    }\n\n    if ((comparison & Node.DOCUMENT_POSITION_CONTAINS) !== 0) {\n      return parentChildCompare(otherNode, otherOffset, thisNode) < 0 ? 1 : -1;\n    }\n\n    if ((comparison & Node.DOCUMENT_POSITION_PRECEDING) !== 0) {\n      return 1;\n    }\n\n    if ((comparison & Node.DOCUMENT_POSITION_FOLLOWING) !== 0) {\n      return -1;\n    }\n    // tslint:enable:no-bitwise\n\n    throw new Error(\"neither preceding nor following: this should not happen\");\n  }\n}\n\n/**\n * Finds the root under which a node resides. Note that in cases where an\n * undefined result is useless, you should use [[getRoot]] instead.\n *\n * @param node The node whose root we want.\n *\n * @returns The root object, or ``undefined`` if the root can't be found.\n */\nexport function findRoot(node: Node | Attr | undefined | null):\nDLocRoot | undefined {\n  while (node != null) {\n    if (isElement(node) || isDocument(node)) {\n      const root = $.data(node, \"wed-dloc-root\");\n      if (root != null) {\n        return root;\n      }\n    }\n    node = node.parentNode;\n  }\n  return undefined;\n}\n\n/**\n * Gets the root under which a node resides.\n *\n * @param node The node whose root we want.\n *\n * @returns The root node.\n *\n * @throws {Error} If the root cannot be found.\n */\nexport function getRoot(node: Node | Attr | undefined | null): DLocRoot {\n  const ret = findRoot(node);\n  if (ret == null) {\n    throw new Error(\"no root found\");\n  }\n  return ret;\n}\n\n/**\n * Represents a range spanning locations indicated by two [[DLoc]] objects.\n * Though this is not enforced at the VM level, objects of this class are to be\n * considered immutable.\n */\nexport class DLocRange {\n  /**\n   * @param start The start of the range.\n   * @param end The end of the range.\n   */\n  constructor(readonly start: DLoc, readonly end: DLoc) {\n    if (start.root !== end.root) {\n      throw new Error(\"the start and end must be in the same document\");\n    }\n  }\n\n  /** Whether this range is collapsed. */\n  get collapsed(): boolean {\n    return this.start.equals(this.end);\n  }\n\n  /**\n   * Make a DOM range.\n   *\n   * @returns The range. Or ``undefined`` if either the start or end are not\n   * pointing to valid positions.\n   *\n   * @throws {Error} If trying to make a range from an attribute node. DOM\n   * ranges can only point into elements or text nodes.\n   */\n  makeDOMRange(): rangy.RangyRange | undefined {\n    if (isAttr(this.start.node)) {\n      throw new Error(\"cannot make range from attribute node\");\n    }\n\n    if (!this.start.isValid()) {\n      return undefined;\n    }\n\n    if (isAttr(this.end.node)) {\n      throw new Error(\"cannot make range from attribute node\");\n    }\n\n    if (!this.end.isValid()) {\n      return undefined;\n    }\n\n    return rangeFromPoints(this.start.node, this.start.offset, this.end.node,\n                           this.end.offset).range;\n  }\n\n  /**\n   * Same as [[makeDOMRange]] but throws instead of returning ``undefined``.\n   */\n  mustMakeDOMRange(): rangy.RangyRange {\n    const ret = this.makeDOMRange();\n    if (ret === undefined) {\n      throw new Error(\"cannot make a range\");\n    }\n\n    return ret;\n  }\n\n  /**\n   * @returns Whether ``this`` and ``other`` are equal. They are equal if they\n   * are the same object or if they have equal start and ends.\n   */\n  equals(other: DLocRange | undefined | null): boolean {\n    if (other == null) {\n      return false;\n    }\n\n    return this === other ||\n      (this.start.equals(other.start) && this.end.equals(other.end));\n  }\n\n  /**\n   * @returns Whether the two endpoints of the range are valid.\n   */\n  isValid(): boolean {\n    return this.start.isValid() && this.end.isValid();\n  }\n\n  /**\n   * @param loc The location to test.\n   *\n   * @returns Whether a location is within the range.\n   */\n  contains(loc: DLoc): boolean {\n    const startTest = this.start.compare(loc);\n    const endTest = this.end.compare(loc);\n    // Reversed ranges are valid. So one end must be lower or equal to loc, and\n    // the other end must be greater or equal to loc. The following test ensures\n    // this. (If both are -1, then the result is > 0, and if both are 1, then\n    // then result > 0.)\n    return startTest * endTest <= 0;\n  }\n}\n\n//  LocalWords:  makeDLoc DLoc domutil jquery MPL dloc mustMakeDLoc nd thisNode\n//  LocalWords:  otherNode compareDocumentPosition makeDOMRange\n"]}