{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../lib/tests/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utilities that don't require a DOM to run.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { ajax } from \"bluejax\";\nimport { AssertionError, expect } from \"chai\";\n\nexport function delay(timeout: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, timeout));\n}\n\nexport function waitFor(fn: () => boolean | Promise<boolean>,\n                        pollDelay: number = 100,\n                        timeout?: number): Promise<boolean> {\n  const start = Date.now();\n\n  function check(): boolean | Promise<boolean> {\n    const ret = fn();\n    if (ret) {\n      return ret;\n    }\n\n    if ((timeout !== undefined) && (Date.now() - start > timeout)) {\n      return false;\n    }\n\n    return delay(pollDelay).then(check);\n  }\n\n  // TypeScript does not like Promise.resolve(check).\n  return Promise.resolve().then(check);\n}\n\nexport function waitForSuccess(fn: () => void,\n                               pollDelay?: number,\n                               timeout?: number): Promise<void> {\n  return waitFor(() => {\n    try {\n      fn();\n      return true;\n    }\n    catch (e) {\n      if (e instanceof AssertionError) {\n        return false;\n      }\n\n      throw e;\n    }\n  }, pollDelay, timeout).then(() => undefined);\n}\n\n// tslint:disable-next-line:completed-docs\nexport class DataProvider {\n  private readonly cache: Record<string, string> = Object.create(null);\n  private readonly parser: DOMParser = new DOMParser();\n  private readonly registered: Record<string, string> = Object.create(null);\n\n  constructor(private readonly base: string) {}\n\n  register(name: string, path: string): void {\n    this.registered[name] = path;\n  }\n\n  getNamed(name: string): Promise<string> {\n    const path = this.registered[name];\n    return this.getText(path);\n  }\n\n  getNamedDoc(name: string): Promise<Document> {\n    const path = this.registered[name];\n    return this.getDoc(path);\n  }\n\n  getText(path: string): Promise<string> {\n    return this._getText(this.base + path);\n  }\n\n  _getText(path: string): Promise<string> {\n    return Promise.resolve().then(() => {\n      const cached = this.cache[path];\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      return ajax({ url: path, dataType: \"text\"})\n        .then((data) => {\n          this.cache[path] = data;\n          return data;\n        });\n    });\n  }\n\n  getDoc(path: string): Promise<Document> {\n    return this._getText(this.base + path).then((data) => {\n      return this.parser.parseFromString(data, \"text/xml\");\n    });\n  }\n}\n\n// tslint:disable-next-line:no-any\nexport type ErrorClass = { new (...args: any[]): Error };\n\nexport function expectError(fn: Function,\n                            pattern: RegExp | string): Promise<void>;\nexport function expectError(fn: Function, errorClass: ErrorClass,\n                            pattern: RegExp | string): Promise<void>;\nexport function expectError(fn: Function,\n                            errorLike: RegExp | string | ErrorClass,\n                            pattern?: RegExp | string): Promise<void> {\n  return fn().then(\n    () => {\n      throw new Error(\"should have thrown an error\");\n    },\n    // tslint:disable-next-line:no-any\n    (ex: any) => {\n      if (!(errorLike instanceof RegExp || typeof errorLike === \"string\")) {\n        expect(ex).to.be.instanceof(errorLike);\n      }\n      else {\n        pattern = errorLike;\n      }\n\n      if (pattern instanceof RegExp) {\n        expect(ex).to.have.property(\"message\").match(pattern);\n      }\n      else {\n        expect(ex).to.have.property(\"message\").equal(pattern);\n      }\n    });\n}\n\n// tslint:disable-next-line:no-any\nexport function makeFakePasteEvent(clipboardData: any): any {\n  const event = new $.Event(\"paste\");\n  event.originalEvent = {\n    clipboardData,\n    // tslint:disable-next-line:no-empty\n    stopImmediatePropagation: () => {},\n    // tslint:disable-next-line:no-empty\n    preventDefault: () => {},\n    // tslint:disable-next-line:no-empty\n    stopPropagation: () => {},\n    // tslint:disable-next-line:no-any\n  } as any;\n  return event;\n}\n"]}