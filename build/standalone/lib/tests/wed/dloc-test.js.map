{"version":3,"file":"dloc-test.js","sourceRoot":"","sources":["../../../../../lib/tests/wed/dloc-test.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA;;;;OAIG;IACH,YAAY,CAAC;;;;IAWb,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;IAE3B,iBAAoB,CAAuB;QACzC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACpB,0EAA0E;QAC1E,sBAAsB;QACtB,OAAO,CAAM,CAAC;IAChB,CAAC;IAED,QAAQ,CAAC,MAAM,EAAE;QACf,IAAI,KAAa,CAAC;QAClB,IAAI,IAAiB,CAAC;QACtB,IAAI,OAAiB,CAAC;QACtB,IAAI,WAAmB,CAAC;QAExB,MAAM,CAAC;YACA,OAAA,IAAI,mBAAY,CAAC,kDAAkD,CAAC;iBACnE,OAAO,CAAC,sBAAsB,CAAC;iBAC/B,IAAI,CAAC,UAAC,SAAS;gBACd,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;gBACrC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAChC,KAAK,GAAG,gBAAC,CAAC,IAAI,CAAC,CAAC;gBAChB,IAAM,MAAM,GAAG,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC;gBACtC,IAAM,MAAM,GAAG,MAAM,CAAC,eAAe,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;gBAC7D,IAAM,QAAQ,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,EACf,MAAM,CAAC,iBAAkB,CAAC,CAAC;gBAC/D,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBAC3B,OAAO,GAAG,IAAI,eAAQ,CAAC,IAAI,CAAC,CAAC;gBAC7B,WAAW,GAAG,qBAAc,CAAC,MAAM,CAAC,CAAC;YACvC,CAAC,CAAC;QAbF,CAaE,CAAC,CAAC;QAEX,KAAK,CAAC;YACJ,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC;YACR,iEAAiE;YACjE,gCAAgC;YAChC,gBAAC,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QAEH;YACE,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,CAAC;YAChE,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACpC,IAAM,OAAO,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACnD,IAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC/B,OAAO,EAAE,OAAO,SAAA,EAAE,GAAG,KAAA,EAAE,CAAC;QAC1B,CAAC;QAED;YACE,KAAK,CAAC,MAAM,CAAC,4BAA4B,CAAC,CAAC;YAC3C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACnC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;YAC5C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAM,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC/B,CAAC,CAAC,UAAW,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;YAClC,OAAO,EAAE,GAAG,KAAA,EAAE,OAAO,SAAA,EAAE,CAAC;QAC1B,CAAC;QAED,QAAQ,CAAC,UAAU,EAAE;YACnB,EAAE,CAAC,gBAAgB,EAAE;gBACnB,MAAM,CAAC,KAAK,CAAC,eAAQ,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;YACxC,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,qCAAqC,EAAE;gBACxC,MAAM,CAAC,MAAM,CAAC;oBACZ,IAAI,eAAQ,CAAC,IAAI,CAAC,CAAC;gBACrB,CAAC,EACa,KAAK,EACL,6BAA6B,CAAC,CAAC;YAC/C,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,YAAY,EAAE;gBACrB,EAAE,CAAC,iCAAiC,EAAE;oBACpC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBACxC,IAAM,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5D,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,aAAa,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,2CAA2C,EAAE;oBAC9C,IAAM,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9D,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,WAAW,CAAC,CAAC;gBACtD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBACxC,IAAM,IAAI,GACR,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;oBACtE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,gBAAgB,CAAC,CAAC;gBAC3D,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uDAAuD,EACvD;oBACE,IAAM,IAAI,GAAG,OAAO,CAAC,gBAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,EACtC,KAAK,EAAE,kCAAkC,CAAC,CAAC;gBAC3D,CAAC,CAAC,CAAC;gBAEN,EAAE,CAAC,uBAAuB,EAAE;oBAC1B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,EACtC,KAAK,EAAE,wBAAwB,CAAC,CAAC;oBAE/C,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,EAC3C,KAAK,EAAE,wBAAwB,CAAC,CAAC;gBACjD,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,YAAY,EAAE;gBACrB,EAAE,CAAC,0CAA0C,EAAE;oBAC7C,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE;oBAC1C,IAAM,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5D,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE,IAAI,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,6CAA6C,EAAE;oBAChD,IAAM,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9D,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,CAAC;gBACtD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,0CAA0C,EAAE;oBAC7C,IAAM,IAAI,GACR,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;oBACtE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC,CAAC;gBAC3D,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,2CAA2C,EAAE;oBAC9C,qEAAqE;oBACrE,wEAAwE;oBACxE,wEAAwE;oBACxE,kEAAkE;oBAClE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;gBACjD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,yBAAyB,EAAE;oBAC5B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,EACtC,KAAK,EAAE,2BAA2B,CAAC,CAAC;gBACnD,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,UAAU,EAAE;YACnB,EAAE,CAAC,gBAAgB,EAAE;gBACnB,MAAM,CAAC,KAAK,CAAC,eAAQ,CAAC,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YACvD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,oCAAoC,EAAE;gBACvC,MAAM,CAAC,WAAW,CAAC,eAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3D,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,SAAS,EAAE;YAClB,EAAE,CAAC,eAAe,EAAE;gBAClB,MAAM,CAAC,KAAK,CAAC,cAAO,CAAC,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YACtD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,sCAAsC,EAAE;gBACzC,MAAM,CAAC,MAAM,CAAC,cAAO,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EACpD,KAAK,EAAE,eAAe,CAAC,CAAC;YACvC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,UAAU,EAAE;YACnB,EAAE,CAAC,uDAAuD,EAAE;gBAC1D,MAAM,CAAC,WAAW,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;YACrD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,sBAAsB,EAAE;gBACzB,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;gBACvC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,kDAAkD,EAAE;gBACrD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;gBAC1C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,2CAA2C,EAAE;gBAC9C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,CAAC;gBAChE,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC;gBACvC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,gDAAgD,EAAE;gBACnD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAE,CAAC;gBACzC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,iDAAiD,EAAE;gBACpD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAE,CAAC;gBACpC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC;gBACrC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,0DAA0D;gBAC1D,wBAAwB,EAAE;gBACxB,MAAM,CAAC,WAAW,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,SAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAC9D,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,kDAAkD,EAAE;gBACrD,IAAM,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrC,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAC1C,KAAK,EAAE,kBAAkB,CAAC,CAAC;YAC1C,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,6CAA6C,EAAE;gBAChD,IAAM,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrC,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,EAC7C,qCAAqC,CAAC,CAAC;YACvD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,6CAA6C,EAAE;gBAChD,IAAM,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrC,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,EACjD,mCAAmC,CAAC,CAAC;YACrD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,wDAAwD,EAAE;gBAC3D,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC5C,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EAClD,sCAAsC,CAAC,CAAC;YACxD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,qDAAqD,EAAE;gBACxD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;gBAC/C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBACzC,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EACnD,sCAAsC,CAAC,CAAC;YACvD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,0DAA0D,EAAE;gBAC7D,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,CAAC;gBAChE,MAAM,CAAC,MAAM,CAAC,gBAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EAClD,sCAAsC,CAAC,CAAC;YACxD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,8BAA8B,EAAE;gBACjC,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAE,CAAC;gBAC9C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,kDAAkD,EAAE;gBACrD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC5C,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAE,CAAC;gBAC/C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,+CAA+C,EAAE;gBAClD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;gBAC/C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBACzC,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAE,CAAC;gBAC/C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAG,CAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,oDAAoD,EAAE;gBACvD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,CAAC;gBAChE,MAAM,CAAC,MAAM,CAAC,gBAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzB,IAAM,GAAG,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAE,CAAC;gBAC/C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC3C,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,cAAc,EAAE;YACvB,EAAE,CAAC,4CAA4C,EAAE;gBAC/C,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC,EAClD,KAAK,EACL,2CAA2C,CAAC,CAAC;YAC7D,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,sBAAsB,EAAE;gBACzB,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC1C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,gDAAgD,EAAE;gBACnD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC5C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,qEAAqE,EACrE;gBACE,MAAM,CAAC,MAAM,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,CAClC,SAAS,EACT,IAAI,EACJ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,EACH,KAAK,EACN,2CAA2C,CAAC,CAAC;YAC5D,CAAC,CAAC,CAAC;QACR,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,MAAM,EAAE;YACf,QAAQ,CAAC,OAAO,EAAE;gBAChB,EAAE,CAAC,QAAQ,EAAE;oBACX,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC;gBACrC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,MAAM,EAAE;gBACf,EAAE,CAAC,yCAAyC,EAAE;oBAC5C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC5B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBAClC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;oBAC3B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC/B,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,WAAW,EAAE;gBACpB,EAAE,CAAC,eAAe,EAAE;oBAClB,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC3C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBACzC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;oBAC1C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;oBACvC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBACtC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,yBAAyB,EAAE;oBAC5B,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC;oBACvC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;oBACtC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;oBACpC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;oBACjC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,wBAAwB,EAAE;oBAC3B,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC3C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBACzC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;oBAC1C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;oBACvC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBACtC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,4BAA4B,EAAE;oBACzB,IAAA,4BAA0C,EAAxC,oBAAO,EAAE,YAAG,CAA6B;oBACjD,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,EAAtB,CAAsB,EAAE,KAAK,EACpC,uCAAuC,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,4CAA4C,EAAE;oBACzC,IAAA,4BAA0C,EAAxC,oBAAO,EAAE,YAAG,CAA6B;oBACjD,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,EAAtB,CAAsB,EAAE,KAAK,EACpC,uCAAuC,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE;oBAClC,IAAA,mCAAO,CAAuB;oBACtC,IAAM,KAAK,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;oBAClC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAC5B,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,oCAAoC,EAAE;oBACjC,IAAA,sBAAoC,EAAlC,YAAG,EAAE,oBAAO,CAAuB;oBAC3C,IAAM,KAAK,GAAG,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;oBACrC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAC5B,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,eAAe,EAAE;gBACxB,EAAE,CAAC,eAAe,EAAE;oBAClB,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;oBAC/B,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,yBAAyB,EAAE;oBAC5B,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC;oBAC3C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;oBAC/B,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;oBAC7B,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE;oBAClC,IAAA,mCAAO,CAAuB;oBACtC,IAAM,KAAK,GAAG,OAAO,CAAC,aAAa,EAAE,CAAC;oBACtC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAC5B,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,oCAAoC,EAAE;oBACjC,IAAA,sBAAoC,EAAlC,YAAG,EAAE,oBAAO,CAAuB;oBAC3C,IAAM,KAAK,GAAG,GAAG,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;oBACzC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAC5B,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,mBAAmB,EAAE;gBAC5B,EAAE,CAAC,4BAA4B,EAAE;oBACvB,IAAA,mCAAO,CAAuB;oBACtC,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,OAAO,CAAC,iBAAiB,EAAE,EAA3B,CAA2B,EAAE,KAAK,EACxC,qBAAqB,CAAC,CAAC;gBACvC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,yBAAyB,EAAE;oBACtB,IAAA,sBAAoC,EAAlC,YAAG,EAAE,oBAAO,CAAuB;oBAC3C,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,GAAG,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAA9B,CAA8B,EAAE,KAAK,EAC3C,qBAAqB,CAAC,CAAC;gBACvC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,SAAS,EAAE;gBAClB,EAAE,CAAC,wCAAwC,EAAE;oBAC3C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC1C,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,SAAS,EAAE;gBAClB,EAAE,CAAC,mDAAmD,EAAE;oBACtD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAC/B,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,gDAAgD,EAAE;oBACnD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;oBAC/C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBACzC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAC/B,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qDAAqD,EAAE;oBACxD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,CAAC;oBAChE,MAAM,CAAC,MAAM,CAAC,gBAAM,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzB,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAC/B,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,oEAAoE,EACpE;oBACE,KAAK,CAAC,MAAM,CAAC,4BAA4B,CAAC,CAAC;oBAC3C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,UAAW,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEN,EAAE,CAAC,iEAAiE,EACjE;oBACE,KAAK,CAAC,MAAM,CAAC,gCAAgC,CAAC,CAAC;oBAC/C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;oBAC9C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBACzC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,UAAW,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEN,EAAE,CAAC,sEAAsE,EACtE;oBACE,KAAK,CAAC,MAAM,CAAC,sCAAsC,CAAC,CAAC;oBACrD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;oBAClE,MAAM,CAAC,MAAM,CAAC,gBAAM,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzB,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,YAAa,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;oBACvC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEN,EAAE,CAAC,6DAA6D,EAAE;oBAChE,KAAK,CAAC,MAAM,CAAC,gCAAgC,CAAC,CAAC;oBAC/C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,UAAW,CAAC,CAAC;oBAC7B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,yDAAyD,EAAE;oBAC5D,KAAK,CAAC,MAAM,CAAC,gCAAgC,CAAC,CAAC;oBAC/C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;oBAC9C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBACzC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,WAAW,GAAG,GAAG,CAAC;oBACpB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,8DAA8D,EAAE;oBACjE,KAAK,CAAC,MAAM,CAAC,sCAAsC,CAAC,CAAC;oBACrD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;oBAClE,MAAM,CAAC,MAAM,CAAC,gBAAM,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzB,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC;oBACd,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;gBAChC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,iBAAiB,EAAE;gBAC1B,EAAE,CAAC,sCAAsC,EAAE;oBACzC,KAAK,CAAC,MAAM,CAAC,gCAAgC,CAAC,CAAC;oBAC/C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,UAAW,CAAC,CAAC;oBAC7B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9B,IAAM,IAAI,GAAG,GAAG,CAAC,eAAe,EAAE,CAAC;oBACnC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9B,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;oBAC3B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,IAAI,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mCAAmC,EAAE;oBACtC,KAAK,CAAC,MAAM,CAAC,gCAAgC,CAAC,CAAC;oBAC/C,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;oBAC9C,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBACzC,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,WAAW,GAAG,GAAG,CAAC;oBACpB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9B,IAAM,IAAI,GAAG,GAAG,CAAC,eAAe,EAAE,CAAC;oBACnC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9B,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;oBAC3B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,IAAI,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,wCAAwC,EAAE;oBAC3C,KAAK,CAAC,MAAM,CAAC,sCAAsC,CAAC,CAAC;oBACrD,IAAM,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;oBAClE,MAAM,CAAC,MAAM,CAAC,gBAAM,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzB,IAAM,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC/C,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC;oBACd,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9B,IAAM,IAAI,GAAG,GAAG,CAAC,eAAe,EAAE,CAAC;oBACnC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9B,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;oBAC3B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,IAAI,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,QAAQ,EAAE;gBACjB,IAAI,CAAc,CAAC;gBACnB,IAAI,GAAS,CAAC;gBACd,MAAM,CAAC;oBACL,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE;oBAC1C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,6CAA6C,EAAE;oBAChD,IAAM,IAAI,GAAG,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBACvC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,gCAAgC,EAAE;oBACnC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBACnC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBACxC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;gBACxC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,4CAA4C,EAAE;oBAC/C,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,UAAW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,8CAA8C,EAAE;oBACjD,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,SAAS,EAAE;gBAClB,IAAI,CAAc,CAAC;gBACnB,IAAI,GAAS,CAAC;gBACd,MAAM,CAAC;oBACL,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,oCAAoC,EAAE;oBACvC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBACpC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,0CAA0C,EAAE;oBAC7C,IAAM,IAAI,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3C,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;gBACrC,CAAC,CAAC,CAAC;gBAEH,QAAQ,CAAC,YAAY,EAAE;oBACrB,IAAI,IAAU,CAAC;oBAEf,MAAM,CAAC;wBACL,IAAI,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBACnD,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,mCAAmC,EAAE;wBACtC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBACtC,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,iCAAiC,EAAE;wBACpC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBACrC,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;gBAEH,QAAQ,CAAC,uBAAuB,EAAE;oBAChC,IAAI,KAAW,CAAC;oBAChB,IAAI,IAAU,CAAC;oBACf,MAAM,CAAC;wBACL,IAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE,CAAC;wBAChD,KAAK,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;wBAC3C,IAAI,GAAG,WAAI,CAAC,YAAY,CACtB,IAAI,EACJ,SAAS,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;oBAChD,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,6CAA6C,EAAE;wBAChD,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBACxC,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,4CAA4C,EAAE;wBAC/C,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;oBACvC,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;gBAEH,QAAQ,CAAC,kBAAkB,EAAE;oBAC3B,IAAI,MAAe,CAAC;oBACpB,IAAI,KAAW,CAAC;oBAChB,IAAI,KAAW,CAAC;oBAChB,MAAM,CAAC;wBACL,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;wBACvC,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;wBAC9B,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;wBAC9B,IAAI,eAAQ,CAAC,MAAM,CAAC,CAAC;wBACrB,KAAK,GAAG,WAAI,CAAC,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;wBACnE,KAAK,GAAG,WAAI,CAAC,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBACrE,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,wDAAwD,EAAE;wBAC3D,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBACzC,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,uDAAuD,EAAE;wBAC1D,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;oBACxC,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;gBAEH,QAAQ,CAAC,4BAA4B,EAAE;oBACrC,IAAI,YAAkB,CAAC;oBACvB,IAAI,WAAiB,CAAC;oBAEtB,MAAM,CAAC;wBACL,YAAY,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;wBACxD,WAAW,GAAG,YAAY,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;wBAC7C,iEAAiE;wBACjE,qBAAqB;wBACrB,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACnD,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,sDAAsD,EAAE;wBACzD,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC9C,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,oDAAoD,EAAE;wBACvD,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC5C,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,mDAAmD,EAAE;wBACtD,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC7C,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,qDAAqD,EAAE;wBACxD,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC7C,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,aAAa,EAAE;gBACtB,IAAI,SAAkB,CAAC;gBACvB,IAAI,aAAmB,CAAC;gBACxB,IAAI,KAAW,CAAC;gBAChB,IAAI,IAAU,CAAC;gBACf,MAAM,CAAC;oBACL,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAE,CAAC;oBAC1C,aAAa,GAAG,SAAS,CAAC,gBAAgB,CAAC,WAAW,CAAE,CAAC;oBACzD,KAAK,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBAC3C,IAAI,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC,CAAC,CAAC;gBACnD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,sCAAsC,EAAE;oBACzC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;oBAC/C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,8BAA8B,EAAE;oBACjC,IAAM,IAAI,GAAG,SAAS,CAAC,UAAW,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;oBAC5C,IAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;gBACzC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mCAAmC,EAAE;oBACtC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;gBAChD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,sDAAsD,EAAE;oBACzD,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,EACT,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,CAAC;gBAC1E,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,gBAAgB,EAAE;gBACzB,IAAI,CAAc,CAAC;gBACnB,IAAI,GAAS,CAAC;gBACd,MAAM,CAAC;oBACL,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,sCAAsC,EAAE;oBACzC,IAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;oBACzC,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBAC7B,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mDAAmD,EAAE;oBACtD,IAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBAC1B,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,qBAAqB,EAAE;gBAC9B,IAAI,CAAc,CAAC;gBACnB,IAAI,GAAS,CAAC;gBACd,MAAM,CAAC;oBACL,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uBAAuB,EAAE;oBAC1B,IAAM,IAAI,GAAG,GAAG,CAAC,mBAAmB,EAAE,CAAC;oBACvC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAC/C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBACxC,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;oBAC/B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,EACnC,KAAK,EAAE,kBAAkB,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,0BAA0B,EAAE;gBACnC,IAAI,CAAc,CAAC;gBACnB,IAAI,GAAS,CAAC;gBACd,MAAM,CAAC;oBACL,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAC5C,GAAG,GAAG,OAAO,CAAC,WAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uBAAuB,EAAE;oBAC1B,IAAM,IAAI,GAAG,GAAG,CAAC,wBAAwB,EAAE,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAC/C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBACxC,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;oBAC/B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,EACxC,KAAK,EAAE,kBAAkB,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,WAAW,EAAE;YACpB,IAAI,CAAO,CAAC;YACZ,IAAI,GAAS,CAAC;YAEd,MAAM,CAAC;gBACL,CAAC,GAAG,OAAO,CAAC,gBAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;gBACzC,GAAG,GAAG,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YACtC,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,WAAW,EAAE;gBACpB,EAAE,CAAC,mCAAmC,EAAE;oBACtC,MAAM,CAAC,MAAM,CAAC,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC;gBACnD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,wCAAwC,EAAE;oBAC3C,MAAM,CAAC,OAAO,CAAC,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;gBACtE,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,QAAQ,EAAE;gBACjB,EAAE,CAAC,oDAAoD,EAAE;oBACvD,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;oBACtC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;gBACrC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,8DAA8D,EAAE;oBACjE,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxD,IAAM,MAAM,GAAG,IAAI,gBAAS,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7B,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC5D,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBACtC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,6DAA6D,EAAE;oBAChE,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxD,IAAM,MAAM,GAAG,IAAI,gBAAS,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7B,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC5D,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;oBACjD,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC5C,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBACvC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,2DAA2D,EAAE;oBAC9D,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;oBACtC,IAAM,MAAM,GAAG,IAAI,gBAAS,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7B,WAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC5D,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;oBAChD,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC7C,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBACvC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,SAAS,EAAE;gBAClB,EAAE,CAAC,qCAAqC,EAAE;oBACxC,MAAM,CAAC,MAAM,CAAC,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBACnD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mCAAmC,EAAE;oBAC9B,IAAA,mCAAO,CAAuB;oBACtC,MAAM,CAAC,OAAO,CAAC,IAAI,gBAAS,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,iCAAiC,EAAE;oBAC5B,IAAA,mCAAO,CAAuB;oBACtC,MAAM,CAAC,OAAO,CAAC,IAAI,gBAAS,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,cAAc,EAAE;gBACvB,EAAE,CAAC,mBAAmB,EAAE;oBACtB,IAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;oBACnC,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,YAAY,EAAG,CAAC;oBACvD,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;oBACxB,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC7C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBAClC,IAAA,4BAAgD,EAA9C,oBAAO,EAAE,aAAS,CAA6B;oBACvD,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,IAAI,gBAAS,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,YAAY,EAAE,EAA3C,CAA2C,EAAE,KAAK,EACxD,uCAAuC,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mCAAmC,EAAE;oBAChC,IAAA,4BAAgD,EAA9C,oBAAO,EAAE,aAAS,CAA6B;oBACvD,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,IAAI,gBAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,YAAY,EAAE,EAA3C,CAA2C,EAAE,KAAK,EACxD,uCAAuC,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE;oBAClC,IAAA,mCAAO,CAAuB;oBACtC,MAAM,CAAC,WAAW,CAAC,IAAI,gBAAS,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,YAAY,EAAE,CAAC,CAAC;gBACjE,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qCAAqC,EAAE;oBAChC,IAAA,mCAAO,CAAuB;oBACtC,MAAM,CAAC,WAAW,CAAC,IAAI,gBAAS,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,YAAY,EAAE,CAAC,CAAC;gBACjE,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,kBAAkB,EAAE;gBAC3B,EAAE,CAAC,mBAAmB,EAAE;oBACtB,IAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;oBACnC,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,gBAAgB,EAAE,CAAC;oBAC1D,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;oBACxB,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC7C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBAC5C,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC7C,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,4BAA4B,EAAE;oBACvB,IAAA,mCAAO,CAAuB;oBACtC,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;oBAC1C,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,KAAK,CAAC,gBAAgB,EAAE,EAAxB,CAAwB,EAAE,KAAK,EACrC,qBAAqB,CAAC,CAAC;gBACvC,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,0BAA0B,EAAE;oBACrB,IAAA,mCAAO,CAAuB;oBACtC,IAAM,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;oBAC1C,MAAM,CAAC,MAAM,CAAC,cAAM,OAAA,KAAK,CAAC,gBAAgB,EAAE,EAAxB,CAAwB,EAAE,KAAK,EACtC,qBAAqB,CAAC,CAAC;gBACtC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,UAAU,EAAE;gBACnB,IAAI,KAAgB,CAAC;gBACrB,MAAM,CAAC;oBACL,KAAK,GAAG,IAAI,gBAAS,CAAC,GAAG,EAAE,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mDAAmD,EAAE;oBACtD,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpE,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,kDAAkD,EAAE;oBACrD,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uDAAuD,EAAE;oBAC1D,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,qDAAqD,EAAE;oBACxD,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,kDAAkD,EAAE;oBACrD,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvD,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\n\nimport $ from \"jquery\";\n\nimport * as convert from \"wed/convert\";\nimport { DLoc, DLocRange, DLocRoot, findRoot, getRoot } from \"wed/dloc\";\nimport { isAttr } from \"wed/domutil\";\nimport { encodeAttrName } from \"wed/util\";\n\nimport { DataProvider } from \"../util\";\n\nconst assert = chai.assert;\n\nfunction defined<T>(x: T | null | undefined): T {\n  assert.isDefined(x);\n  // The assertion above already excludes null and undefined, but TypeScript\n  // does not know this.\n  return x as T;\n}\n\ndescribe(\"dloc\", () => {\n  let $root: JQuery;\n  let root: HTMLElement;\n  let rootObj: DLocRoot;\n  let encodedType: string;\n\n  before(() =>\n         new DataProvider(\"/base/build/standalone/lib/tests/dloc_test_data/\")\n         .getText(\"source_converted.xml\")\n         .then((sourceXML) => {\n           root = document.createElement(\"div\");\n           document.body.appendChild(root);\n           $root = $(root);\n           const parser = new window.DOMParser();\n           const xmlDoc = parser.parseFromString(sourceXML, \"text/xml\");\n           const htmlTree = convert.toHTMLTree(window.document,\n                                               xmlDoc.firstElementChild!);\n           root.appendChild(htmlTree);\n           rootObj = new DLocRoot(root);\n           encodedType = encodeAttrName(\"type\");\n         }));\n\n  after(() => {\n    document.body.removeChild(root);\n  });\n\n  afterEach(() => {\n    // Some tests add elements with the class __test to the DOM tree.\n    // Proactively delete them here.\n    $(\".__test\").remove();\n  });\n\n  function makeAttributeNodeCase(): { attrLoc: DLoc; loc: DLoc } {\n    const a = defined($(\".quote\")[0].getAttributeNode(encodedType));\n    const b = defined($(\".body .p\")[1]);\n    const attrLoc = defined(DLoc.makeDLoc(root, a, 0));\n    const loc = attrLoc.make(b, 1);\n    return { attrLoc, loc };\n  }\n\n  function makeInvalidCase(): { loc: DLoc; invalid: DLoc } {\n    $root.append(\"<div class='__test'></div>\");\n    const t = defined($(\".__test\")[0]);\n    assert.equal(t.nodeType, Node.ELEMENT_NODE);\n    const b = defined($(\".body .p\")[1]);\n    const loc = defined(DLoc.makeDLoc(root, b, 1));\n    const invalid = loc.make(t, 0);\n    t.parentNode!.removeChild(t);\n    assert.isFalse(invalid.isValid());\n    return { loc, invalid };\n  }\n\n  describe(\"DLocRoot\", () => {\n    it(\"marks the root\", () => {\n      assert.equal(findRoot(root), rootObj);\n    });\n\n    it(\"fails if the node is already marked\", () => {\n      assert.throws(() => {\n        new DLocRoot(root);\n      },\n                    Error,\n                    \"node already marked as root\");\n    });\n\n    describe(\"nodeToPath\", () => {\n      it(\"returns an empty string on root\", () => {\n        assert.equal(rootObj.nodeToPath(root), \"\");\n      });\n\n      it(\"returns a correct path on text node\", () => {\n        const node = defined($root.find(\".title\")[0].childNodes[0]);\n        assert.equal(rootObj.nodeToPath(node), \"0/0/0/0/0/0\");\n      });\n\n      it(\"returns a correct path on later text node\", () => {\n        const node = defined($root.find(\".body>.p\")[1].childNodes[2]);\n        assert.equal(rootObj.nodeToPath(node), \"0/1/0/1/2\");\n      });\n\n      it(\"returns a correct path on attribute\", () => {\n        const node =\n          defined($root.find(\".body>.p\")[1].attributes.getNamedItem(\"class\"));\n        assert.equal(rootObj.nodeToPath(node), \"0/1/0/1/@class\");\n      });\n\n      it(\"fails on a node which is not a descendant of its root\",\n         () => {\n           const node = defined($(\"body\")[0]);\n           assert.throws(rootObj.nodeToPath.bind(rootObj, node),\n                         Error, \"node is not a descendant of root\");\n         });\n\n      it(\"fails on invalid node\", () => {\n        assert.throws(rootObj.nodeToPath.bind(rootObj, null),\n                      Error, \"invalid node parameter\");\n\n        assert.throws(rootObj.nodeToPath.bind(rootObj, undefined),\n                      Error, \"invalid node parameter\");\n      });\n    });\n\n    describe(\"pathToNode\", () => {\n      it(\"returns root when passed an empty string\", () => {\n        assert.equal(rootObj.pathToNode(\"\"), root);\n      });\n\n      it(\"returns a correct node on a text path\", () => {\n        const node = defined($root.find(\".title\")[0].childNodes[0]);\n        assert.equal(rootObj.pathToNode(\"0/0/0/0/0/0\"), node);\n      });\n\n      it(\"returns a correct node on a later text path\", () => {\n        const node = defined($root.find(\".body>.p\")[1].childNodes[2]);\n        assert.equal(rootObj.pathToNode(\"0/1/0/1/2\"), node);\n      });\n\n      it(\"returns a correct node on attribute path\", () => {\n        const node =\n          defined($root.find(\".body>.p\")[1].attributes.getNamedItem(\"class\"));\n        assert.equal(rootObj.pathToNode(\"0/1/0/1/@class\"), node);\n      });\n\n      it(\"accepts more than one digit per path step\", () => {\n        // There was a stupid bug in an earlier version which would make this\n        // fail with an exception complaining that the path was malformed due to\n        // the presence of \"10\". The null return value is fine since there is no\n        // such element, but at least it should not generate an exception.\n        assert.equal(rootObj.pathToNode(\"0/10\"), null);\n      });\n\n      it(\"fails on malformed path\", () => {\n        assert.throws(rootObj.pathToNode.bind(rootObj, \"+\"),\n                     Error, \"malformed path expression\");\n      });\n    });\n  });\n\n  describe(\"findRoot\", () => {\n    it(\"finds the root\", () => {\n      assert.equal(findRoot(defined($(\".p\")[0])), rootObj);\n    });\n\n    it(\"returns undefined if not in a root\", () => {\n      assert.isUndefined(findRoot(defined($root.parent()[0])));\n    });\n  });\n\n  describe(\"getRoot\", () => {\n    it(\"gets the root\", () => {\n      assert.equal(getRoot(defined($(\".p\")[0])), rootObj);\n    });\n\n    it(\"throws an exception if not in a root\", () => {\n      assert.throws(getRoot.bind(undefined, defined($root.parent()[0])),\n                   Error, \"no root found\");\n    });\n  });\n\n  describe(\"makeDLoc\", () => {\n    it(\"returns undefined when called with undefined location\", () => {\n      assert.isUndefined(DLoc.makeDLoc(root, undefined));\n    });\n\n    it(\"returns a valid DLoc\", () => {\n      const a = defined($(\".p\")[0]);\n      const loc = DLoc.makeDLoc(root, a, 0)!;\n      assert.equal(loc.node, a);\n      assert.equal(loc.offset, 0);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"returns a valid DLoc when the root is a DLocRoot\", () => {\n      const a = defined($(\".p\")[0]);\n      const loc = DLoc.makeDLoc(rootObj, a, 0)!;\n      assert.equal(loc.node, a);\n      assert.equal(loc.offset, 0);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"returns a valid DLoc on an attribute node\", () => {\n      const a = defined($(\".quote\")[0].getAttributeNode(encodedType));\n      const loc = DLoc.makeDLoc(root, a, 0)!;\n      assert.equal(loc.node, a);\n      assert.equal(loc.offset, 0);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"returns a valid DLoc when called with an array\", () => {\n      const a = defined($(\".p\")[0]);\n      const loc = DLoc.makeDLoc(root, [a, 0])!;\n      assert.equal(loc.node, a);\n      assert.equal(loc.offset, 0);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"returns a valid DLoc when the offset is omitted\", () => {\n      const a = defined($(\".body .p\")[1]);\n      const loc = DLoc.makeDLoc(root, a)!;\n      assert.equal(loc.node, a.parentNode);\n      assert.equal(loc.offset, 1);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"returns undefined when called with an array that has an \" +\n       \"undefined first member\", () => {\n         assert.isUndefined(DLoc.makeDLoc(root, [undefined!, 0]));\n    });\n\n    it(\"throws an error when the node is not in the root\", () => {\n      const c = defined($root.parent()[0]);\n      assert.throws(DLoc.makeDLoc.bind(undefined, root, c, 0),\n                   Error, \"node not in root\");\n    });\n\n    it(\"throws an error when the root is not marked\", () => {\n      const c = defined($root.parent()[0]);\n      assert.throws(DLoc.makeDLoc.bind(undefined, c, c, 0), Error,\n                    /^root has not been marked as a root/);\n    });\n\n    it(\"throws an error when the offset is negative\", () => {\n      const c = defined($root.parent()[0]);\n      assert.throws(DLoc.makeDLoc.bind(undefined, root, c, -1), Error,\n                    /^negative offsets are not allowed/);\n    });\n\n    it(\"throws an error when the offset is too large (element)\", () => {\n      const c = defined($(\".p\")[0]);\n      assert.equal(c.nodeType, Node.ELEMENT_NODE);\n      assert.throws(DLoc.makeDLoc.bind(undefined, root, c, 100), Error,\n                    /^offset greater than allowable value/);\n    });\n\n    it(\"throws an error when the offset is too large (text)\", () => {\n      const c = defined($(\".body .p\")[0].firstChild);\n      assert.equal(c.nodeType, Node.TEXT_NODE);\n      assert.throws(DLoc.makeDLoc.bind(undefined, root, c, 100), Error,\n                   /^offset greater than allowable value/);\n    });\n\n    it(\"throws an error when the offset is too large (attribute)\", () => {\n      const c = defined($(\".quote\")[0].getAttributeNode(encodedType));\n      assert.isTrue(isAttr(c));\n      assert.throws(DLoc.makeDLoc.bind(undefined, root, c, 100), Error,\n                    /^offset greater than allowable value/);\n    });\n\n    it(\"normalizes a negative offset\", () => {\n      const c = defined($(\".p\")[0]);\n      const loc = DLoc.makeDLoc(root, c, -1, true)!;\n      assert.equal(loc.offset, 0);\n    });\n\n    it(\"normalizes an offset that is too large (element)\", () => {\n      const c = defined($(\".p\")[0]);\n      assert.equal(c.nodeType, Node.ELEMENT_NODE);\n      const loc = DLoc.makeDLoc(root, c, 100, true)!;\n      assert.equal(loc.offset, 0);\n    });\n\n    it(\"normalizes an offset that is too large (text)\", () => {\n      const c = defined($(\".body .p\")[0].firstChild);\n      assert.equal(c.nodeType, Node.TEXT_NODE);\n      const loc = DLoc.makeDLoc(root, c, 100, true)!;\n      assert.equal(loc.offset, (c as Text).data.length);\n    });\n\n    it(\"normalizes an offset that is too large (attribute)\", () => {\n      const c = defined($(\".quote\")[0].getAttributeNode(encodedType));\n      assert.isTrue(isAttr(c));\n      const loc = DLoc.makeDLoc(root, c, 100, true)!;\n      assert.equal(loc.offset, c.value.length);\n    });\n  });\n\n  describe(\"mustMakeDLoc\", () => {\n    it(\"throws when called with undefined location\", () => {\n      assert.throws(DLoc.mustMakeDLoc.bind(undefined, root, undefined),\n                    Error,\n                    /^called mustMakeDLoc with an absent node$/);\n    });\n\n    it(\"returns a valid DLoc\", () => {\n      const a = defined($(\".p\")[0]);\n      const loc = DLoc.mustMakeDLoc(root, a, 0);\n      assert.equal(loc.node, a);\n      assert.equal(loc.offset, 0);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"returns a valid DLoc when called with an array\", () => {\n      const a = defined($(\".p\")[0]);\n      const loc = DLoc.mustMakeDLoc(root, [a, 0]);\n      assert.equal(loc.node, a);\n      assert.equal(loc.offset, 0);\n      assert.equal(loc.root, root);\n      assert.isTrue(loc.isValid());\n    });\n\n    it(\"throws when called with an array that has an undefined first member\",\n       () => {\n         assert.throws(DLoc.mustMakeDLoc.bind(\n           undefined,\n           root,\n           [undefined, 0]),\n                       Error,\n                      /^called mustMakeDLoc with an absent node$/);\n       });\n  });\n\n  describe(\"DLoc\", () => {\n    describe(\"clone\", () => {\n      it(\"clones\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const loc = defined(DLoc.makeDLoc(root, a, 1));\n        assert.deepEqual(loc, loc.clone());\n      });\n    });\n\n    describe(\"make\", () => {\n      it(\"makes a new location with the same root\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const b = defined($(\".body .p\")[1]);\n        const loc = defined(DLoc.makeDLoc(root, a, 1));\n        const loc2 = loc.make(b, 0);\n        assert.equal(loc.root, loc2.root);\n        assert.equal(loc2.node, b);\n        assert.equal(loc2.offset, 0);\n      });\n    });\n\n    describe(\"makeRange\", () => {\n      it(\"makes a range\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const b = defined($(\".body .p\")[1]);\n        const loc = defined(DLoc.makeDLoc(root, a, 0));\n        const loc2 = loc.make(b, 1);\n        const range = defined(loc.makeRange(loc2));\n        assert.equal(range.range.startContainer, a);\n        assert.equal(range.range.startOffset, 0);\n        assert.equal(range.range.endContainer, b);\n        assert.equal(range.range.endOffset, 1);\n        assert.isFalse(range.range.collapsed);\n        assert.isFalse(range.reversed);\n      });\n\n      it(\"makes a collapsed range\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const loc = defined(DLoc.makeDLoc(root, a, 0));\n        const range = defined(loc.makeRange());\n        assert.equal(range.startContainer, a);\n        assert.equal(range.startOffset, 0);\n        assert.equal(range.endContainer, a);\n        assert.equal(range.endOffset, 0);\n        assert.isTrue(range.collapsed);\n      });\n\n      it(\"makes a reversed range\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const b = defined($(\".body .p\")[1]);\n        const loc = defined(DLoc.makeDLoc(root, b, 1));\n        const loc2 = loc.make(a, 0);\n        const range = defined(loc.makeRange(loc2));\n        assert.equal(range.range.startContainer, a);\n        assert.equal(range.range.startOffset, 0);\n        assert.equal(range.range.endContainer, b);\n        assert.equal(range.range.endOffset, 1);\n        assert.isFalse(range.range.collapsed);\n        assert.isTrue(range.reversed);\n      });\n\n      it(\"fails on an attribute node\", () => {\n        const { attrLoc, loc } = makeAttributeNodeCase();\n        assert.throws(() => attrLoc.makeRange(loc), Error,\n                     \"cannot make range from attribute node\");\n      });\n\n      it(\"fails on an attribute node passed as other\", () => {\n        const { attrLoc, loc } = makeAttributeNodeCase();\n        assert.throws(() => loc.makeRange(attrLoc), Error,\n                     \"cannot make range from attribute node\");\n      });\n\n      it(\"returns undefined on invalid location\", () => {\n        const { invalid } = makeInvalidCase();\n        const range = invalid.makeRange();\n        assert.isUndefined(range);\n      });\n\n      it(\"returns undefined on invalid other\", () => {\n        const { loc, invalid } = makeInvalidCase();\n        const range = loc.makeRange(invalid);\n        assert.isUndefined(range);\n      });\n    });\n\n    describe(\"makeDLocRange\", () => {\n      it(\"makes a range\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const b = defined($(\".body .p\")[1]);\n        const loc = defined(DLoc.makeDLoc(root, a, 0));\n        const loc2 = loc.make(b, 1);\n        const range = defined(loc.makeDLocRange(loc2));\n        assert.equal(range.start, loc);\n        assert.equal(range.end, loc2);\n      });\n\n      it(\"makes a collapsed range\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const loc = defined(DLoc.makeDLoc(root, a, 0));\n        const range = defined(loc.makeDLocRange());\n        assert.equal(range.start, loc);\n        assert.equal(range.end, loc);\n        assert.isTrue(range.collapsed);\n      });\n\n      it(\"returns undefined on invalid location\", () => {\n        const { invalid } = makeInvalidCase();\n        const range = invalid.makeDLocRange();\n        assert.isUndefined(range);\n      });\n\n      it(\"returns undefined on invalid other\", () => {\n        const { loc, invalid } = makeInvalidCase();\n        const range = loc.makeDLocRange(invalid);\n        assert.isUndefined(range);\n      });\n    });\n\n    describe(\"mustMakeDLocRange\", () => {\n      it(\"throws on invalid location\", () => {\n        const { invalid } = makeInvalidCase();\n        assert.throws(() => invalid.mustMakeDLocRange(), Error,\n                      \"cannot make a range\");\n      });\n\n      it(\"throws on invalid other\", () => {\n        const { loc, invalid } = makeInvalidCase();\n        assert.throws(() => loc.mustMakeDLocRange(invalid), Error,\n                      \"cannot make a range\");\n      });\n    });\n\n    describe(\"toArray\", () => {\n      it(\"returns an array with the right values\", () => {\n        const a = defined($(\".body .p\")[0]);\n        const loc = defined(DLoc.makeDLoc(root, a, 1));\n        assert.deepEqual(loc.toArray(), [a, 1]);\n      });\n    });\n\n    describe(\"isValid\", () => {\n      it(\"returns true when the location is valid (element)\", () => {\n        const p = defined($(\".p\")[0]);\n        assert.equal(p.nodeType, Node.ELEMENT_NODE);\n        const loc = defined(DLoc.makeDLoc(root, p, 0));\n        assert.isTrue(loc.isValid());\n      });\n\n      it(\"returns true when the location is valid (text)\", () => {\n        const t = defined($(\".body .p\")[0].firstChild);\n        assert.equal(t.nodeType, Node.TEXT_NODE);\n        const loc = defined(DLoc.makeDLoc(root, t, 0));\n        assert.isTrue(loc.isValid());\n      });\n\n      it(\"returns true when the location is valid (attribute)\", () => {\n        const a = defined($(\".quote\")[0].getAttributeNode(encodedType));\n        assert.isTrue(isAttr(a));\n        const loc = defined(DLoc.makeDLoc(root, a, 0));\n        assert.isTrue(loc.isValid());\n      });\n\n      it(\"returns false when the node is no longer in the document (element)\",\n         () => {\n           $root.append(\"<div class='__test'></div>\");\n           const t = defined($(\".__test\")[0]);\n           assert.equal(t.nodeType, Node.ELEMENT_NODE);\n           const loc = defined(DLoc.makeDLoc(root, t, 0));\n           t.parentNode!.removeChild(t);\n           assert.isFalse(loc.isValid());\n         });\n\n      it(\"returns false when the node is no longer in the document (text)\",\n         () => {\n           $root.append(\"<div class='__test'>test</div>\");\n           const t = defined($(\".__test\")[0].firstChild);\n           assert.equal(t.nodeType, Node.TEXT_NODE);\n           const loc = defined(DLoc.makeDLoc(root, t, 0));\n           t.parentNode!.removeChild(t);\n           assert.isFalse(loc.isValid());\n         });\n\n      it(\"returns false when the node is no longer in the document (attribute)\",\n         () => {\n           $root.append(\"<div class='__test' foo='bar'></div>\");\n           const t = defined($(\".__test\")[0].attributes.getNamedItem(\"foo\"));\n           assert.isTrue(isAttr(t));\n           const loc = defined(DLoc.makeDLoc(root, t, 0));\n           t.ownerElement!.removeAttribute(\"foo\");\n           assert.isFalse(loc.isValid());\n         });\n\n      it(\"returns false when the offset is not longer valid (element)\", () => {\n        $root.append(\"<div class='__test'>test</div>\");\n        const t = defined($(\".__test\")[0]);\n        assert.equal(t.nodeType, Node.ELEMENT_NODE);\n        const loc = defined(DLoc.makeDLoc(root, t, 1));\n        t.removeChild(t.firstChild!);\n        assert.isFalse(loc.isValid());\n      });\n\n      it(\"returns false when the offset is no longer valid (text)\", () => {\n        $root.append(\"<div class='__test'>test</div>\");\n        const t = defined($(\".__test\")[0].firstChild);\n        assert.equal(t.nodeType, Node.TEXT_NODE);\n        const loc = defined(DLoc.makeDLoc(root, t, 4));\n        t.textContent = \"t\";\n        assert.isFalse(loc.isValid());\n      });\n\n      it(\"returns false when the offset is no longer valid (attribute)\", () => {\n        $root.append(\"<div class='__test' foo='bar'></div>\");\n        const t = defined($(\".__test\")[0].attributes.getNamedItem(\"foo\"));\n        assert.isTrue(isAttr(t));\n        const loc = defined(DLoc.makeDLoc(root, t, 3));\n        t.value = \"f\";\n        assert.isFalse(loc.isValid());\n      });\n    });\n\n    describe(\"normalizeOffset\", () => {\n      it(\"makes a new valid location (element)\", () => {\n        $root.append(\"<div class='__test'>test</div>\");\n        const t = defined($(\".__test\")[0]);\n        assert.equal(t.nodeType, Node.ELEMENT_NODE);\n        const loc = defined(DLoc.makeDLoc(root, t, 1));\n        t.removeChild(t.firstChild!);\n        assert.isFalse(loc.isValid());\n        const norm = loc.normalizeOffset();\n        assert.isTrue(norm.isValid());\n        assert.notEqual(loc, norm);\n        assert.equal(norm.normalizeOffset(), norm);\n      });\n\n      it(\"makes a new valid location (text)\", () => {\n        $root.append(\"<div class='__test'>test</div>\");\n        const t = defined($(\".__test\")[0].firstChild);\n        assert.equal(t.nodeType, Node.TEXT_NODE);\n        const loc = defined(DLoc.makeDLoc(root, t, 4));\n        t.textContent = \"t\";\n        assert.isFalse(loc.isValid());\n        const norm = loc.normalizeOffset();\n        assert.isTrue(norm.isValid());\n        assert.notEqual(loc, norm);\n        assert.equal(norm.normalizeOffset(), norm);\n      });\n\n      it(\"makes a new valid location (attribute)\", () => {\n        $root.append(\"<div class='__test' foo='bar'></div>\");\n        const t = defined($(\".__test\")[0].attributes.getNamedItem(\"foo\"));\n        assert.isTrue(isAttr(t));\n        const loc = defined(DLoc.makeDLoc(root, t, 3));\n        t.value = \"f\";\n        assert.isFalse(loc.isValid());\n        const norm = loc.normalizeOffset();\n        assert.isTrue(norm.isValid());\n        assert.notEqual(loc, norm);\n        assert.equal(norm.normalizeOffset(), norm);\n      });\n    });\n\n    describe(\"equals\", () => {\n      let p: HTMLElement;\n      let loc: DLoc;\n      before(() => {\n        p = defined($(\".body .p\")[0]);\n        assert.equal(p.nodeType, Node.ELEMENT_NODE);\n        loc = defined(DLoc.makeDLoc(root, p, 0));\n      });\n\n      it(\"returns true if it is the same object\", () => {\n        assert.isTrue(loc.equals(loc));\n      });\n\n      it(\"returns true if the two locations are equal\", () => {\n        const loc2 = DLoc.makeDLoc(root, p, 0);\n        assert.isTrue(loc.equals(loc2));\n      });\n\n      it(\"returns false if other is null\", () => {\n        assert.isFalse(loc.equals(null));\n      });\n\n      it(\"returns false if other is undefined\", () => {\n        assert.isFalse(loc.equals(undefined));\n      });\n\n      it(\"returns false if the two nodes are unequal\", () => {\n        assert.isFalse(loc.equals(loc.make(p.parentNode!, 0)));\n      });\n\n      it(\"returns false if the two offsets are unequal\", () => {\n        assert.isFalse(loc.equals(loc.make(p, 1)));\n      });\n    });\n\n    describe(\"compare\", () => {\n      let p: HTMLElement;\n      let loc: DLoc;\n      before(() => {\n        p = defined($(\".body .p\")[0]);\n        assert.equal(p.nodeType, Node.ELEMENT_NODE);\n        loc = defined(DLoc.makeDLoc(root, p, 0));\n      });\n\n      it(\"returns 0 if it is the same object\", () => {\n        assert.equal(loc.compare(loc), 0);\n      });\n\n      it(\"returns 0 if the two locations are equal\", () => {\n        const loc2 = DLoc.mustMakeDLoc(root, p, 0);\n        assert.equal(loc.compare(loc2), 0);\n      });\n\n      describe(\"(siblings)\", () => {\n        let next: DLoc;\n\n        before(() => {\n          next = DLoc.mustMakeDLoc(root, p.nextSibling, 0);\n        });\n\n        it(\"returns -1 if this precedes other\", () => {\n          assert.equal(loc.compare(next), -1);\n        });\n\n        it(\"returns 1 if this follows other\", () => {\n          assert.equal(next.compare(loc), 1);\n        });\n      });\n\n      describe(\"(attribute - element)\", () => {\n        let quote: DLoc;\n        let attr: DLoc;\n        before(() => {\n          const quoteNode = root.querySelector(\".quote\")!;\n          quote = DLoc.mustMakeDLoc(root, quoteNode);\n          attr = DLoc.mustMakeDLoc(\n            root,\n            quoteNode.getAttributeNode(encodedType), 0);\n        });\n\n        it(\"returns -1 if other is an attribute of this\", () => {\n          assert.equal(quote.compare(attr), -1);\n        });\n\n        it(\"returns 1 if this is an attribute of other\", () => {\n          assert.equal(attr.compare(quote), 1);\n        });\n      });\n\n      describe(\"(two attributes)\", () => {\n        let parent: Element;\n        let attr1: DLoc;\n        let attr2: DLoc;\n        before(() => {\n          parent = document.createElement(\"div\");\n          parent.setAttribute(\"b\", \"2\");\n          parent.setAttribute(\"a\", \"1\");\n          new DLocRoot(parent);\n          attr1 = DLoc.mustMakeDLoc(parent, parent.getAttributeNode(\"a\"), 0);\n          attr2 = DLoc.mustMakeDLoc(parent, parent.getAttributeNode(\"b\"), 0);\n        });\n\n        it(\"returns -1 if this is an attribute coming before other\", () => {\n          assert.equal(attr1.compare(attr2), -1);\n        });\n\n        it(\"returns 1 if this is an attribute coming aftger other\", () => {\n          assert.equal(attr2.compare(attr1), 1);\n        });\n      });\n\n      describe(\"(parent - child positions)\", () => {\n        let parentBefore: DLoc;\n        let parentAfter: DLoc;\n\n        before(() => {\n          parentBefore = DLoc.mustMakeDLoc(root, p.parentNode, 0);\n          parentAfter = parentBefore.makeWithOffset(1);\n          // We want to check that we are looking at the p element we think\n          // we are looking at.\n          assert.equal(parentBefore.node.childNodes[0], p);\n        });\n\n        it(\"returns -1 if this is a parent position before other\", () => {\n          assert.equal(parentBefore.compare(loc), -1);\n        });\n\n        it(\"returns 1 if this is a parent position after other\", () => {\n          assert.equal(parentAfter.compare(loc), 1);\n        });\n\n        it(\"returns 1 if this is a child position after other\", () => {\n          assert.equal(loc.compare(parentBefore), 1);\n        });\n\n        it(\"returns -1 if this is a child position before other\", () => {\n          assert.equal(loc.compare(parentAfter), -1);\n        });\n      });\n    });\n\n    describe(\"pointedNode\", () => {\n      let quoteNode: Element;\n      let attributeNode: Attr;\n      let quote: DLoc;\n      let attr: DLoc;\n      before(() => {\n        quoteNode = root.querySelector(\".quote\")!;\n        attributeNode = quoteNode.getAttributeNode(encodedType)!;\n        quote = DLoc.mustMakeDLoc(root, quoteNode);\n        attr = DLoc.mustMakeDLoc(root, attributeNode, 0);\n      });\n\n      it(\"returns the child of an element node\", () => {\n        assert.equal(quoteNode.parentNode, quote.node);\n        assert.equal(quote.pointedNode, quoteNode);\n      });\n\n      it(\"returns the text node itself\", () => {\n        const text = quoteNode.firstChild!;\n        assert.equal(text.nodeType, Node.TEXT_NODE);\n        const newLoc = quote.make(text, 0);\n        assert.equal(newLoc.pointedNode, text);\n      });\n\n      it(\"returns the attribute node itself\", () => {\n        assert.equal(attr.pointedNode, attributeNode);\n      });\n\n      it(\"returns undefined if the offset is past all children\", () => {\n        assert.isUndefined(quote.make(quoteNode,\n                                      quoteNode.childNodes.length).pointedNode);\n      });\n    });\n\n    describe(\"makeWithOffset\", () => {\n      let p: HTMLElement;\n      let loc: DLoc;\n      before(() => {\n        p = defined($(\".body .p\")[0]);\n        assert.equal(p.nodeType, Node.ELEMENT_NODE);\n        loc = defined(DLoc.makeDLoc(root, p, 0));\n      });\n\n      it(\"makes a new object with a new offset\", () => {\n        const loc2 = loc.makeWithOffset(1);\n        assert.equal(loc2.offset, 1);\n        assert.notEqual(loc.offset, loc2.offset);\n        assert.notEqual(loc, loc2);\n      });\n\n      it(\"returns the same object if the offset is the same\", () => {\n        const loc2 = loc.makeWithOffset(0);\n        assert.equal(loc, loc2);\n      });\n    });\n\n    describe(\"getLocationInParent\", () => {\n      let p: HTMLElement;\n      let loc: DLoc;\n      before(() => {\n        p = defined($(\".body .p\")[1]);\n        assert.equal(p.nodeType, Node.ELEMENT_NODE);\n        loc = defined(DLoc.makeDLoc(root, p, 0));\n      });\n\n      it(\"gets a valid location\", () => {\n        const loc2 = loc.getLocationInParent();\n        assert.equal(loc2.offset, 1);\n        assert.equal(loc2.node, loc.node.parentNode);\n      });\n\n      it(\"fails if we are already at the root\", () => {\n        const loc2 = loc.make(root, 0);\n        assert.throws(loc2.getLocationInParent.bind(loc2),\n                      Error, \"node not in root\");\n      });\n    });\n\n    describe(\"getLocationAfterInParent\", () => {\n      let p: HTMLElement;\n      let loc: DLoc;\n      before(() => {\n        p = defined($(\".body .p\")[1]);\n        assert.equal(p.nodeType, Node.ELEMENT_NODE);\n        loc = defined(DLoc.makeDLoc(root, p, 0));\n      });\n\n      it(\"gets a valid location\", () => {\n        const loc2 = loc.getLocationAfterInParent();\n        assert.equal(loc2.offset, 2);\n        assert.equal(loc2.node, loc.node.parentNode);\n      });\n\n      it(\"fails if we are already at the root\", () => {\n        const loc2 = loc.make(root, 0);\n        assert.throws(loc2.getLocationAfterInParent.bind(loc2),\n                      Error, \"node not in root\");\n      });\n    });\n  });\n\n  describe(\"DLocRange\", () => {\n    let a: Node;\n    let loc: DLoc;\n\n    before(() => {\n      a = defined($(\".body .p\")[0].firstChild);\n      loc = DLoc.mustMakeDLoc(root, a, 0);\n    });\n\n    describe(\"collapsed\", () => {\n      it(\"is true when a range is collapsed\", () => {\n        assert.isTrue(new DLocRange(loc, loc).collapsed);\n      });\n\n      it(\"is false when a range is not collapsed\", () => {\n        assert.isFalse(new DLocRange(loc, loc.makeWithOffset(1)).collapsed);\n      });\n    });\n\n    describe(\"equals\", () => {\n      it(\"returns true when other is the same object as this\", () => {\n        const range = new DLocRange(loc, loc);\n        assert.isTrue(range.equals(range));\n      });\n\n      it(\"returns true when the two ranges have the same start and end\", () => {\n        const range = new DLocRange(loc, loc.makeWithOffset(1));\n        const range2 = new DLocRange(DLoc.mustMakeDLoc(root, a, 0),\n                                     DLoc.mustMakeDLoc(root, a, 1));\n        assert.isTrue(range.equals(range2));\n      });\n\n      it(\"returns false when the two ranges differ in start positions\", () => {\n        const range = new DLocRange(loc, loc.makeWithOffset(1));\n        const range2 = new DLocRange(DLoc.mustMakeDLoc(root, a, 1),\n                                     DLoc.mustMakeDLoc(root, a, 1));\n        assert.isFalse(range.start.equals(range2.start));\n        assert.isTrue(range.end.equals(range2.end));\n        assert.isFalse(range.equals(range2));\n      });\n\n      it(\"returns false when the two ranges differ in end positions\", () => {\n        const range = new DLocRange(loc, loc);\n        const range2 = new DLocRange(DLoc.mustMakeDLoc(root, a, 0),\n                                     DLoc.mustMakeDLoc(root, a, 1));\n        assert.isTrue(range.start.equals(range2.start));\n        assert.isFalse(range.end.equals(range2.end));\n        assert.isFalse(range.equals(range2));\n      });\n    });\n\n    describe(\"isValid\", () => {\n      it(\"returns true if both ends are valid\", () => {\n        assert.isTrue(new DLocRange(loc, loc).isValid());\n      });\n\n      it(\"returns false if start is invalid\", () => {\n        const { invalid } = makeInvalidCase();\n        assert.isFalse(new DLocRange(invalid, loc).isValid());\n      });\n\n      it(\"returns false if end is invalid\", () => {\n        const { invalid } = makeInvalidCase();\n        assert.isFalse(new DLocRange(loc, invalid).isValid());\n      });\n    });\n\n    describe(\"makeDOMRange\", () => {\n      it(\"makes a DOM range\", () => {\n        const loc2 = loc.makeWithOffset(1);\n        const range = new DLocRange(loc, loc2).makeDOMRange()!;\n        assert.isDefined(range);\n        assert.equal(range.startContainer, loc.node);\n        assert.equal(range.startOffset, loc.offset);\n        assert.equal(range.endContainer, loc2.node);\n        assert.equal(range.endOffset, loc2.offset);\n      });\n\n      it(\"fails if start is an attribute node\", () => {\n        const { attrLoc, loc: loc2 } = makeAttributeNodeCase();\n        assert.throws(() => new DLocRange(attrLoc, loc2).makeDOMRange(), Error,\n                      \"cannot make range from attribute node\");\n      });\n\n      it(\"fails if end is an attribute node\", () => {\n        const { attrLoc, loc: loc2 } = makeAttributeNodeCase();\n        assert.throws(() => new DLocRange(loc2, attrLoc).makeDOMRange(), Error,\n                      \"cannot make range from attribute node\");\n      });\n\n      it(\"returns undefined if start is invalid\", () => {\n        const { invalid } = makeInvalidCase();\n        assert.isUndefined(new DLocRange(invalid, loc).makeDOMRange());\n      });\n\n      it(\"returns undefined if end is invalid\", () => {\n        const { invalid } = makeInvalidCase();\n        assert.isUndefined(new DLocRange(loc, invalid).makeDOMRange());\n      });\n    });\n\n    describe(\"mustMakeDOMRange\", () => {\n      it(\"makes a DOM range\", () => {\n        const loc2 = loc.makeWithOffset(1);\n        const range = new DLocRange(loc, loc2).mustMakeDOMRange();\n        assert.isDefined(range);\n        assert.equal(range.startContainer, loc.node);\n        assert.equal(range.startOffset, loc.offset);\n        assert.equal(range.endContainer, loc2.node);\n        assert.equal(range.endOffset, loc2.offset);\n      });\n\n      it(\"throws if start is invalid\", () => {\n        const { invalid } = makeInvalidCase();\n        const range = new DLocRange(invalid, loc);\n        assert.throws(() => range.mustMakeDOMRange(), Error,\n                      \"cannot make a range\");\n      });\n\n      it(\"throws if end is invalid\", () => {\n        const { invalid } = makeInvalidCase();\n        const range = new DLocRange(loc, invalid);\n        assert.throws(() => range.mustMakeDOMRange(), Error,\n                     \"cannot make a range\");\n      });\n    });\n\n    describe(\"contains\", () => {\n      let range: DLocRange;\n      before(() => {\n        range = new DLocRange(loc, loc.makeWithOffset(2));\n      });\n\n      it(\"returns false if the location is before the range\", () => {\n        assert.isFalse(range.contains(loc.make(loc.node.parentNode!, 0)));\n      });\n\n      it(\"returns false if the location is after the range\", () => {\n        assert.isFalse(range.contains(loc.makeWithOffset(3)));\n      });\n\n      it(\"returns true if the location is at start of the range\", () => {\n        assert.isTrue(range.contains(loc.makeWithOffset(0)));\n      });\n\n      it(\"returns true if the location is at end of the range\", () => {\n        assert.isTrue(range.contains(loc.makeWithOffset(2)));\n      });\n\n      it(\"returns true if the location is between the ends\", () => {\n        assert.isTrue(range.contains(loc.makeWithOffset(1)));\n      });\n    });\n  });\n});\n"]}