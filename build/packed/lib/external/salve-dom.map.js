{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 420c4c8631f0b1a750ec","webpack:///./build/dist/lib/main.js","webpack:///external \"salve\"","webpack:///./build/dist/lib/event_emitter.js","webpack:///./build/dist/lib/tools.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,gBAAgB;AAC3C;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,GAAG;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB,QAAQ;AAC9B;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mBAAmB;AACtG;AACA,oCAAoC,0CAA0C;AAC9E;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,0BAA0B,OAAO;AACjC,0BAA0B,KAAK;AAC/B,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wGAAwG;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,kBAAkB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,oBAAoB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,gBAAgB;AACvD;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA,+FAA+F,oBAAoB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,gBAAgB;AACvD;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,mBAAmB;AAC1G;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,gBAAgB;AACnD;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;AC/kDA,+C;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC,sEAAsE;AACtE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,qBAAqB;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,gBAAgB;AACvD;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,qBAAqB;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,gBAAgB;AACvD;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,yC;;;;;;;AClKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC","file":"salve-dom.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"salve\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"salve\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salve-dom\"] = factory(require(\"salve\"));\n\telse\n\t\troot[\"salve-dom\"] = factory(root[\"salve\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 420c4c8631f0b1a750ec","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar salve_1 = require(\"salve\");\nvar event_emitter_1 = require(\"./event_emitter\");\nvar tools_1 = require(\"./tools\");\nfunction _indexOf(parent, needle) {\n    return Array.prototype.indexOf.call(parent, needle);\n}\nfunction isAttr(it) {\n    var attrNodeType = Node.ATTRIBUTE_NODE;\n    // We check that ``attr_node_type`` is not undefined because eventually\n    // ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n    // could be testing ``undefined === undefined`` for objects which are not\n    // attributes, which would return ``true``. The function is not very strict\n    // but it should not be too lax either.\n    return it instanceof Attr ||\n        ((attrNodeType !== undefined) && (it.nodeType === attrNodeType));\n}\nexports.isAttr = isAttr;\n// validation_stage values\nvar Stage;\n(function (Stage) {\n    Stage[Stage[\"START_TAG\"] = 1] = \"START_TAG\";\n    Stage[Stage[\"CONTENTS\"] = 2] = \"CONTENTS\";\n    Stage[Stage[\"END_TAG\"] = 3] = \"END_TAG\";\n})(Stage || (Stage = {}));\n// Working state values\nvar WorkingState;\n(function (WorkingState) {\n    /**\n     * The validator is stopped but has not completed a validation pass yet.\n     */\n    WorkingState[WorkingState[\"INCOMPLETE\"] = 1] = \"INCOMPLETE\";\n    /**\n     * The validator is working on validating the document.\n     */\n    WorkingState[WorkingState[\"WORKING\"] = 2] = \"WORKING\";\n    /**\n     * The validator is stopped and has found the document invalid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"INVALID\"] = 3] = \"INVALID\";\n    /**\n     * The validator is stopped and has found the document valid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"VALID\"] = 4] = \"VALID\";\n})(WorkingState = exports.WorkingState || (exports.WorkingState = {}));\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nvar ProgressState = /** @class */ (function () {\n    function ProgressState(partDone, portion) {\n        this.partDone = partDone;\n        this.portion = portion;\n    }\n    return ProgressState;\n}());\n//\n// Note: the Validator class adds information to the Element nodes it is working\n// with by adding expando properties that start with \"wed_event_\". This deemed\n// acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to be open to\n//   third party software. Even if it were, the chance of a clash is small.\n//\n// * The values of the expando properties are primitives (not objects or other\n//   elements).\n//\n// * We don't care about browsers or situations where expando properties are not\n//   supported.\n//\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nvar EventIndexException = /** @class */ (function (_super) {\n    __extends(EventIndexException, _super);\n    function EventIndexException() {\n        var _this = _super.call(this, \"undefined event_index; _validateUpTo should have taken care of that\") || this;\n        tools_1.fixPrototype(_this, EventIndexException);\n        return _this;\n    }\n    return EventIndexException;\n}(Error));\n// This private utility function checks whether an event is possible only\n// because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker, eventName, ns, name) {\n    var evs = walker.possible();\n    var matched = false;\n    try {\n        for (var evs_1 = __values(evs), evs_1_1 = evs_1.next(); !evs_1_1.done; evs_1_1 = evs_1.next()) {\n            var ev = evs_1_1.value;\n            if (ev.params[0] !== eventName) {\n                continue;\n            }\n            var namePattern = ev.params[1];\n            var matches = namePattern.match(ns, name);\n            // Keep track of whether it ever matched anything.\n            matched = matched || matches;\n            // We already know that it matches, and this is not merely due to a\n            // wildcard.\n            if (matches && !namePattern.wildcardMatch(ns, name)) {\n                return false;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (evs_1_1 && !evs_1_1.done && (_a = evs_1.return)) _a.call(evs_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // If it never matched any pattern at all, then we must return false.  If we\n    // get here and matched is true then it means that it matched all patterns due\n    // to wildcards.\n    return matched;\n    var e_1, _a;\n}\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nvar Validator = /** @class */ (function () {\n    function Validator(schema, root, options) {\n        if (options === void 0) { options = {}; }\n        this.schema = schema;\n        this.root = root;\n        this._cycleEntered = 0;\n        this._timeout = 200;\n        this._maxTimespan = 100;\n        this._resetting = false;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._boundWrapper = this._workWrapper.bind(this);\n        // Validation state\n        this._validationEvents = [];\n        this._workingState = WorkingState.INCOMPLETE;\n        this._partDone = 0;\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationStack = [new ProgressState(0, 1)];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        this._prefix = \"salveDom\";\n        // The distance between walkers under which we skip saving a walker in the\n        // cache.\n        this._walkerCacheGap = 100;\n        this._events = new event_emitter_1.EventEmitter();\n        var keys = [\"timeout\", \"maxTimespan\",\n            \"walkerCacheGap\"];\n        try {\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                var key = keys_1_1.value;\n                var value = options[key];\n                if (value === undefined) {\n                    continue;\n                }\n                if (value < 0) {\n                    throw new Error(\"the value for \" + key + \" cannot be negative\");\n                }\n                this[\"_\" + key] = options[key];\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        if (options.prefix !== undefined) {\n            this._prefix = options.prefix;\n        }\n        this._curEl = this.root;\n        // This prevents an infinite loop when speculativelyValidate is called to\n        // validate a text node.\n        this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", this._validationEvents.length);\n        this._setWorkingState(WorkingState.INCOMPLETE, 0);\n        this._validationWalker = this.schema.newWalker();\n        this.events = this._events;\n        var e_2, _a;\n    }\n    Validator.prototype.makeKey = function (key) {\n        return \"\" + this._prefix + key;\n    };\n    /**\n     * Function allowing to get a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype.getNodeProperty = function (node, key) {\n        return node[this.makeKey(key)];\n    };\n    /**\n     * Function allowing to set a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype._setNodeProperty = function (node, key, value) {\n        node[this.makeKey(key)] = value;\n    };\n    Validator.prototype._clearNodeProperties = function (node) {\n        var keys = [\n            \"EventIndexAfter\",\n            \"EventIndexAfterStart\",\n            \"EventIndexBeforeAttributes\",\n            \"EventIndexAfterAttributes\",\n            \"PossibleDueToWildcard\",\n            \"ErrorId\",\n        ];\n        try {\n            for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {\n                var key = keys_2_1.value;\n                delete node[this.makeKey(key)];\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        var e_3, _a;\n    };\n    /**\n     * Starts the background validation process.\n     */\n    Validator.prototype.start = function () {\n        if (this._timeoutId !== undefined) {\n            this._stop(WorkingState.WORKING);\n        }\n        // When we call ``this.start``, we want the validation to start ASAP. So we\n        // do not use ``this._timeout`` here. However, we do not call\n        // ``this._workWrapper`` directly because we want to be able to call\n        // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n        // directly, we'd be calling this._cycle from inside this._cycle, which is\n        // results in an internal error.\n        this._timeoutId = setTimeout(this._boundWrapper, 0);\n    };\n    /**\n     * Get the namespaces defined in the schema passed to the Validator.\n     *\n     * @returns The namespaces known to the schema.\n     */\n    Validator.prototype.getSchemaNamespaces = function () {\n        return this.schema.getNamespaces();\n    };\n    /**\n     * Get the namespaces used in the document. This method does not cache its\n     * information and scan the whole document independently of the current\n     * validation status.\n     *\n     * @returns An object whose keys are namespace prefixes and values are lists\n     * of namespace URIs.  The values are lists because prefixes can be redefined\n     * in a document.\n     */\n    Validator.prototype.getDocumentNamespaces = function () {\n        var ret = {};\n        function _process(node) {\n            if (node === null) {\n                return;\n            }\n            var attrIxLim = node.attributes.length;\n            for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                var attr = node.attributes[attrIx];\n                if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n                    var key = attr.name.slice(6);\n                    var array = ret[key];\n                    if (array === undefined) {\n                        array = ret[key] = [];\n                    }\n                    array.push(attr.value);\n                }\n            }\n            var child = node.firstChild;\n            while (child !== null) {\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    _process(child);\n                }\n                child = child.nextSibling;\n            }\n        }\n        _process(this.root.firstChild);\n        return ret;\n    };\n    /**\n     * Convenience method. The bound version of this method\n     * (``this._boundWrapper``) is what is called by the timeouts to perform the\n     * background validation.\n     */\n    Validator.prototype._workWrapper = function () {\n        if (this._work()) {\n            this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n        }\n    };\n    /**\n     * Controller method for the background validation. Keeps the validator\n     * running only until done or until the maximum time span for one run\n     * of the validator is reached.\n     *\n     * @returns False if there is no more work to do. True otherwise.\n     */\n    Validator.prototype._work = function () {\n        var startDate = Date.now();\n        while (true) {\n            // Give a chance to other operations to work.\n            if ((this._maxTimespan > 0) &&\n                (Date.now() - startDate) >= this._maxTimespan) {\n                return true;\n            }\n            var ret = this._cycle();\n            if (!ret) {\n                return false;\n            }\n        }\n    };\n    /**\n     * Performs one cycle of validation. \"One cycle\" is an arbitrarily small unit\n     * of work.\n     *\n     * @returns False if there is no more work to be done. True otherwise.\n     *\n     * @throws {Error} When there is an internal error.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._cycle = function () {\n        var _this = this;\n        // If we got here after a reset, then we've finished resetting.  If we were\n        // not resetting, then this is a noop.\n        this._resetting = false;\n        //\n        // This check is meant to catch problems that could be hard to diagnose if\n        // wed or one of its modes had a bug such that `_cycle` is reentered from\n        // `_cycle`. This could happen during error processing, for instance. Error\n        // processing causes wed to process the errors, which causes changes in the\n        // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n        // execute something like `getErrorsFor`, which could cause `_cycle` to be\n        // reentered.\n        //\n        if (this._cycleEntered > 0) {\n            throw new Error(\"internal error: _cycle is being reentered\");\n        }\n        if (this._cycleEntered < 0) {\n            throw new Error(\"internal error: _cycleEntered negative\");\n        }\n        //\n        // IMPORTANT: This variable must be decremented before exiting this\n        // method. A try...finally statement is not used here because it would\n        // prevent some virtual machines from optimizing this function.\n        //\n        this._cycleEntered++;\n        var walker = this._validationWalker;\n        var stack = this._validationStack;\n        var events = this._validationEvents;\n        var portion = stack[0].portion;\n        var stage = this._validationStage;\n        var _loop_1 = function () {\n            var curEl = this_1._curEl;\n            switch (stage) {\n                case Stage.START_TAG: {\n                    // The logic is such that if we get here curEl must be an Element.\n                    curEl = curEl;\n                    stack.unshift(new ProgressState(this_1._partDone, portion));\n                    // Handle namespace declarations. Yes, this must happen before we deal\n                    // with the tag name.\n                    this_1._fireAndProcessEvent(walker, \"enterContext\", [], curEl, 0);\n                    var attrIxLim = curEl.attributes.length;\n                    for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                        var attr = curEl.attributes[attrIx];\n                        var uri = void 0;\n                        if (attr.name === \"xmlns\") {\n                            uri = \"\";\n                        }\n                        else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n                            uri = attr.name.slice(6);\n                        }\n                        if (uri !== undefined) {\n                            this_1._fireAndProcessEvent(walker, \"definePrefix\", [uri, attr.value], curEl, 0);\n                        }\n                    }\n                    var tagName = curEl.tagName;\n                    // tslint:disable-next-line:no-non-null-assertion\n                    var parent_1 = curEl.parentNode;\n                    var curElIndex = _indexOf(parent_1.childNodes, curEl);\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        this_1._processEventResult([new salve_1.ValidationError(\"cannot resolve the name \" + tagName)], parent_1, curElIndex);\n                        // This allows us to move forward. It will certainly cause a\n                        // validation error, and send salve into its recovery mode for unknown\n                        // elements.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    // Check whether this element is going to be allowed only due to a\n                    // wildcard.\n                    this_1._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\", ename.ns, ename.name);\n                    this_1._fireAndProcessEvent(walker, \"enterStartTag\", [ename.ns, ename.name], parent_1, curElIndex);\n                    this_1._setNodeProperty(curEl, \"EventIndexBeforeAttributes\", events.length);\n                    this_1._fireAttributeEvents(walker, curEl);\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterAttributes\", events.length);\n                    // Leave the start tag.\n                    this_1._fireAndProcessEvent(walker, \"leaveStartTag\", [], curEl, 0);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n                    this_1._cycleEntered--;\n                    return { value: true };\n                    // break would be unreachable.\n                }\n                case Stage.CONTENTS: {\n                    var node = (this_1._previousChild === null) ?\n                        // starting from scratch\n                        curEl.firstChild :\n                        // already validation contents\n                        this_1._previousChild.nextSibling;\n                    var textAccumulator_1 = [];\n                    var textAccumulatorNode_1;\n                    var flushText = function () {\n                        if (textAccumulator_1.length !== 0) {\n                            var eventResult = walker.fireEvent(\"text\", [textAccumulator_1.join(\"\")]);\n                            if (eventResult instanceof Array) {\n                                if (textAccumulatorNode_1 === undefined) {\n                                    throw new Error(\"flushText running with undefined node\");\n                                }\n                                // We are never without a parentNode here.\n                                // tslint:disable-next-line:no-non-null-assertion\n                                var parent_2 = textAccumulatorNode_1.parentNode;\n                                _this._processEventResult(eventResult, parent_2, _indexOf(parent_2.childNodes, textAccumulatorNode_1));\n                            }\n                        }\n                        textAccumulator_1 = [];\n                        textAccumulatorNode_1 = undefined;\n                    };\n                    while (node !== null) {\n                        switch (node.nodeType) {\n                            case Node.TEXT_NODE:\n                                // Salve does not allow multiple text events in a row. If text is\n                                // encountered, then all the text must be passed to salve as a\n                                // single event. We record the text and will flush it to salve\n                                // later.\n                                textAccumulator_1.push(node.data);\n                                if (textAccumulatorNode_1 === undefined) {\n                                    textAccumulatorNode_1 = node;\n                                }\n                                break;\n                            case Node.ELEMENT_NODE:\n                                flushText();\n                                portion /= curEl.childElementCount;\n                                this_1._curEl = curEl = node;\n                                stage = this_1._validationStage = Stage.START_TAG;\n                                this_1._previousChild = null;\n                                return \"continue-stage_change\";\n                            case Node.COMMENT_NODE:\n                                break; // We just skip over comment nodes.\n                            default:\n                                throw new Error(\"unexpected node type: \" + node.nodeType);\n                        }\n                        node = node.nextSibling;\n                    }\n                    flushText();\n                    stage = this_1._validationStage = Stage.END_TAG;\n                    break;\n                }\n                case Stage.END_TAG: {\n                    // We've reached the end...\n                    if (curEl === this_1.root) {\n                        var eventResult = walker.end();\n                        if (eventResult instanceof Array) {\n                            this_1._processEventResult(eventResult, curEl, curEl.childNodes.length);\n                        }\n                        this_1._runDocumentValidation();\n                        this_1._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n                        this_1._partDone = 1;\n                        this_1._stop(this_1._errors.length > 0 ? WorkingState.INVALID :\n                            WorkingState.VALID);\n                        this_1._cycleEntered--;\n                        return { value: false };\n                    }\n                    // we need it later\n                    var originalElement = curEl;\n                    var tagName = curEl.tagName;\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        // We just produce the name name we produced when we encountered the\n                        // start tag.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    this_1._fireAndProcessEvent(walker, \"endTag\", [ename.ns, ename.name], curEl, curEl.childNodes.length);\n                    this_1._fireAndProcessEvent(walker, \"leaveContext\", [], curEl, curEl.childNodes.length);\n                    // Go back to the parent\n                    this_1._previousChild = curEl;\n                    // We are never without a parentNode here.\n                    // tslint:disable-next-line:no-non-null-assertion\n                    this_1._curEl = curEl = curEl.parentNode;\n                    var nextDone = this_1._partDone;\n                    if (curEl !== this_1.root) {\n                        stack.shift();\n                        var first = stack[0];\n                        nextDone = first.partDone += portion;\n                        portion = first.portion;\n                    }\n                    this_1._setWorkingState(WorkingState.WORKING, nextDone);\n                    this_1._setNodeProperty(originalElement, \"EventIndexAfter\", this_1._validationEvents.length);\n                    stage = this_1._validationStage = Stage.CONTENTS;\n                    this_1._cycleEntered--;\n                    return { value: true };\n                }\n                // break; would be unreachable\n                default:\n                    throw new Error(\"unexpected state\");\n            }\n        };\n        var this_1 = this;\n        stage_change: while (true) {\n            var state_1 = _loop_1();\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n            switch (state_1) {\n                case \"continue-stage_change\": continue stage_change;\n            }\n        }\n    };\n    /**\n     * Stops background validation.\n     */\n    Validator.prototype.stop = function () {\n        this._stop();\n    };\n    /**\n     * This private method takes an argument that allows setting the working state\n     * to a specific value. This is useful to reduce the number of\n     * ``state-update`` events emitted when some internal operations are\n     * performed. The alternative would be to perform a state change before or\n     * after the call to ``stop``, which would result in more events being\n     * emitted.\n     *\n     * If the parameter is unused, then the logic is that if we were not yet in a\n     * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n     *\n     * @param state The state with which to stop.\n     */\n    Validator.prototype._stop = function (state) {\n        if (this._timeoutId !== undefined) {\n            clearTimeout(this._timeoutId);\n        }\n        this._timeoutId = undefined;\n        if (state === undefined) {\n            // We are stopping prematurely, update the state\n            if (this._workingState === WorkingState.WORKING) {\n                this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n            }\n        }\n        else {\n            this._setWorkingState(state, this._partDone);\n        }\n    };\n    /**\n     * Run document-level validation that cannot be modeled by Relax NG.  The\n     * default implementation does nothing. Deriving classes may override it to\n     * call [[_processError]].\n     */\n    Validator.prototype._runDocumentValidation = function () { }; // tslint:disable-line: no-empty\n    /**\n     * Restarts validation from a specific point. After the call returns, the\n     * background validation will be in effect. (So calling it on a stopped\n     * validator has the side effect of starting it.)\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.restartAt = function (node) {\n        this.resetTo(node);\n        this.start();\n    };\n    /**\n     * Reset validation to continue from a certain point.\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.resetTo = function (node) {\n        // We use `this._resetting` to avoid a costly reinitialization if this\n        // method is called twice in a row before any work has had a chance to be\n        // done.\n        if (!this._resetting) {\n            this._resetting = true;\n            this._resetTo(node);\n        }\n    };\n    Validator.prototype._erase = function (el) {\n        this._clearNodeProperties(el);\n        var child = el.firstElementChild;\n        while (child !== null) {\n            this._erase(child);\n            child = child.nextElementSibling;\n        }\n    };\n    /**\n     * Resets validation to continue from a specific point. Any further work done\n     * by the validator will start from the point specified.\n     *\n     * @param node The element to start validation from.\n     *\n     * @emits module:validator~Validator#reset-errors\n     */\n    // @ts-ignore\n    Validator.prototype._resetTo = function (node) {\n        // An earlier implementation was trying to be clever and to avoid restarting\n        // much earlier than strictly needed. That ended up being more costly than\n        // doing this primitive restart from 0 no matter what. Eventually, Validator\n        // should be updated so that on large documents, restarting from a location\n        // towards the end does not require revalidating the whole document. For\n        // now, since wed is used for smallish documents, it would be a premature\n        // optimization.\n        this._erase(this.root);\n        this._validationStage = Stage.CONTENTS;\n        this._previousChild = null;\n        this._validationWalker = this.schema.newWalker();\n        this._validationEvents = [];\n        this._curEl = this.root;\n        this._partDone = 0;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        /**\n         * Tells the listener that it must reset its list of errors.\n         *\n         * @event module:validator~Validator#reset-errors\n         * @type {Object}\n         * @property {integer} at The index of the first error that must\n         * be deleted. This error and all those after it must be deleted.\n         */\n        this._events._emit(\"reset-errors\", { at: 0 });\n    };\n    /**\n     * Sets the working state of the validator. Emits a \"state-update\" event if\n     * the state has changed.\n     *\n     * @param newState The new state of the validator.\n     *\n     * @param newDone The new portion of work done.\n     *\n     * @emits module:validator~Validator#state-update\n     */\n    Validator.prototype._setWorkingState = function (newState, newDone) {\n        var changed = false;\n        if (this._workingState !== newState) {\n            this._workingState = newState;\n            changed = true;\n        }\n        if (this._partDone !== newDone) {\n            this._partDone = newDone;\n            changed = true;\n        }\n        if (changed) {\n            /**\n             * Tells the listener that the validator has changed state.\n             *\n             * @event module:validator~Validator#state-update\n             */\n            this._events._emit(\"state-update\", { state: newState, partDone: newDone });\n        }\n    };\n    /**\n     * Gets the validator working state.\n     *\n     * @returns The working state\n     */\n    Validator.prototype.getWorkingState = function () {\n        return {\n            state: this._workingState,\n            partDone: this._partDone,\n        };\n    };\n    Object.defineProperty(Validator.prototype, \"errors\", {\n        /**\n         * The current set of errors.\n         */\n        get: function () {\n            return this._errors.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Processes the result of firing a tag event. It will emit an \"error\"\n     * event for each error.\n     *\n     * @param results The results of the walker's ``fireEvent`` call.\n     *\n     * @param node The data node to which the result belongs.\n     *\n     * @param index The index into ``node`` to which the result belongs.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processEventResult = function (results, node, index) {\n        try {\n            for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n                var result = results_1_1.value;\n                this._processError({ error: result, node: node, index: index });\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        var e_4, _a;\n    };\n    /**\n     * This method should be called whenever a new error is detected. It\n     * records the error and emits the corresponding event.\n     *\n     * @param error The error found.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processError = function (error) {\n        var _this = this;\n        /**\n         * We don't make this a method because it should only be called from\n         * ``_processError``. The way we generate new ID values works **only**\n         * because we push a new error in the list when there's no ID already set.\n         *\n         * Ensure the node has an error ID and return it. The error ID is the number\n         * set on the ``ErrorId`` property. If the node has no ID set yet, we assign\n         * one and return the new value. Otherwise, the old value is returned.\n         *\n         * @param node The node of interest.\n         *\n         * @returns The error ID.\n         */\n        var ensureErrorId = function (nodeGettingId) {\n            var oldId = _this.getNodeProperty(nodeGettingId, \"ErrorId\");\n            if (oldId === undefined) {\n                // The length of the error array at the time of first calling this\n                // function is good enough to serve as an ID.\n                oldId = _this._errors.length;\n                _this._setNodeProperty(nodeGettingId, \"ErrorId\", oldId);\n            }\n            return oldId;\n        };\n        // We must first check whether we've seen this error before, and avoid\n        // recording it again if we've seen it. This could happen when\n        // ``_getWalkerAt`` is used, because the validator may repeat firing events\n        // and processing the associated errors. We cannot just turn off error\n        // processing when ``_getWalkerAt`` is used because it may be used in cases\n        // where we are legitimately advancing the state of validation (rather than\n        // going over old stuff).\n        var node = error.node;\n        var errorId = node == null ? \"\" : String(ensureErrorId(node));\n        var key = errorId + \",\" + error.error.toString();\n        var alreadySeen = this._errorsSeen[key];\n        // We want to do a strict compare with true to handle ``undefined``.\n        if (alreadySeen !== true) {\n            this._errorsSeen[key] = true;\n            this._errors.push(error);\n            /**\n             * Tells the listener that an error has occurred.\n             *\n             * @event module:validator~Validator#error\n             * @type {Object}\n             * @property {Object} error The validation error.\n             * @property {Node} node The node where the error occurred.\n             * @property {integer} index The index in this node.\n             */\n            this._events._emit(\"error\", error);\n        }\n    };\n    /**\n     * Fires all the attribute events for a given element.\n     */\n    Validator.prototype._fireAttributeEvents = function (walker, el) {\n        // Find all attributes, fire events for them.\n        var attributes = el.attributes;\n        // tslint:disable-next-line:prefer-for-of\n        for (var i = 0; i < attributes.length; ++i) {\n            var attr = attributes[i];\n            // Skip those attributes which are namespace attributes.\n            if ((attr.name === \"xmlns\") ||\n                (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n                continue;\n            }\n            if (this._fireAttributeNameEvent(walker, attr)) {\n                this._fireAndProcessEvent(walker, \"attributeValue\", [attr.value], attr, 0);\n            }\n        }\n    };\n    /**\n     * Fires an attributeName event. If the attribute name is in a namespace and\n     * cannot be resolved, the event is not fired.\n     *\n     * @returns True if the event was actually fired, false if not.\n     */\n    Validator.prototype._fireAttributeNameEvent = function (walker, attr) {\n        var attrName = attr.name;\n        var ename = walker.resolveName(attrName, true);\n        if (ename === undefined) {\n            this._processError({ error: new salve_1.ValidationError(\"cannot resolve attribute name \" + attrName), node: attr, index: 0 });\n            return false;\n        }\n        this._setPossibleDueToWildcard(attr, walker, \"attributeName\", ename.ns, ename.name);\n        this._fireAndProcessEvent(walker, \"attributeName\", [ename.ns, ename.name], attr, 0);\n        return true;\n    };\n    /**\n     * Convenience method to fire events.\n     *\n     * @param walker The walker on which to fire events.\n     *\n     * @param name The name of the event to fire.\n     *\n     * @param params The event's parameters.\n     *\n     * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n     * can be undefined for events that have no location associated with them.\n     *\n     * @param ix The index into ``el`` associated with this event, or a ``Node``\n     * which must be a child of ``el``. The index will be computed from the\n     * location of the child passed as this parameter in ``el``.\n     */\n    Validator.prototype._fireAndProcessEvent = function (walker, name, params, el, ix) {\n        this._validationEvents.push({ name: name, params: params });\n        switch (name) {\n            case \"enterContext\":\n                walker.enterContext();\n                return;\n            case \"leaveContext\":\n                walker.leaveContext();\n                return;\n            case \"definePrefix\":\n                walker.definePrefix(params[0], params[1]);\n                return;\n            default:\n                var eventResult = walker.fireEvent(name, params);\n                if (eventResult instanceof Array) {\n                    if (el != null && ix !== undefined && typeof ix !== \"number\") {\n                        // tslint:disable-next-line:no-parameter-reassignment\n                        ix = _indexOf(el.childNodes, ix);\n                    }\n                    this._processEventResult(eventResult, el, ix);\n                }\n        }\n    };\n    /**\n     * Force an immediate validation which is guaranteed to go at least up to the\n     * point specified by ``container, index``, exclusively. These parameters are\n     * interpreted in the same way a DOM caret is.\n     *\n     * If the validation has not yet reached the location specified, validation\n     * will immediately be performed to reach the point. If the validation has\n     * already reached this point, then this call is a no-op.\n     *\n     * There is one exception in the way the ``container, index`` pair is\n     * interpreted. If the container is the ``root`` that was passed when\n     * constructing the Validator, then setting ``index`` to a negative value will\n     * result in the validation validating all elements **and** considering the\n     * document complete. So unclosed tags or missing elements will be\n     * reported. Otherwise, the validation goes up the ``index`` but considers the\n     * document incomplete, and won't report the errors that are normally reported\n     * at the end of a document. For instance, unclosed elements won't be\n     * reported.\n     *\n     * @param container The location up to where to validate.\n     *\n     * @param index The location up to where to validate.\n     *\n     * @param attributes Whether we are interested to validate up to and including\n     * the attribute events of the node pointed to by ``container, index``. The\n     * validation ends before leaving the start tag.\n     *\n     * @throws {Error} If ``container`` is not of element or text type.\n     */\n    Validator.prototype._validateUpTo = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        // tslint:disable-next-line:no-parameter-reassignment\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to validate after attributes but before \" +\n                \"the end of the start tag on a \" +\n                \"node which is not an element node\");\n        }\n        // Set these to reasonable defaults. The rest of the code is dedicated to\n        // changing these values to those necessary depending on specifics of what\n        // is passed to the method.\n        var toInspect = container;\n        var dataKey = \"EventIndexAfter\";\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (attributes) {\n                dataKey = \"EventIndexAfterAttributes\";\n                toInspect = container.childNodes[index];\n            }\n            else if (index === 0) {\n                // We're before the top element, no events to fire.\n                return;\n            }\n            // default values of toInspect and dataKey are what we want\n        }\n        else {\n            if (isAttr(container)) {\n                toInspect = container.ownerElement;\n                dataKey = \"EventIndexBeforeAttributes\";\n            }\n            else {\n                switch (container.nodeType) {\n                    case Node.TEXT_NODE:\n                        toInspect = container.previousElementSibling;\n                        if (toInspect === null) {\n                            // tslint:disable-next-line:no-non-null-assertion\n                            toInspect = container.parentNode;\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    case Node.ELEMENT_NODE:\n                    case Node.DOCUMENT_FRAGMENT_NODE:\n                    case Node.DOCUMENT_NODE:\n                        var node = container.childNodes[index];\n                        var prev = node === undefined ?\n                            container.lastElementChild :\n                            // It may not be an element, in which case we get \"undefined\".\n                            node.previousElementSibling;\n                        if (attributes) {\n                            dataKey = \"EventIndexAfterAttributes\";\n                            toInspect = node;\n                        }\n                        else if (prev !== null) {\n                            toInspect = prev;\n                        }\n                        else {\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    default:\n                        throw new Error(\"unexpected node type: \" + container.nodeType);\n                }\n            }\n        }\n        while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n            this._cycle();\n        }\n    };\n    /**\n     * Gets the walker which would represent the state of parsing at the point\n     * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n     * of how these parameters are interpreted.\n     *\n     * **The walker returned by this function is not guaranteed to be a new\n     *   instance. Callers should not modify the walker returned but instead clone\n     *   it.**\n     *\n     * @param container\n     *\n     * @param index\n     *\n     * @param attributes Whether we are interested to validate up to but not\n     * including the attribute events of the node pointed to by ``container,\n     * index``. If ``true`` the walker returned will have all events fired on it\n     * up to, and including, those attribute events on the element pointed to by\n     * ``container, index``.\n     *\n     * @returns The walker.\n     *\n     * @throws {EventIndexException} If it runs out of events or computes an event\n     * index that makes no sense.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._getWalkerAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        // tslint:disable-next-line:no-parameter-reassignment\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to get a walker for attribute events on a \" +\n                \"node which is not an element node\");\n        }\n        // Make sure we have the data we need.\n        this._validateUpTo(container, index, attributes);\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (!attributes) {\n                // We're before the top element, no events to fire.\n                if (index === 0) {\n                    return this.schema.newWalker();\n                }\n                // _validateUpTo ensures that the current walker held by the validator\n                // is what we want. We can just return it here because it is the\n                // caller's reponsibility to either not modify it or clone it.\n                return this._validationWalker;\n            }\n        }\n        var walker;\n        function fireTextEvent(textNode) {\n            if (walker === undefined) {\n                throw new Error(\"calling fireTextEvent without a walker\");\n            }\n            walker.fireEvent(\"text\", [textNode.data]);\n        }\n        if (isAttr(container)) {\n            var el = container.ownerElement;\n            walker = this.readyWalker(\n            // tslint:disable-next-line:no-non-null-assertion\n            this.getNodeProperty(el, \"EventIndexBeforeAttributes\"));\n            // Don't fire on namespace attributes.\n            if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n                walker = walker.clone();\n                this._fireAttributeNameEvent(walker, container);\n            }\n        }\n        else {\n            switch (container.nodeType) {\n                case Node.TEXT_NODE: {\n                    var prev = container.previousElementSibling;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (prev !== null) {\n                        getFrom = prev;\n                        propName = \"EventIndexAfter\";\n                    }\n                    else {\n                        // tslint:disable-next-line:no-non-null-assertion\n                        getFrom = container.parentNode;\n                        propName = \"EventIndexAfterStart\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    // We will attempt to fire a text event if our location is inside the\n                    // current text node.\n                    //\n                    // A previous version of this code was also checking whether there is a\n                    // text node between this text node and prev but this cannot happen\n                    // because the tree on which validation is performed cannot have two\n                    // adjacent text nodes. It was also checking whether there was a _text\n                    // element between prev and this text node but this also cannot happen.\n                    if (index > 0) {\n                        walker = walker.clone();\n                        fireTextEvent(container);\n                    }\n                    break;\n                }\n                case Node.ELEMENT_NODE:\n                case Node.DOCUMENT_NODE:\n                case Node.DOCUMENT_FRAGMENT_NODE: {\n                    var node = container.childNodes[index];\n                    var prev = void 0;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (!attributes) {\n                        prev = node === undefined ? container.lastElementChild :\n                            node.previousElementSibling;\n                        if (prev !== null) {\n                            getFrom = prev;\n                            propName = \"EventIndexAfter\";\n                        }\n                        else {\n                            getFrom = container;\n                            propName = \"EventIndexAfterStart\";\n                        }\n                    }\n                    else {\n                        getFrom = node;\n                        propName = \"EventIndexAfterAttributes\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    if (!attributes) {\n                        // We will attempt to fire a text event if another text node appeared\n                        // between the node we care about and the element just before it.\n                        var prevSibling = node != null ? node.previousSibling : null;\n                        if (prevSibling !== null &&\n                            // If the previous sibling is the same as the previous *element*\n                            // sibbling, then there is nothing *between* that we need to take\n                            // care of.\n                            prevSibling !== prev) {\n                            if (prevSibling.nodeType === Node.TEXT_NODE) {\n                                walker = walker.clone();\n                                fireTextEvent(prevSibling);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(\"unexpected node type: \" + container.nodeType);\n            }\n        }\n        return walker;\n    };\n    Validator.prototype.readyWalker = function (eventIndex) {\n        //\n        // Perceptive readers will notice that the caching being done here could be\n        // more aggressive. It turns out that the cases where we have to clone the\n        // walker after getting it from the cache are not that frequently used, so\n        // there is little to gain from being more aggressive. Furthermore, it is\n        // likely that the caching system will change when we implement a saner way\n        // to reset validation and segment large documents into smaller chunks.\n        //\n        if (eventIndex === undefined) {\n            throw new EventIndexException();\n        }\n        var cache = this._walkerCache;\n        var max = this._walkerCacheMax;\n        var walker = cache[eventIndex];\n        if (walker !== undefined) {\n            return walker;\n        }\n        //\n        // Scan the cache for a walker we could use... rather than start from zero.\n        //\n        // There is no point in trying to be clever by using this._walkerCacheGap to\n        // start our search. If _getWalkerAt is called with decreasing positions in\n        // the document, then the gap is meaningless for our search. (Such scenario\n        // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n        // cannot assume that it won't happen.)\n        //\n        // Also, the following approach is a bit crude but trying to be clever with\n        // Object.keys() and then searching through a sorted list does not yield an\n        // appreciable improvement. Maybe on very large documents it would but this\n        // module will have to be redesigned to tackle that so there's no point now\n        // to be cleverer than this. We also tested using a sparse Array for the\n        // cache and got visibly worse performance. And we tested to see if a flag\n        // indicating if the cache has anything in it would help avoid doing a long\n        // search but it maked things worse. Basically, it seems that the typical\n        // usage pattern of _getWalkerAt is such that it will usually be called in\n        // increasing order of position in the document.\n        //\n        var searchIx = eventIndex;\n        if (searchIx >= max) {\n            searchIx = max;\n            walker = cache[searchIx];\n        }\n        else {\n            while (walker === undefined && --searchIx >= 0) {\n                walker = cache[searchIx];\n            }\n        }\n        if (walker !== undefined) {\n            walker = walker.clone();\n        }\n        else {\n            walker = this.schema.newWalker();\n            searchIx = 0;\n        }\n        for (var ix = searchIx; ix < eventIndex; ++ix) {\n            var _a = this._validationEvents[ix], name_1 = _a.name, params = _a.params;\n            switch (name_1) {\n                case \"enterContext\":\n                    walker.enterContext();\n                    break;\n                case \"leaveContext\":\n                    walker.leaveContext();\n                    break;\n                case \"definePrefix\":\n                    walker.definePrefix(params[0], params[1]);\n                    break;\n                default:\n                    walker.fireEvent(name_1, params);\n            }\n        }\n        // This is a bit arbitrary to find a balance between caching too much\n        // information and spending too much time computing walkers.\n        if (eventIndex - searchIx >= this._walkerCacheGap) {\n            cache[eventIndex] = walker;\n            this._walkerCacheMax = Math.max(eventIndex, max);\n        }\n        return walker;\n    };\n    /**\n     * Returns the set of possible events for the location specified by the\n     * parameters.\n     *\n     * @param container Together with ``index`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param index Together with ``container`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param attributes\n     *\n     * @returns A set of possible events.\n     */\n    Validator.prototype.possibleAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        var walker = this._getWalkerAt(container, index, attributes);\n        // Calling possible does not *modify* the walker.\n        return walker.possible();\n    };\n    /**\n     * Finds the locations in a node where a certain validation event is\n     * possible.\n     *\n     * @param container A node.\n     *\n     * @param event The event to search for. The event should contain the same\n     * data as would be passed to ``fireEvent``. Specifically, name patterns may\n     * not be used in the event passed to this method.\n     *\n     * @returns The locations in ``container`` where the event is possible.\n     */\n    Validator.prototype.possibleWhere = function (container, event) {\n        var ret = [];\n        var params = event.params;\n        try {\n            for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n                var param = params_1_1.value;\n                if (typeof param !== \"string\") {\n                    throw new Error(\"this method does not accept event with name \\\npatterns: convert the pattern to a uri, localPart pair\");\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        var name = params[0];\n        if (name === \"startTagAndAttributes\" || name === \"attributeNameAndValue\") {\n            throw new Error(\"this method does not support \" + name + \": you must use granular events instead\");\n        }\n        var eventString = event.toString();\n        for (var index = 0; index <= container.childNodes.length; ++index) {\n            var possible = this.possibleAt(container, index);\n            if (name === \"enterStartTag\" || name === \"attributeName\") {\n                try {\n                    // In the case where we have a name pattern as the 2nd parameter, and\n                    // this pattern can be complex or have wildcards, then we have to check\n                    // all events one by one for a name pattern match. (While enterStartTag,\n                    // endTag and attributeName all have name patterns, endTag cannot be\n                    // complex or allow wildcards because what it allows much match the tag\n                    // that started the current element. This is why we do not use this\n                    // branch to test for it.)\n                    for (var possible_1 = __values(possible), possible_1_1 = possible_1.next(); !possible_1_1.done; possible_1_1 = possible_1.next()) {\n                        var candidate = possible_1_1.value;\n                        if (candidate.params[0] === name &&\n                            candidate.params[1].match(params[1], params[2])) {\n                            ret.push(index);\n                            break;\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (possible_1_1 && !possible_1_1.done && (_b = possible_1.return)) _b.call(possible_1);\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            }\n            else {\n                try {\n                    for (var possible_2 = __values(possible), possible_2_1 = possible_2.next(); !possible_2_1.done; possible_2_1 = possible_2.next()) {\n                        var candidate = possible_2_1.value;\n                        if (candidate.toString() === eventString) {\n                            ret.push(index);\n                            break;\n                        }\n                    }\n                }\n                catch (e_7_1) { e_7 = { error: e_7_1 }; }\n                finally {\n                    try {\n                        if (possible_2_1 && !possible_2_1.done && (_c = possible_2.return)) _c.call(possible_2);\n                    }\n                    finally { if (e_7) throw e_7.error; }\n                }\n            }\n        }\n        return ret;\n        var e_5, _a, e_6, _b, e_7, _c;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidate = function (container, index, toParse) {\n        var clone;\n        if (toParse instanceof Array) {\n            clone = container.ownerDocument.createDocumentFragment();\n            try {\n                for (var toParse_1 = __values(toParse), toParse_1_1 = toParse_1.next(); !toParse_1_1.done; toParse_1_1 = toParse_1.next()) {\n                    var child = toParse_1_1.value;\n                    clone.insertBefore(child.cloneNode(true), null);\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (toParse_1_1 && !toParse_1_1.done && (_a = toParse_1.return)) _a.call(toParse_1);\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n        }\n        else {\n            clone = toParse.cloneNode(true);\n        }\n        var root = container.ownerDocument.createElement(\"div\");\n        root.insertBefore(clone, null);\n        return this.speculativelyValidateFragment(container, index, root);\n        var e_8, _a;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse. See above.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidateFragment = function (container, index, toParse) {\n        // This is useful for pure-JS code that may be calling this.\n        if (toParse.nodeType !== Node.ELEMENT_NODE) {\n            throw new Error(\"toParse is not an element\");\n        }\n        // We create a new validator with the proper state to parse the fragment\n        // we've been given.\n        var dup = new Validator(this.schema, toParse);\n        // We have to clone the walker to prevent messing up the internal cache.\n        dup._validationWalker = this._getWalkerAt(container, index).clone();\n        // This forces validating the whole fragment\n        dup._validateUpTo(toParse, toParse.childNodes.length);\n        if (dup._errors.length !== 0) {\n            return dup._errors;\n        }\n        return false;\n    };\n    /**\n     * Obtain the validation errors that belong to a specific node.\n     *\n     * The term \"that belong to\" has a specific meaning here:\n     *\n     * - An error in the contents of an element belongs to the element whose\n     *   contents are incorrect. For instance if in the sequence\n     *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n     *   error belongs to the node for the element ``foo``, not the node for the\n     *   element ``blip``.\n     *\n     * - Attribute errors belong to the element node to which the attributes\n     *   belong.\n     *\n     * @param node The node whose errors we want to get.\n     *\n     * @returns The errors.\n     */\n    Validator.prototype.getErrorsFor = function (node) {\n        var parent = node.parentNode;\n        if (parent === null) {\n            throw new Error(\"node without a parent!\");\n        }\n        // Validate to after the closing tag of the node.\n        this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n        var ret = [];\n        try {\n            for (var _a = __values(this._errors), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var errorData = _b.value;\n                if (errorData.node === node) {\n                    ret.push(errorData);\n                }\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        return ret;\n        var e_9, _c;\n    };\n    /**\n     * Sets a flag indicating whether a node is possible only due to a name\n     * pattern wildcard, and emits an event if setting the flag is a change from\n     * the previous value of the flag. It does this by inspecting the event that\n     * would be fired when ``node`` is validated. The parameters ``eventName``,\n     * ``ns`` and ``name`` are used to determine what we are looking for among\n     * possible events.\n     *\n     * @param node The node we want to check.\n     *\n     * @param walker A walker whose last fired event is the one just before the\n     * event that would be fired when validating ``node``.\n     *\n     * @param eventName The event name we are interested in.\n     *\n     * @param ns The namespace to use with the event.\n     *\n     * @param name The name to use with the event.\n     *\n     * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n     *\n     */\n    Validator.prototype._setPossibleDueToWildcard = function (node, walker, eventName, ns, name) {\n        var previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n        var possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n        this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n        if (previous === undefined || previous !== possible) {\n            /**\n             * Tells the listener that a node's flag indicating whether it is possible\n             * only due to a wildcard has changed.\n             *\n             * @event module:validator~Validator#possible-due-to-wildcard-change\n             *\n             * @type {Node} The node whose flag has changed.\n             */\n            this._events._emit(\"possible-due-to-wildcard-change\", node);\n        }\n    };\n    /**\n     * Resolve a qualified name to an expanded name. See\n     * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n     * takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param name The name to rresolve.\n     *\n     * @param attributes Whether the name is an attribute's name.\n     *\n     * @return The resolved name.\n     */\n    Validator.prototype.resolveNameAt = function (container, index, name, attribute) {\n        if (attribute === void 0) { attribute = false; }\n        // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n        // its ``attribute`` parameter ``false``.\n        return this._getWalkerAt(container, index).resolveName(name, attribute);\n    };\n    /**\n     * Unresolve an expanded name to a qualified name. See\n     * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n     * method takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param uri The URI to unresolve.\n     *\n     * @param name The name to unresolve.\n     *\n     * @return The unresolved name.\n     */\n    Validator.prototype.unresolveNameAt = function (container, index, uri, name) {\n        return this._getWalkerAt(container, index).unresolveName(uri, name);\n    };\n    return Validator;\n}());\nexports.Validator = Validator;\n/**\n * Exception to be raised if we cannot parse a string as an XML document.\n */\nvar ParsingError = /** @class */ (function (_super) {\n    __extends(ParsingError, _super);\n    /**\n     * @param xmlErrors A string that contains the errors reported. The library\n     * here simply serializes the error document produced by the parser.\n     */\n    function ParsingError(xmlErrors) {\n        var _this = _super.call(this) || this;\n        _this.xmlErrors = xmlErrors;\n        var err = new Error(\"cannot parse\");\n        _this.name = \"ParsingError\";\n        _this.stack = err.stack;\n        _this.message = err.message;\n        tools_1.fixPrototype(_this, ParsingError);\n        return _this;\n    }\n    return ParsingError;\n}(Error));\nexports.ParsingError = ParsingError;\n// tslint:disable-next-line:no-http-string\nvar XML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\nvar MOZILLA_NAMESPACE = \n// tslint:disable-next-line:no-http-string\n\"http://www.mozilla.org/newlayout/xml/parsererror.xml\";\n/**\n * A utility function that detects whether the parsing fails and throws an error\n * in such case.\n *\n * Note that if you pass a well-formed and correctly structured error document\n * to this function, the result will look like an error, even though it was\n * parsed properly. Given the way ``DOMParser`` reports errors, this cannot be\n * helped.\n *\n * @param source The XML to parse.\n *\n * @param win The window from which to create a ``DOMParser``.\n *\n * @returns The parsed document.\n *\n * @throws {ParsingError} If the source cannot be parsed.\n */\nfunction safeParse(source, win) {\n    if (win === void 0) { win = window; }\n    var parser = new win.DOMParser();\n    var doc;\n    try {\n        doc = parser.parseFromString(source, \"text/xml\");\n    }\n    catch (ex) {\n        // On IE10/11 bad source will cause a SyntaxError.\n        if (ex.name !== \"SyntaxError\" || ex.code !== 12) {\n            throw ex;\n        }\n        throw new ParsingError(\"no error information available\");\n    }\n    // A DOMParser will generate a document that contains a description of the\n    // error(s). Unfortunately, this document is not consistently generated across\n    // browsers.\n    //\n    // However, running the code through Browser Stack on Chrome, Firefox, IE\n    // 10-100, Edge, Opera, and Safari that they boil down either to the Chrome\n    // case or the Firefox case.\n    if (\n    // Firefox\n    (doc.getElementsByTagNameNS(MOZILLA_NAMESPACE, \"parsererror\")[0] !==\n        undefined) ||\n        // Chrome\n        (doc.getElementsByTagNameNS(XML_NAMESPACE, \"parsererror\")[0] !==\n            undefined)) {\n        throw new ParsingError(doc.documentElement.outerHTML);\n    }\n    return doc;\n}\nexports.safeParse = safeParse;\n//# sourceMappingURL=main.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/main.js\n// module id = 0\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"salve\"\n// module id = 1\n// module chunks = 0 1","\"use strict\";\n/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this._eventListeners = Object.create(null);\n        this._generalListeners = [];\n        this._trace = false;\n    }\n    EventEmitter.prototype.addEventListener = function (eventName, listener) {\n        if (eventName === \"*\") {\n            this._generalListeners.push(listener);\n        }\n        else {\n            var listeners = this._eventListeners[eventName];\n            if (listeners === undefined) {\n                listeners = this._eventListeners[eventName] = [];\n            }\n            listeners.push(listener);\n        }\n    };\n    EventEmitter.prototype.addOneTimeEventListener = function (eventName, listener) {\n        var _this = this;\n        // We perform casts as any here to indicate to TypeScript that it is\n        // safe to pass this stub.\n        var me = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.removeEventListener(eventName, me);\n            return listener.apply(_this, args);\n        };\n        this.addEventListener(eventName, me);\n        return me;\n    };\n    EventEmitter.prototype.removeEventListener = function (eventName, listener) {\n        var listeners = (eventName === \"*\") ?\n            this._generalListeners :\n            this._eventListeners[eventName];\n        if (listeners === undefined) {\n            return;\n        }\n        var index = listeners.lastIndexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    EventEmitter.prototype.removeAllListeners = function (eventName) {\n        if (eventName === \"*\") {\n            this._generalListeners = [];\n        }\n        else {\n            this._eventListeners[eventName] = [];\n        }\n    };\n    /**\n     * This is the function that the class using this mixin must call to\n     * indicate that an event has occurred.\n     *\n     * @param eventName The name of the event to emit.\n     *\n     * @param ev The event data to provide to handlers. The type can be\n     * anything.\n     */\n    EventEmitter.prototype._emit = function (eventName, ev) {\n        if (this._trace) {\n            // tslint:disable-next-line: no-console\n            console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n        }\n        {\n            var listeners = this._generalListeners;\n            if (listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                try {\n                    for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\n                        var listener = listeners_1_1.value;\n                        var ret = listener.call(undefined, eventName, ev);\n                        if (ret === false) {\n                            return;\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        }\n        {\n            var listeners = this._eventListeners[eventName];\n            if (listeners !== undefined && listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                try {\n                    for (var listeners_2 = __values(listeners), listeners_2_1 = listeners_2.next(); !listeners_2_1.done; listeners_2_1 = listeners_2.next()) {\n                        var listener = listeners_2_1.value;\n                        var ret = listener.call(undefined, ev);\n                        if (ret === false) {\n                            return;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (listeners_2_1 && !listeners_2_1.done && (_b = listeners_2.return)) _b.call(listeners_2);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        var e_1, _a, e_2, _b;\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n//  LocalWords:  Mangalam MPL Dubeau noop ev mixin\n//# sourceMappingURL=event_emitter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/event_emitter.js\n// module id = 2\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\nfunction fixPrototype(obj, parent) {\n    var oldProto = Object.getPrototypeOf !== undefined ?\n        Object.getPrototypeOf(obj) :\n        obj.__proto__;\n    if (oldProto !== parent) {\n        if (Object.setPrototypeOf !== undefined) {\n            Object.setPrototypeOf(obj, parent.prototype);\n        }\n        else {\n            obj.__proto__ = parent.prototype;\n        }\n    }\n}\nexports.fixPrototype = fixPrototype;\n//# sourceMappingURL=tools.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./build/dist/lib/tools.js\n// module id = 3\n// module chunks = 0 1"],"sourceRoot":""}