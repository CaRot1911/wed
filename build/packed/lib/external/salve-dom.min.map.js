{"version":3,"sources":["webpack://salve-dom/webpack/universalModuleDefinition","webpack://salve-dom/webpack/bootstrap","webpack://salve-dom/./build/dist/lib/tools.js","webpack://salve-dom/./build/dist/lib/event_emitter.js","webpack://salve-dom/external \"salve\"","webpack://salve-dom/./build/dist/lib/main.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__2__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","fixPrototype","obj","parent","undefined","getPrototypeOf","__proto__","setPrototypeOf","__values","this","Symbol","iterator","next","length","done","EventEmitter","_eventListeners","create","_generalListeners","_trace","addEventListener","eventName","listener","push","listeners","addOneTimeEventListener","_this","me","args","_i","arguments","removeEventListener","apply","index","lastIndexOf","splice","removeAllListeners","_emit","ev","e_1","_a","e_2","_b","console","log","slice","listeners_1","listeners_1_1","e_1_1","error","return","listeners_2","listeners_2_1","e_2_1","extendStatics","__extends","Array","b","__","constructor","salve_1","event_emitter_1","tools_1","_indexOf","needle","indexOf","WorkingState","attrNodeType","Node","ATTRIBUTE_NODE","isAttr","it","nodeType","Attr","ProgressState","partDone","portion","EventIndexException","_super","Error","Validator","schema","options","_cycleEntered","_timeout","_maxTimespan","_resetting","_errors","_errorsSeen","_boundWrapper","_workWrapper","bind","_validationEvents","_workingState","INCOMPLETE","_partDone","_validationStage","_previousChild","_validationStack","_walkerCache","_walkerCacheMax","_prefix","_walkerCacheGap","_events","keys_1","keys_1_1","key","prefix","_curEl","_setNodeProperty","_setWorkingState","_validationWalker","newWalker","events","makeKey","getNodeProperty","node","_clearNodeProperties","anode","start","_timeoutId","_stop","WORKING","setTimeout","getSchemaNamespaces","getNamespaces","getDocumentNamespaces","ret","_process","attrIxLim","attributes","attrIx","attr","array","child","firstChild","ELEMENT_NODE","nextSibling","_work","startDate","Date","now","_cycle","walker","stack","stage","_loop_1","curEl","this_1","unshift","_fireAndProcessEvent","uri","tagName","parent_1","parentNode","curElIndex","childNodes","ename","resolveName","_processEventResult","ValidationError","EName","_setPossibleDueToWildcard","ns","_fireAttributeEvents","textAccumulatorNode_1","textAccumulator_1","flushText","eventResult","fireEvent","parent_2","TEXT_NODE","data","childElementCount","COMMENT_NODE","end","_runDocumentValidation","INVALID","VALID","originalElement","nextDone","shift","first","stage_change","state_1","stop","state","clearTimeout","restartAt","resetTo","_resetTo","_erase","el","firstElementChild","nextElementSibling","at","newState","newDone","changed","getWorkingState","results","results_1","results_1_1","result","_processError","e_3_1","e_3","nodeGettingId","oldId","String","toString","_fireAttributeNameEvent","attrName","params","ix","enterContext","leaveContext","definePrefix","_validateUpTo","container","toInspect","dataKey","ownerElement","previousElementSibling","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","prev","lastElementChild","_getWalkerAt","fireTextEvent","textNode","readyWalker","clone","getFrom","propName","prevSibling","previousSibling","eventIndex","cache","max","searchIx","name_1","Math","possibleAt","possible","possibleWhere","event","params_1","params_1_1","e_4_1","e_4","e_5","e_6","_c","eventString","hasNamePattern","possible_1","possible_1_1","candidate","match","e_5_1","possible_2","possible_2_1","e_6_1","speculativelyValidate","toParse","ownerDocument","createDocumentFragment","toParse_1","toParse_1_1","insertBefore","cloneNode","e_7_1","e_7","createElement","speculativelyValidateFragment","dup","getErrorsFor","e_8","errorData","e_8_1","previous","evs","matched","evs_1","evs_1_1","namePattern","wildcardMatch","isPossibleDueToWildcard","resolveNameAt","attribute","unresolveNameAt","unresolveName","ParsingError","xmlErrors","err","message","XML_NAMESPACE","MOZILLA_NAMESPACE","safeParse","source","win","doc","parser","DOMParser","parseFromString","ex","code","getElementsByTagNameNS","documentElement","outerHTML"],"mappings":"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","file":"salve-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"salve\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"salve\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salve-dom\"] = factory(require(\"salve\"));\n\telse\n\t\troot[\"salve-dom\"] = factory(root[\"salve\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__2__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\nfunction fixPrototype(obj, parent) {\n    var oldProto = Object.getPrototypeOf !== undefined ?\n        Object.getPrototypeOf(obj) :\n        obj.__proto__;\n    if (oldProto !== parent) {\n        if (Object.setPrototypeOf !== undefined) {\n            Object.setPrototypeOf(obj, parent.prototype);\n        }\n        else {\n            obj.__proto__ = parent.prototype;\n        }\n    }\n}\nexports.fixPrototype = fixPrototype;\n//# sourceMappingURL=tools.js.map","\"use strict\";\n/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this._eventListeners = Object.create(null);\n        this._generalListeners = [];\n        this._trace = false;\n    }\n    EventEmitter.prototype.addEventListener = function (eventName, listener) {\n        if (eventName === \"*\") {\n            this._generalListeners.push(listener);\n        }\n        else {\n            var listeners = this._eventListeners[eventName];\n            if (listeners === undefined) {\n                listeners = this._eventListeners[eventName] = [];\n            }\n            listeners.push(listener);\n        }\n    };\n    EventEmitter.prototype.addOneTimeEventListener = function (eventName, listener) {\n        var _this = this;\n        // We perform casts as any here to indicate to TypeScript that it is\n        // safe to pass this stub.\n        var me = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.removeEventListener(eventName, me);\n            return listener.apply(_this, args);\n        };\n        this.addEventListener(eventName, me);\n        return me;\n    };\n    EventEmitter.prototype.removeEventListener = function (eventName, listener) {\n        var listeners = (eventName === \"*\") ?\n            this._generalListeners :\n            this._eventListeners[eventName];\n        if (listeners === undefined) {\n            return;\n        }\n        var index = listeners.lastIndexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    EventEmitter.prototype.removeAllListeners = function (eventName) {\n        if (eventName === \"*\") {\n            this._generalListeners = [];\n        }\n        else {\n            this._eventListeners[eventName] = [];\n        }\n    };\n    /**\n     * This is the function that the class using this mixin must call to\n     * indicate that an event has occurred.\n     *\n     * @param eventName The name of the event to emit.\n     *\n     * @param ev The event data to provide to handlers. The type can be\n     * anything.\n     */\n    EventEmitter.prototype._emit = function (eventName, ev) {\n        if (this._trace) {\n            // tslint:disable-next-line: no-console\n            console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n        }\n        {\n            var listeners = this._generalListeners;\n            if (listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                try {\n                    for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\n                        var listener = listeners_1_1.value;\n                        var ret = listener.call(undefined, eventName, ev);\n                        if (ret === false) {\n                            return;\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        }\n        {\n            var listeners = this._eventListeners[eventName];\n            if (listeners !== undefined && listeners.length > 0) {\n                // We take a copy so that if any of the handlers add or remove\n                // listeners, they don't disturb our work here.\n                listeners = listeners.slice();\n                try {\n                    for (var listeners_2 = __values(listeners), listeners_2_1 = listeners_2.next(); !listeners_2_1.done; listeners_2_1 = listeners_2.next()) {\n                        var listener = listeners_2_1.value;\n                        var ret = listener.call(undefined, ev);\n                        if (ret === false) {\n                            return;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (listeners_2_1 && !listeners_2_1.done && (_b = listeners_2.return)) _b.call(listeners_2);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        var e_1, _a, e_2, _b;\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n//  LocalWords:  Mangalam MPL Dubeau noop ev mixin\n//# sourceMappingURL=event_emitter.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nvar salve_1 = require(\"salve\");\nvar event_emitter_1 = require(\"./event_emitter\");\nvar tools_1 = require(\"./tools\");\nfunction _indexOf(parent, needle) {\n    return Array.prototype.indexOf.call(parent, needle);\n}\n// We check that ``Node.ATTRIBUTE_NODE`` is not undefined because eventually\n// ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n// could be testing ``undefined === undefined`` for objects which are not\n// attributes, which would return ``true``. The function is not very strict but\n// it should not be too lax either.\nvar attrNodeType = Node.ATTRIBUTE_NODE;\nexports.isAttr = attrNodeType !== undefined ?\n    function (it) { return it.nodeType === attrNodeType; } :\n    function (it) { return it instanceof Attr; };\n// Working state values\nvar WorkingState;\n(function (WorkingState) {\n    /**\n     * The validator is stopped but has not completed a validation pass yet.\n     */\n    WorkingState[WorkingState[\"INCOMPLETE\"] = 1] = \"INCOMPLETE\";\n    /**\n     * The validator is working on validating the document.\n     */\n    WorkingState[WorkingState[\"WORKING\"] = 2] = \"WORKING\";\n    /**\n     * The validator is stopped and has found the document invalid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"INVALID\"] = 3] = \"INVALID\";\n    /**\n     * The validator is stopped and has found the document valid. Note that this\n     * state happens *only* if the whole document was validated.\n     */\n    WorkingState[WorkingState[\"VALID\"] = 4] = \"VALID\";\n})(WorkingState = exports.WorkingState || (exports.WorkingState = {}));\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nvar ProgressState = /** @class */ (function () {\n    function ProgressState(partDone, portion) {\n        this.partDone = partDone;\n        this.portion = portion;\n    }\n    return ProgressState;\n}());\n//\n// Note: the Validator class adds information to the Element nodes it is working\n// with by adding expando properties that start with \"wed_event_\". This deemed\n// acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to be open to\n//   third party software. Even if it were, the chance of a clash is small.\n//\n// * The values of the expando properties are primitives (not objects or other\n//   elements).\n//\n// * We don't care about browsers or situations where expando properties are not\n//   supported.\n//\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nvar EventIndexException = /** @class */ (function (_super) {\n    __extends(EventIndexException, _super);\n    function EventIndexException() {\n        var _this = _super.call(this, \"undefined event_index; _validateUpTo should have taken care of that\") || this;\n        tools_1.fixPrototype(_this, EventIndexException);\n        return _this;\n    }\n    return EventIndexException;\n}(Error));\n// This private utility function checks whether an event is possible *only*\n// because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker, eventName, ns, name) {\n    var evs = walker.possible();\n    var matched = false;\n    try {\n        for (var evs_1 = __values(evs), evs_1_1 = evs_1.next(); !evs_1_1.done; evs_1_1 = evs_1.next()) {\n            var ev = evs_1_1.value;\n            if (ev.params[0] !== eventName) {\n                continue;\n            }\n            var namePattern = ev.params[1];\n            if (namePattern.match(ns, name)) {\n                // We already know that it matches, and this is not merely due to a\n                // wildcard.\n                if (!namePattern.wildcardMatch(ns, name)) {\n                    return false;\n                }\n                // Keep track of whether it ever matched anything.\n                matched = true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (evs_1_1 && !evs_1_1.done && (_a = evs_1.return)) _a.call(evs_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // If it never matched any pattern at all, then we must return false.  If we\n    // get here and matched is true then it means that it matched all patterns due\n    // to wildcards.\n    return matched;\n    var e_1, _a;\n}\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nvar Validator = /** @class */ (function () {\n    function Validator(schema, root, options) {\n        if (options === void 0) { options = {}; }\n        this.schema = schema;\n        this.root = root;\n        this._cycleEntered = 0;\n        this._timeout = 200;\n        this._maxTimespan = 100;\n        this._resetting = false;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._boundWrapper = this._workWrapper.bind(this);\n        // Validation state\n        this._validationEvents = [];\n        this._workingState = WorkingState.INCOMPLETE;\n        this._partDone = 0;\n        this._validationStage = 2 /* CONTENTS */;\n        this._previousChild = null;\n        this._validationStack = [new ProgressState(0, 1)];\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        this._prefix = \"salveDom\";\n        // The distance between walkers under which we skip saving a walker in the\n        // cache.\n        this._walkerCacheGap = 100;\n        this._events = new event_emitter_1.EventEmitter();\n        var keys = [\"timeout\", \"maxTimespan\",\n            \"walkerCacheGap\"];\n        try {\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                var key = keys_1_1.value;\n                var value = options[key];\n                if (value === undefined) {\n                    continue;\n                }\n                if (value < 0) {\n                    throw new Error(\"the value for \" + key + \" cannot be negative\");\n                }\n                this[\"_\" + key] = options[key];\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        if (options.prefix !== undefined) {\n            this._prefix = options.prefix;\n        }\n        this._curEl = this.root;\n        // This prevents an infinite loop when speculativelyValidate is called to\n        // validate a text node.\n        this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", this._validationEvents.length);\n        this._setWorkingState(WorkingState.INCOMPLETE, 0);\n        this._validationWalker = this.schema.newWalker();\n        this.events = this._events;\n        var e_2, _a;\n    }\n    Validator.prototype.makeKey = function (key) {\n        return \"\" + this._prefix + key;\n    };\n    /**\n     * Function allowing to get a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype.getNodeProperty = function (node, key) {\n        return node[this.makeKey(key)];\n    };\n    /**\n     * Function allowing to set a custom properties set on ``Node`` objects by\n     * this class.\n     */\n    Validator.prototype._setNodeProperty = function (node, key, value) {\n        node[this.makeKey(key)] = value;\n    };\n    Validator.prototype._clearNodeProperties = function (node) {\n        var anode = node;\n        delete anode[this.makeKey(\"EventIndexAfter\")];\n        delete anode[this.makeKey(\"EventIndexAfterStart\")];\n        delete anode[this.makeKey(\"EventIndexBeforeAttributes\")];\n        delete anode[this.makeKey(\"EventIndexAfterAttributes\")];\n        delete anode[this.makeKey(\"PossibleDueToWildcard\")];\n        delete anode[this.makeKey(\"ErrorId\")];\n    };\n    /**\n     * Starts the background validation process.\n     */\n    Validator.prototype.start = function () {\n        if (this._timeoutId !== undefined) {\n            this._stop(WorkingState.WORKING);\n        }\n        // When we call ``this.start``, we want the validation to start ASAP. So we\n        // do not use ``this._timeout`` here. However, we do not call\n        // ``this._workWrapper`` directly because we want to be able to call\n        // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n        // directly, we'd be calling this._cycle from inside this._cycle, which is\n        // results in an internal error.\n        this._timeoutId = setTimeout(this._boundWrapper, 0);\n    };\n    /**\n     * Get the namespaces defined in the schema passed to the Validator.\n     *\n     * @returns The namespaces known to the schema.\n     */\n    Validator.prototype.getSchemaNamespaces = function () {\n        return this.schema.getNamespaces();\n    };\n    /**\n     * Get the namespaces used in the document. This method does not cache its\n     * information and scan the whole document independently of the current\n     * validation status.\n     *\n     * @returns An object whose keys are namespace prefixes and values are lists\n     * of namespace URIs.  The values are lists because prefixes can be redefined\n     * in a document.\n     */\n    Validator.prototype.getDocumentNamespaces = function () {\n        var ret = {};\n        function _process(node) {\n            if (node === null) {\n                return;\n            }\n            var attrIxLim = node.attributes.length;\n            for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                var attr = node.attributes[attrIx];\n                if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n                    var key = attr.name.slice(6);\n                    var array = ret[key];\n                    if (array === undefined) {\n                        array = ret[key] = [];\n                    }\n                    array.push(attr.value);\n                }\n            }\n            var child = node.firstChild;\n            while (child !== null) {\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    _process(child);\n                }\n                child = child.nextSibling;\n            }\n        }\n        _process(this.root.firstChild);\n        return ret;\n    };\n    /**\n     * Convenience method. The bound version of this method\n     * (``this._boundWrapper``) is what is called by the timeouts to perform the\n     * background validation.\n     */\n    Validator.prototype._workWrapper = function () {\n        if (this._work()) {\n            this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n        }\n    };\n    /**\n     * Controller method for the background validation. Keeps the validator\n     * running only until done or until the maximum time span for one run\n     * of the validator is reached.\n     *\n     * @returns False if there is no more work to do. True otherwise.\n     */\n    Validator.prototype._work = function () {\n        var startDate = Date.now();\n        while (true) { // tslint:disable-line: no-constant-condition\n            // Give a chance to other operations to work.\n            if ((this._maxTimespan > 0) &&\n                (Date.now() - startDate) >= this._maxTimespan) {\n                return true;\n            }\n            var ret = this._cycle();\n            if (!ret) {\n                return false;\n            }\n        }\n    };\n    /**\n     * Performs one cycle of validation. \"One cycle\" is an arbitrarily small unit\n     * of work.\n     *\n     * @returns False if there is no more work to be done. True otherwise.\n     *\n     * @throws {Error} When there is an internal error.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._cycle = function () {\n        var _this = this;\n        // If we got here after a reset, then we've finished resetting.  If we were\n        // not resetting, then this is a noop.\n        this._resetting = false;\n        //\n        // This check is meant to catch problems that could be hard to diagnose if\n        // wed or one of its modes had a bug such that `_cycle` is reentered from\n        // `_cycle`. This could happen during error processing, for instance. Error\n        // processing causes wed to process the errors, which causes changes in the\n        // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n        // execute something like `getErrorsFor`, which could cause `_cycle` to be\n        // reentered.\n        //\n        if (this._cycleEntered > 0) {\n            throw new Error(\"internal error: _cycle is being reentered\");\n        }\n        if (this._cycleEntered < 0) {\n            throw new Error(\"internal error: _cycleEntered negative\");\n        }\n        //\n        // IMPORTANT: This variable must be decremented before exiting this\n        // method. A try...finally statement is not used here because it would\n        // prevent some virtual machines from optimizing this function.\n        //\n        this._cycleEntered++;\n        var walker = this._validationWalker;\n        var stack = this._validationStack;\n        var events = this._validationEvents;\n        var portion = stack[0].portion;\n        var stage = this._validationStage;\n        var _loop_1 = function () {\n            var curEl = this_1._curEl;\n            switch (stage) {\n                case 1 /* START_TAG */: {\n                    // The logic is such that if we get here curEl must be an Element.\n                    curEl = curEl;\n                    stack.unshift(new ProgressState(this_1._partDone, portion));\n                    // Handle namespace declarations. Yes, this must happen before we deal\n                    // with the tag name.\n                    this_1._fireAndProcessEvent(walker, \"enterContext\", [], curEl, 0);\n                    var attrIxLim = curEl.attributes.length;\n                    for (var attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n                        var attr = curEl.attributes[attrIx];\n                        var uri = void 0;\n                        if (attr.name === \"xmlns\") {\n                            uri = \"\";\n                        }\n                        else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n                            uri = attr.name.slice(6);\n                        }\n                        if (uri !== undefined) {\n                            this_1._fireAndProcessEvent(walker, \"definePrefix\", [uri, attr.value], curEl, 0);\n                        }\n                    }\n                    var tagName = curEl.tagName;\n                    // tslint:disable-next-line:no-non-null-assertion\n                    var parent_1 = curEl.parentNode;\n                    var curElIndex = _indexOf(parent_1.childNodes, curEl);\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        this_1._processEventResult([new salve_1.ValidationError(\"cannot resolve the name \" + tagName)], parent_1, curElIndex);\n                        // This allows us to move forward. It will certainly cause a\n                        // validation error, and send salve into its recovery mode for unknown\n                        // elements.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    // Check whether this element is going to be allowed only due to a\n                    // wildcard.\n                    this_1._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\", ename.ns, ename.name);\n                    this_1._fireAndProcessEvent(walker, \"enterStartTag\", [ename.ns, ename.name], parent_1, curElIndex);\n                    this_1._setNodeProperty(curEl, \"EventIndexBeforeAttributes\", events.length);\n                    this_1._fireAttributeEvents(walker, curEl);\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterAttributes\", events.length);\n                    // Leave the start tag.\n                    this_1._fireAndProcessEvent(walker, \"leaveStartTag\", [], curEl, 0);\n                    stage = this_1._validationStage = 2 /* CONTENTS */;\n                    this_1._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n                    this_1._cycleEntered--;\n                    return { value: true };\n                    // break would be unreachable.\n                }\n                case 2 /* CONTENTS */: {\n                    var node = (this_1._previousChild === null) ?\n                        // starting from scratch\n                        curEl.firstChild :\n                        // already validation contents\n                        this_1._previousChild.nextSibling;\n                    var textAccumulator_1 = \"\";\n                    var textAccumulatorNode_1;\n                    var flushText = function () {\n                        if (textAccumulator_1 !== \"\") {\n                            var eventResult = walker.fireEvent(\"text\", [textAccumulator_1]);\n                            if (eventResult instanceof Array) {\n                                if (textAccumulatorNode_1 === undefined) {\n                                    throw new Error(\"flushText running with undefined node\");\n                                }\n                                // We are never without a parentNode here.\n                                // tslint:disable-next-line:no-non-null-assertion\n                                var parent_2 = textAccumulatorNode_1.parentNode;\n                                _this._processEventResult(eventResult, parent_2, _indexOf(parent_2.childNodes, textAccumulatorNode_1));\n                            }\n                        }\n                        textAccumulator_1 = \"\";\n                        textAccumulatorNode_1 = undefined;\n                    };\n                    while (node !== null) {\n                        switch (node.nodeType) {\n                            case Node.TEXT_NODE:\n                                // Salve does not allow multiple text events in a row. If text is\n                                // encountered, then all the text must be passed to salve as a\n                                // single event. We record the text and will flush it to salve\n                                // later.\n                                textAccumulator_1 += node.data;\n                                if (textAccumulatorNode_1 === undefined) {\n                                    textAccumulatorNode_1 = node;\n                                }\n                                break;\n                            case Node.ELEMENT_NODE:\n                                flushText();\n                                portion /= curEl.childElementCount;\n                                this_1._curEl = curEl = node;\n                                stage = this_1._validationStage = 1 /* START_TAG */;\n                                this_1._previousChild = null;\n                                return \"continue-stage_change\";\n                            case Node.COMMENT_NODE:\n                                break; // We just skip over comment nodes.\n                            default:\n                                throw new Error(\"unexpected node type: \" + node.nodeType);\n                        }\n                        node = node.nextSibling;\n                    }\n                    flushText();\n                    stage = this_1._validationStage = 3 /* END_TAG */;\n                    break;\n                }\n                case 3 /* END_TAG */: {\n                    // We've reached the end...\n                    if (curEl === this_1.root) {\n                        var eventResult = walker.end();\n                        if (eventResult instanceof Array) {\n                            this_1._processEventResult(eventResult, curEl, curEl.childNodes.length);\n                        }\n                        this_1._runDocumentValidation();\n                        this_1._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n                        this_1._partDone = 1;\n                        this_1._stop(this_1._errors.length > 0 ? WorkingState.INVALID :\n                            WorkingState.VALID);\n                        this_1._cycleEntered--;\n                        return { value: false };\n                    }\n                    // we need it later\n                    var originalElement = curEl;\n                    var tagName = curEl.tagName;\n                    var ename = walker.resolveName(tagName, false);\n                    if (ename === undefined) {\n                        // We just produce the name name we produced when we encountered the\n                        // start tag.\n                        ename = new salve_1.EName(\"\", tagName);\n                    }\n                    this_1._fireAndProcessEvent(walker, \"endTag\", [ename.ns, ename.name], curEl, curEl.childNodes.length);\n                    this_1._fireAndProcessEvent(walker, \"leaveContext\", [], curEl, curEl.childNodes.length);\n                    // Go back to the parent\n                    this_1._previousChild = curEl;\n                    // We are never without a parentNode here.\n                    // tslint:disable-next-line:no-non-null-assertion\n                    this_1._curEl = curEl = curEl.parentNode;\n                    var nextDone = this_1._partDone;\n                    if (curEl !== this_1.root) {\n                        stack.shift();\n                        var first = stack[0];\n                        nextDone = first.partDone += portion;\n                        portion = first.portion;\n                    }\n                    this_1._setWorkingState(WorkingState.WORKING, nextDone);\n                    this_1._setNodeProperty(originalElement, \"EventIndexAfter\", this_1._validationEvents.length);\n                    stage = this_1._validationStage = 2 /* CONTENTS */;\n                    this_1._cycleEntered--;\n                    return { value: true };\n                }\n                // break; would be unreachable\n                default:\n                    throw new Error(\"unexpected state\");\n            }\n        };\n        var this_1 = this;\n        stage_change: while (true) {\n            var state_1 = _loop_1();\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n            switch (state_1) {\n                case \"continue-stage_change\": continue stage_change;\n            }\n        }\n    };\n    /**\n     * Stops background validation.\n     */\n    Validator.prototype.stop = function () {\n        this._stop();\n    };\n    /**\n     * This private method takes an argument that allows setting the working state\n     * to a specific value. This is useful to reduce the number of\n     * ``state-update`` events emitted when some internal operations are\n     * performed. The alternative would be to perform a state change before or\n     * after the call to ``stop``, which would result in more events being\n     * emitted.\n     *\n     * If the parameter is unused, then the logic is that if we were not yet in a\n     * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n     *\n     * @param state The state with which to stop.\n     */\n    Validator.prototype._stop = function (state) {\n        if (this._timeoutId !== undefined) {\n            clearTimeout(this._timeoutId);\n        }\n        this._timeoutId = undefined;\n        if (state === undefined) {\n            // We are stopping prematurely, update the state\n            if (this._workingState === WorkingState.WORKING) {\n                this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n            }\n        }\n        else {\n            this._setWorkingState(state, this._partDone);\n        }\n    };\n    /**\n     * Run document-level validation that cannot be modeled by Relax NG.  The\n     * default implementation does nothing. Deriving classes may override it to\n     * call [[_processError]].\n     */\n    Validator.prototype._runDocumentValidation = function () { }; // tslint:disable-line: no-empty\n    /**\n     * Restarts validation from a specific point. After the call returns, the\n     * background validation will be in effect. (So calling it on a stopped\n     * validator has the side effect of starting it.)\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.restartAt = function (node) {\n        this.resetTo(node);\n        this.start();\n    };\n    /**\n     * Reset validation to continue from a certain point.\n     *\n     * @param node The element to start validation from.\n     */\n    Validator.prototype.resetTo = function (node) {\n        // We use `this._resetting` to avoid a costly reinitialization if this\n        // method is called twice in a row before any work has had a chance to be\n        // done.\n        if (!this._resetting) {\n            this._resetting = true;\n            this._resetTo(node);\n        }\n    };\n    Validator.prototype._erase = function (el) {\n        this._clearNodeProperties(el);\n        var child = el.firstElementChild;\n        while (child !== null) {\n            this._erase(child);\n            child = child.nextElementSibling;\n        }\n    };\n    /**\n     * Resets validation to continue from a specific point. Any further work done\n     * by the validator will start from the point specified.\n     *\n     * @param node The element to start validation from.\n     *\n     * @emits module:validator~Validator#reset-errors\n     */\n    // @ts-ignore\n    Validator.prototype._resetTo = function (node) {\n        // An earlier implementation was trying to be clever and to avoid restarting\n        // much earlier than strictly needed. That ended up being more costly than\n        // doing this primitive restart from 0 no matter what. Eventually, Validator\n        // should be updated so that on large documents, restarting from a location\n        // towards the end does not require revalidating the whole document. For\n        // now, since wed is used for smallish documents, it would be a premature\n        // optimization.\n        this._erase(this.root);\n        this._validationStage = 2 /* CONTENTS */;\n        this._previousChild = null;\n        this._validationWalker = this.schema.newWalker();\n        this._validationEvents = [];\n        this._curEl = this.root;\n        this._partDone = 0;\n        this._errors = [];\n        this._errorsSeen = Object.create(null);\n        this._walkerCache = Object.create(null);\n        this._walkerCacheMax = -1;\n        /**\n         * Tells the listener that it must reset its list of errors.\n         *\n         * @event module:validator~Validator#reset-errors\n         * @type {Object}\n         * @property {integer} at The index of the first error that must\n         * be deleted. This error and all those after it must be deleted.\n         */\n        this._events._emit(\"reset-errors\", { at: 0 });\n    };\n    /**\n     * Sets the working state of the validator. Emits a \"state-update\" event if\n     * the state has changed.\n     *\n     * @param newState The new state of the validator.\n     *\n     * @param newDone The new portion of work done.\n     *\n     * @emits module:validator~Validator#state-update\n     */\n    Validator.prototype._setWorkingState = function (newState, newDone) {\n        var changed = false;\n        if (this._workingState !== newState) {\n            this._workingState = newState;\n            changed = true;\n        }\n        if (this._partDone !== newDone) {\n            this._partDone = newDone;\n            changed = true;\n        }\n        if (changed) {\n            /**\n             * Tells the listener that the validator has changed state.\n             *\n             * @event module:validator~Validator#state-update\n             */\n            this._events._emit(\"state-update\", { state: newState, partDone: newDone });\n        }\n    };\n    /**\n     * Gets the validator working state.\n     *\n     * @returns The working state\n     */\n    Validator.prototype.getWorkingState = function () {\n        return {\n            state: this._workingState,\n            partDone: this._partDone,\n        };\n    };\n    Object.defineProperty(Validator.prototype, \"errors\", {\n        /**\n         * The current set of errors.\n         */\n        get: function () {\n            return this._errors.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Processes the result of firing a tag event. It will emit an \"error\"\n     * event for each error.\n     *\n     * @param results The results of the walker's ``fireEvent`` call.\n     *\n     * @param node The data node to which the result belongs.\n     *\n     * @param index The index into ``node`` to which the result belongs.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processEventResult = function (results, node, index) {\n        try {\n            for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n                var result = results_1_1.value;\n                this._processError({ error: result, node: node, index: index });\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        var e_3, _a;\n    };\n    /**\n     * This method should be called whenever a new error is detected. It\n     * records the error and emits the corresponding event.\n     *\n     * @param error The error found.\n     *\n     * @emits module:validator~Validator#error\n     */\n    Validator.prototype._processError = function (error) {\n        var _this = this;\n        /**\n         * We don't make this a method because it should only be called from\n         * ``_processError``. The way we generate new ID values works **only**\n         * because we push a new error in the list when there's no ID already set.\n         *\n         * Ensure the node has an error ID and return it. The error ID is the number\n         * set on the ``ErrorId`` property. If the node has no ID set yet, we assign\n         * one and return the new value. Otherwise, the old value is returned.\n         *\n         * @param node The node of interest.\n         *\n         * @returns The error ID.\n         */\n        var ensureErrorId = function (nodeGettingId) {\n            var oldId = _this.getNodeProperty(nodeGettingId, \"ErrorId\");\n            if (oldId === undefined) {\n                // The length of the error array at the time of first calling this\n                // function is good enough to serve as an ID.\n                oldId = _this._errors.length;\n                _this._setNodeProperty(nodeGettingId, \"ErrorId\", oldId);\n            }\n            return oldId;\n        };\n        // We must first check whether we've seen this error before, and avoid\n        // recording it again if we've seen it. This could happen when\n        // ``_getWalkerAt`` is used, because the validator may repeat firing events\n        // and processing the associated errors. We cannot just turn off error\n        // processing when ``_getWalkerAt`` is used because it may be used in cases\n        // where we are legitimately advancing the state of validation (rather than\n        // going over old stuff).\n        var node = error.node;\n        var errorId = node == null ? \"\" : String(ensureErrorId(node));\n        var key = errorId + \",\" + error.error.toString();\n        var alreadySeen = this._errorsSeen[key];\n        // We want to do a strict compare with true to handle ``undefined``.\n        if (alreadySeen !== true) {\n            this._errorsSeen[key] = true;\n            this._errors.push(error);\n            /**\n             * Tells the listener that an error has occurred.\n             *\n             * @event module:validator~Validator#error\n             * @type {Object}\n             * @property {Object} error The validation error.\n             * @property {Node} node The node where the error occurred.\n             * @property {integer} index The index in this node.\n             */\n            this._events._emit(\"error\", error);\n        }\n    };\n    /**\n     * Fires all the attribute events for a given element.\n     */\n    Validator.prototype._fireAttributeEvents = function (walker, el) {\n        // Find all attributes, fire events for them.\n        var attributes = el.attributes;\n        // tslint:disable-next-line:prefer-for-of\n        for (var i = 0; i < attributes.length; ++i) {\n            var attr = attributes[i];\n            // Skip those attributes which are namespace attributes.\n            if ((attr.name === \"xmlns\") ||\n                (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n                continue;\n            }\n            if (this._fireAttributeNameEvent(walker, attr)) {\n                this._fireAndProcessEvent(walker, \"attributeValue\", [attr.value], attr, 0);\n            }\n        }\n    };\n    /**\n     * Fires an attributeName event. If the attribute name is in a namespace and\n     * cannot be resolved, the event is not fired.\n     *\n     * @returns True if the event was actually fired, false if not.\n     */\n    Validator.prototype._fireAttributeNameEvent = function (walker, attr) {\n        var attrName = attr.name;\n        var ename = walker.resolveName(attrName, true);\n        if (ename === undefined) {\n            this._processError({ error: new salve_1.ValidationError(\"cannot resolve attribute name \" + attrName), node: attr, index: 0 });\n            return false;\n        }\n        this._setPossibleDueToWildcard(attr, walker, \"attributeName\", ename.ns, ename.name);\n        this._fireAndProcessEvent(walker, \"attributeName\", [ename.ns, ename.name], attr, 0);\n        return true;\n    };\n    /**\n     * Convenience method to fire events.\n     *\n     * @param walker The walker on which to fire events.\n     *\n     * @param name The name of the event to fire.\n     *\n     * @param params The event's parameters.\n     *\n     * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n     * can be undefined for events that have no location associated with them.\n     *\n     * @param ix The index into ``el`` associated with this event, or a ``Node``\n     * which must be a child of ``el``. The index will be computed from the\n     * location of the child passed as this parameter in ``el``.\n     */\n    Validator.prototype._fireAndProcessEvent = function (walker, name, params, el, ix) {\n        this._validationEvents.push({ name: name, params: params });\n        switch (name) {\n            case \"enterContext\":\n                walker.enterContext();\n                return;\n            case \"leaveContext\":\n                walker.leaveContext();\n                return;\n            case \"definePrefix\":\n                walker.definePrefix(params[0], params[1]);\n                return;\n            default:\n                var eventResult = walker.fireEvent(name, params);\n                if (eventResult instanceof Array) {\n                    if (el != null && ix !== undefined && typeof ix !== \"number\") {\n                        // tslint:disable-next-line:no-parameter-reassignment\n                        ix = _indexOf(el.childNodes, ix);\n                    }\n                    this._processEventResult(eventResult, el, ix);\n                }\n        }\n    };\n    /**\n     * Force an immediate validation which is guaranteed to go at least up to the\n     * point specified by ``container, index``, exclusively. These parameters are\n     * interpreted in the same way a DOM caret is.\n     *\n     * If the validation has not yet reached the location specified, validation\n     * will immediately be performed to reach the point. If the validation has\n     * already reached this point, then this call is a no-op.\n     *\n     * There is one exception in the way the ``container, index`` pair is\n     * interpreted. If the container is the ``root`` that was passed when\n     * constructing the Validator, then setting ``index`` to a negative value will\n     * result in the validation validating all elements **and** considering the\n     * document complete. So unclosed tags or missing elements will be\n     * reported. Otherwise, the validation goes up the ``index`` but considers the\n     * document incomplete, and won't report the errors that are normally reported\n     * at the end of a document. For instance, unclosed elements won't be\n     * reported.\n     *\n     * @param container The location up to where to validate.\n     *\n     * @param index The location up to where to validate.\n     *\n     * @param attributes Whether we are interested to validate up to and including\n     * the attribute events of the node pointed to by ``container, index``. The\n     * validation ends before leaving the start tag.\n     *\n     * @throws {Error} If ``container`` is not of element or text type.\n     */\n    Validator.prototype._validateUpTo = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        // tslint:disable-next-line:no-parameter-reassignment\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to validate after attributes but before \" +\n                \"the end of the start tag on a \" +\n                \"node which is not an element node\");\n        }\n        // Set these to reasonable defaults. The rest of the code is dedicated to\n        // changing these values to those necessary depending on specifics of what\n        // is passed to the method.\n        var toInspect = container;\n        var dataKey = \"EventIndexAfter\";\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (attributes) {\n                dataKey = \"EventIndexAfterAttributes\";\n                toInspect = container.childNodes[index];\n            }\n            else if (index === 0) {\n                // We're before the top element, no events to fire.\n                return;\n            }\n            // default values of toInspect and dataKey are what we want\n        }\n        else {\n            if (exports.isAttr(container)) {\n                // tslint:disable-next-line:no-non-null-assertion\n                toInspect = container.ownerElement;\n                dataKey = \"EventIndexBeforeAttributes\";\n            }\n            else {\n                switch (container.nodeType) {\n                    case Node.TEXT_NODE:\n                        toInspect = container.previousElementSibling;\n                        if (toInspect === null) {\n                            // tslint:disable-next-line:no-non-null-assertion\n                            toInspect = container.parentNode;\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    case Node.ELEMENT_NODE:\n                    case Node.DOCUMENT_FRAGMENT_NODE:\n                    case Node.DOCUMENT_NODE:\n                        var node = container.childNodes[index];\n                        var prev = node === undefined ?\n                            container.lastElementChild :\n                            // It may not be an element, in which case we get \"undefined\".\n                            node.previousElementSibling;\n                        if (attributes) {\n                            dataKey = \"EventIndexAfterAttributes\";\n                            toInspect = node;\n                        }\n                        else if (prev !== null) {\n                            toInspect = prev;\n                        }\n                        else {\n                            dataKey = \"EventIndexAfterStart\";\n                        }\n                        break;\n                    default:\n                        throw new Error(\"unexpected node type: \" + container.nodeType);\n                }\n            }\n        }\n        while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n            this._cycle();\n        }\n    };\n    /**\n     * Gets the walker which would represent the state of parsing at the point\n     * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n     * of how these parameters are interpreted.\n     *\n     * **The walker returned by this function is not guaranteed to be a new\n     *   instance. Callers should not modify the walker returned but instead clone\n     *   it.**\n     *\n     * @param container\n     *\n     * @param index\n     *\n     * @param attributes Whether we are interested to validate up to but not\n     * including the attribute events of the node pointed to by ``container,\n     * index``. If ``true`` the walker returned will have all events fired on it\n     * up to, and including, those attribute events on the element pointed to by\n     * ``container, index``.\n     *\n     * @returns The walker.\n     *\n     * @throws {EventIndexException} If it runs out of events or computes an event\n     * index that makes no sense.\n     */\n    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n    Validator.prototype._getWalkerAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        // tslint:disable-next-line:no-parameter-reassignment\n        attributes = !!attributes; // Normalize.\n        if (attributes && (container.childNodes === undefined ||\n            container.childNodes[index].nodeType !==\n                Node.ELEMENT_NODE)) {\n            throw new Error(\"trying to get a walker for attribute events on a \" +\n                \"node which is not an element node\");\n        }\n        // Make sure we have the data we need.\n        this._validateUpTo(container, index, attributes);\n        // This function could be called with container === root if the document is\n        // empty or if the user has the caret before the start tag of the first\n        // element of the actual structure we want to validate or after the end tag\n        // of that element.\n        if (container === this.root && index <= 0) {\n            if (!attributes) {\n                // We're before the top element, no events to fire.\n                if (index === 0) {\n                    return this.schema.newWalker();\n                }\n                // _validateUpTo ensures that the current walker held by the validator\n                // is what we want. We can just return it here because it is the\n                // caller's reponsibility to either not modify it or clone it.\n                return this._validationWalker;\n            }\n        }\n        var walker;\n        function fireTextEvent(textNode) {\n            if (walker === undefined) {\n                throw new Error(\"calling fireTextEvent without a walker\");\n            }\n            walker.fireEvent(\"text\", [textNode.data]);\n        }\n        if (exports.isAttr(container)) {\n            // tslint:disable-next-line:no-non-null-assertion\n            var el = container.ownerElement;\n            walker = this.readyWalker(\n            // tslint:disable-next-line:no-non-null-assertion\n            this.getNodeProperty(el, \"EventIndexBeforeAttributes\"));\n            // Don't fire on namespace attributes.\n            if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n                walker = walker.clone();\n                this._fireAttributeNameEvent(walker, container);\n            }\n        }\n        else {\n            switch (container.nodeType) {\n                case Node.TEXT_NODE: {\n                    var prev = container.previousElementSibling;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (prev !== null) {\n                        getFrom = prev;\n                        propName = \"EventIndexAfter\";\n                    }\n                    else {\n                        // tslint:disable-next-line:no-non-null-assertion\n                        getFrom = container.parentNode;\n                        propName = \"EventIndexAfterStart\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    // We will attempt to fire a text event if our location is inside the\n                    // current text node.\n                    //\n                    // A previous version of this code was also checking whether there is a\n                    // text node between this text node and prev but this cannot happen\n                    // because the tree on which validation is performed cannot have two\n                    // adjacent text nodes. It was also checking whether there was a _text\n                    // element between prev and this text node but this also cannot happen.\n                    if (index > 0) {\n                        walker = walker.clone();\n                        fireTextEvent(container);\n                    }\n                    break;\n                }\n                case Node.ELEMENT_NODE:\n                case Node.DOCUMENT_NODE:\n                case Node.DOCUMENT_FRAGMENT_NODE: {\n                    var node = container.childNodes[index];\n                    var prev = void 0;\n                    var getFrom = void 0;\n                    var propName = void 0;\n                    if (!attributes) {\n                        prev = node === undefined ? container.lastElementChild :\n                            node.previousElementSibling;\n                        if (prev !== null) {\n                            getFrom = prev;\n                            propName = \"EventIndexAfter\";\n                        }\n                        else {\n                            getFrom = container;\n                            propName = \"EventIndexAfterStart\";\n                        }\n                    }\n                    else {\n                        getFrom = node;\n                        propName = \"EventIndexAfterAttributes\";\n                    }\n                    // tslint:disable-next-line:no-non-null-assertion\n                    walker = this.readyWalker(this.getNodeProperty(getFrom, propName));\n                    if (!attributes) {\n                        // We will attempt to fire a text event if another text node appeared\n                        // between the node we care about and the element just before it.\n                        var prevSibling = node != null ? node.previousSibling : null;\n                        if (prevSibling !== null &&\n                            // If the previous sibling is the same as the previous *element*\n                            // sibbling, then there is nothing *between* that we need to take\n                            // care of.\n                            prevSibling !== prev) {\n                            if (prevSibling.nodeType === Node.TEXT_NODE) {\n                                walker = walker.clone();\n                                fireTextEvent(prevSibling);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(\"unexpected node type: \" + container.nodeType);\n            }\n        }\n        return walker;\n    };\n    Validator.prototype.readyWalker = function (eventIndex) {\n        //\n        // Perceptive readers will notice that the caching being done here could be\n        // more aggressive. It turns out that the cases where we have to clone the\n        // walker after getting it from the cache are not that frequently used, so\n        // there is little to gain from being more aggressive. Furthermore, it is\n        // likely that the caching system will change when we implement a saner way\n        // to reset validation and segment large documents into smaller chunks.\n        //\n        if (eventIndex === undefined) {\n            throw new EventIndexException();\n        }\n        var cache = this._walkerCache;\n        var max = this._walkerCacheMax;\n        var walker = cache[eventIndex];\n        if (walker !== undefined) {\n            return walker;\n        }\n        //\n        // Scan the cache for a walker we could use... rather than start from zero.\n        //\n        // There is no point in trying to be clever by using this._walkerCacheGap to\n        // start our search. If _getWalkerAt is called with decreasing positions in\n        // the document, then the gap is meaningless for our search. (Such scenario\n        // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n        // cannot assume that it won't happen.)\n        //\n        // Also, the following approach is a bit crude but trying to be clever with\n        // Object.keys() and then searching through a sorted list does not yield an\n        // appreciable improvement. Maybe on very large documents it would but this\n        // module will have to be redesigned to tackle that so there's no point now\n        // to be cleverer than this. We also tested using a sparse Array for the\n        // cache and got visibly worse performance. And we tested to see if a flag\n        // indicating if the cache has anything in it would help avoid doing a long\n        // search but it maked things worse. Basically, it seems that the typical\n        // usage pattern of _getWalkerAt is such that it will usually be called in\n        // increasing order of position in the document.\n        //\n        var searchIx = eventIndex;\n        if (searchIx >= max) {\n            searchIx = max;\n            walker = cache[searchIx];\n        }\n        else {\n            while (walker === undefined && --searchIx >= 0) {\n                walker = cache[searchIx];\n            }\n        }\n        if (walker !== undefined) {\n            walker = walker.clone();\n        }\n        else {\n            walker = this.schema.newWalker();\n            searchIx = 0;\n        }\n        for (var ix = searchIx; ix < eventIndex; ++ix) {\n            var _a = this._validationEvents[ix], name_1 = _a.name, params = _a.params;\n            switch (name_1) {\n                case \"enterContext\":\n                    walker.enterContext();\n                    break;\n                case \"leaveContext\":\n                    walker.leaveContext();\n                    break;\n                case \"definePrefix\":\n                    walker.definePrefix(params[0], params[1]);\n                    break;\n                default:\n                    walker.fireEvent(name_1, params);\n            }\n        }\n        // This is a bit arbitrary to find a balance between caching too much\n        // information and spending too much time computing walkers.\n        if (eventIndex - searchIx >= this._walkerCacheGap) {\n            cache[eventIndex] = walker;\n            this._walkerCacheMax = Math.max(eventIndex, max);\n        }\n        return walker;\n    };\n    /**\n     * Returns the set of possible events for the location specified by the\n     * parameters.\n     *\n     * @param container Together with ``index`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param index Together with ``container`` this parameter is interpreted to\n     * form a location.\n     *\n     * @param attributes\n     *\n     * @returns A set of possible events.\n     */\n    Validator.prototype.possibleAt = function (container, index, attributes) {\n        if (attributes === void 0) { attributes = false; }\n        var walker = this._getWalkerAt(container, index, attributes);\n        // Calling possible does not *modify* the walker.\n        return walker.possible();\n    };\n    /**\n     * Finds the locations in a node where a certain validation event is\n     * possible.\n     *\n     * @param container A node.\n     *\n     * @param event The event to search for. The event should contain the same\n     * data as would be passed to ``fireEvent``. Specifically, name patterns may\n     * not be used in the event passed to this method.\n     *\n     * @returns The locations in ``container`` where the event is possible.\n     */\n    Validator.prototype.possibleWhere = function (container, event) {\n        var ret = [];\n        var params = event.params;\n        try {\n            for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n                var param = params_1_1.value;\n                if (typeof param !== \"string\") {\n                    throw new Error(\"this method does not accept event with name \\\npatterns: convert the pattern to a uri, localPart pair\");\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        var name = params[0];\n        if (name === \"startTagAndAttributes\" || name === \"attributeNameAndValue\") {\n            throw new Error(\"this method does not support \" + name + \": you must use granular events instead\");\n        }\n        var eventString = event.toString();\n        var hasNamePattern = name === \"enterStartTag\" || name === \"attributeName\";\n        for (var index = 0; index <= container.childNodes.length; ++index) {\n            var possible = this.possibleAt(container, index);\n            if (hasNamePattern) {\n                try {\n                    // In the case where we have a name pattern as the 2nd parameter, and\n                    // this pattern can be complex or have wildcards, then we have to check\n                    // all events one by one for a name pattern match. (While enterStartTag,\n                    // endTag and attributeName all have name patterns, endTag cannot be\n                    // complex or allow wildcards because what it allows much match the tag\n                    // that started the current element. This is why we do not use this\n                    // branch to test for it.)\n                    for (var possible_1 = __values(possible), possible_1_1 = possible_1.next(); !possible_1_1.done; possible_1_1 = possible_1.next()) {\n                        var candidate = possible_1_1.value;\n                        if (candidate.params[0] === name &&\n                            candidate.params[1].match(params[1], params[2])) {\n                            ret.push(index);\n                            break;\n                        }\n                    }\n                }\n                catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                finally {\n                    try {\n                        if (possible_1_1 && !possible_1_1.done && (_b = possible_1.return)) _b.call(possible_1);\n                    }\n                    finally { if (e_5) throw e_5.error; }\n                }\n            }\n            else {\n                try {\n                    for (var possible_2 = __values(possible), possible_2_1 = possible_2.next(); !possible_2_1.done; possible_2_1 = possible_2.next()) {\n                        var candidate = possible_2_1.value;\n                        if (candidate.toString() === eventString) {\n                            ret.push(index);\n                            break;\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (possible_2_1 && !possible_2_1.done && (_c = possible_2.return)) _c.call(possible_2);\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            }\n        }\n        return ret;\n        var e_4, _a, e_5, _b, e_6, _c;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidate = function (container, index, toParse) {\n        var clone;\n        if (toParse instanceof Array) {\n            clone = container.ownerDocument.createDocumentFragment();\n            try {\n                for (var toParse_1 = __values(toParse), toParse_1_1 = toParse_1.next(); !toParse_1_1.done; toParse_1_1 = toParse_1.next()) {\n                    var child = toParse_1_1.value;\n                    clone.insertBefore(child.cloneNode(true), null);\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (toParse_1_1 && !toParse_1_1.done && (_a = toParse_1.return)) _a.call(toParse_1);\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n        }\n        else {\n            clone = toParse.cloneNode(true);\n        }\n        var root = container.ownerDocument.createElement(\"div\");\n        root.insertBefore(clone, null);\n        return this.speculativelyValidateFragment(container, index, root);\n        var e_7, _a;\n    };\n    /**\n     * Validate a DOM fragment as if it were present at the point specified in the\n     * parameters in the DOM tree being validated.\n     *\n     * WARNING: This method will not catch unclosed elements. This is because the\n     * fragment is not considered to be a \"complete\" document. Unclosed elements\n     * or fragments that are not well-formed must be caught by other means.\n     *\n     * @param container The location in the tree to start at.\n     *\n     * @param index The location in the tree to start at.\n     *\n     * @param toParse The fragment to parse. See above.\n     *\n     * @returns Returns an array of errors if there is an error. Otherwise returns\n     * false.\n     */\n    Validator.prototype.speculativelyValidateFragment = function (container, index, toParse) {\n        // This is useful for pure-JS code that may be calling this.\n        if (toParse.nodeType !== Node.ELEMENT_NODE) {\n            throw new Error(\"toParse is not an element\");\n        }\n        // We create a new validator with the proper state to parse the fragment\n        // we've been given.\n        var dup = new Validator(this.schema, toParse);\n        // We have to clone the walker to prevent messing up the internal cache.\n        dup._validationWalker = this._getWalkerAt(container, index).clone();\n        // This forces validating the whole fragment\n        dup._validateUpTo(toParse, toParse.childNodes.length);\n        if (dup._errors.length !== 0) {\n            return dup._errors;\n        }\n        return false;\n    };\n    /**\n     * Obtain the validation errors that belong to a specific node.\n     *\n     * The term \"that belong to\" has a specific meaning here:\n     *\n     * - An error in the contents of an element belongs to the element whose\n     *   contents are incorrect. For instance if in the sequence\n     *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n     *   error belongs to the node for the element ``foo``, not the node for the\n     *   element ``blip``.\n     *\n     * - Attribute errors belong to the element node to which the attributes\n     *   belong.\n     *\n     * @param node The node whose errors we want to get.\n     *\n     * @returns The errors.\n     */\n    Validator.prototype.getErrorsFor = function (node) {\n        var parent = node.parentNode;\n        if (parent === null) {\n            throw new Error(\"node without a parent!\");\n        }\n        // Validate to after the closing tag of the node.\n        this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n        var ret = [];\n        try {\n            for (var _a = __values(this._errors), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var errorData = _b.value;\n                if (errorData.node === node) {\n                    ret.push(errorData);\n                }\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n        return ret;\n        var e_8, _c;\n    };\n    /**\n     * Sets a flag indicating whether a node is possible only due to a name\n     * pattern wildcard, and emits an event if setting the flag is a change from\n     * the previous value of the flag. It does this by inspecting the event that\n     * would be fired when ``node`` is validated. The parameters ``eventName``,\n     * ``ns`` and ``name`` are used to determine what we are looking for among\n     * possible events.\n     *\n     * @param node The node we want to check.\n     *\n     * @param walker A walker whose last fired event is the one just before the\n     * event that would be fired when validating ``node``.\n     *\n     * @param eventName The event name we are interested in.\n     *\n     * @param ns The namespace to use with the event.\n     *\n     * @param name The name to use with the event.\n     *\n     * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n     *\n     */\n    Validator.prototype._setPossibleDueToWildcard = function (node, walker, eventName, ns, name) {\n        var previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n        var possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n        this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n        if (previous === undefined || previous !== possible) {\n            /**\n             * Tells the listener that a node's flag indicating whether it is possible\n             * only due to a wildcard has changed.\n             *\n             * @event module:validator~Validator#possible-due-to-wildcard-change\n             *\n             * @type {Node} The node whose flag has changed.\n             */\n            this._events._emit(\"possible-due-to-wildcard-change\", node);\n        }\n    };\n    /**\n     * Resolve a qualified name to an expanded name. See\n     * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n     * takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param name The name to rresolve.\n     *\n     * @param attributes Whether the name is an attribute's name.\n     *\n     * @return The resolved name.\n     */\n    Validator.prototype.resolveNameAt = function (container, index, name, attribute) {\n        if (attribute === void 0) { attribute = false; }\n        // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n        // its ``attribute`` parameter ``false``.\n        return this._getWalkerAt(container, index).resolveName(name, attribute);\n    };\n    /**\n     * Unresolve an expanded name to a qualified name. See\n     * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n     * method takes into account namespaces defined on parent nodes.\n     *\n     * @param container Where to perform the operation.\n     *\n     * @param index Where to perform the operation.\n     *\n     * @param uri The URI to unresolve.\n     *\n     * @param name The name to unresolve.\n     *\n     * @return The unresolved name.\n     */\n    Validator.prototype.unresolveNameAt = function (container, index, uri, name) {\n        return this._getWalkerAt(container, index).unresolveName(uri, name);\n    };\n    return Validator;\n}());\nexports.Validator = Validator;\n/**\n * Exception to be raised if we cannot parse a string as an XML document.\n */\nvar ParsingError = /** @class */ (function (_super) {\n    __extends(ParsingError, _super);\n    /**\n     * @param xmlErrors A string that contains the errors reported. The library\n     * here simply serializes the error document produced by the parser.\n     */\n    function ParsingError(xmlErrors) {\n        var _this = _super.call(this) || this;\n        _this.xmlErrors = xmlErrors;\n        var err = new Error(\"cannot parse\");\n        _this.name = \"ParsingError\";\n        _this.stack = err.stack;\n        _this.message = err.message;\n        tools_1.fixPrototype(_this, ParsingError);\n        return _this;\n    }\n    return ParsingError;\n}(Error));\nexports.ParsingError = ParsingError;\n// tslint:disable-next-line:no-http-string\nvar XML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\nvar MOZILLA_NAMESPACE = \n// tslint:disable-next-line:no-http-string\n\"http://www.mozilla.org/newlayout/xml/parsererror.xml\";\n/**\n * A utility function that detects whether the parsing fails and throws an error\n * in such case.\n *\n * Note that if you pass a well-formed and correctly structured error document\n * to this function, the result will look like an error, even though it was\n * parsed properly. Given the way ``DOMParser`` reports errors, this cannot be\n * helped.\n *\n * @param source The XML to parse.\n *\n * @param win The window from which to create a ``DOMParser``.\n *\n * @returns The parsed document.\n *\n * @throws {ParsingError} If the source cannot be parsed.\n */\nfunction safeParse(source, win) {\n    if (win === void 0) { win = window; }\n    var parser = new win.DOMParser();\n    var doc;\n    try {\n        doc = parser.parseFromString(source, \"text/xml\");\n    }\n    catch (ex) {\n        // On IE10/11 bad source will cause a SyntaxError.\n        if (ex.name !== \"SyntaxError\" || ex.code !== 12) {\n            throw ex;\n        }\n        throw new ParsingError(\"no error information available\");\n    }\n    // A DOMParser will generate a document that contains a description of the\n    // error(s). Unfortunately, this document is not consistently generated across\n    // browsers.\n    //\n    // However, running the code through Browser Stack on Chrome, Firefox, IE\n    // 10-100, Edge, Opera, and Safari that they boil down either to the Chrome\n    // case or the Firefox case.\n    if (\n    // Firefox\n    (doc.getElementsByTagNameNS(MOZILLA_NAMESPACE, \"parsererror\")[0] !==\n        undefined) ||\n        // Chrome\n        (doc.getElementsByTagNameNS(XML_NAMESPACE, \"parsererror\")[0] !==\n            undefined)) {\n        throw new ParsingError(doc.documentElement.outerHTML);\n    }\n    return doc;\n}\nexports.safeParse = safeParse;\n//# sourceMappingURL=main.js.map"],"sourceRoot":""}