{"version":3,"file":"doc-pattern.js","sourceRoot":"","sources":["../../../../../../lib/wed/modes/generic/doc-pattern.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Facilities for interpreting the patterns passed in dochtml in\n * metadata files.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\n/**\n * An execution context for a pattern.\n */\nexport interface Context {\n  /**\n   * Resolve an interpolated name to a value.\n   *\n   * @param name The name to resolve.\n   *\n   * @returns The resolved name. An unresolvable name raise an error.\n   */\n  resolveName(name: string): string;\n}\n\n/**\n * A compiled pattern.\n */\nexport interface DocPattern {\n  /**\n   * Execute the pattern so as to get a value.\n   *\n   * @param context The execution context for the pattern.\n   *\n   * @returns The evaluated pattern.\n   */\n  execute(context: Context): string;\n}\n\n/**\n * A literal value in a pattern.\n */\nclass Literal {\n  /**\n   * @param value The value to which this literal resolves to.\n   */\n  constructor(private readonly value: string) {}\n\n  execute(): string {\n    return this.value;\n  }\n}\n\n/**\n * A concatenation operation.\n */\nclass Concat {\n  /**\n   * @param values The patterns to concatenate.\n   */\n  constructor(private readonly values: DocPattern[]) {}\n\n  execute(context: Context): string {\n    return this.values.map((value) => value.execute(context)).join(\"\");\n  }\n}\n\n/**\n * An interpolation like ``${foo}``.\n */\nclass Interpolation {\n  /**\n   * @param name The name to interpolate.\n   */\n  constructor(private readonly name: string) {}\n\n  execute(context: Context): string {\n    return context.resolveName(this.name);\n  }\n}\n\n/**\n * A substitution operation, like in ``${foo:s(\"a\",\"b\")}``.\n */\nclass Substitution {\n  constructor(private readonly pattern: string,\n              private readonly substitution: string,\n              private readonly child: DocPattern) {}\n\n  execute(context: Context): string {\n    const value = this.child.execute(context);\n    return value.replace(this.pattern, this.substitution);\n  }\n}\n\n/**\n * Compile a string pattern to a [[DocPattern]] object.\n *\n * @param pattern The pattern to compile.\n *\n * @returns The compiled pattern.\n */\nexport function compile(pattern: string): DocPattern {\n  const parts = pattern.split(/(\\$\\{|\\})/);\n\n  const patterns: DocPattern[] = [];\n  let interpolating = false;\n  for (const part of parts) {\n    // tslint:disable-next-line:no-invalid-template-strings\n    if (part === \"${\") {\n      if (interpolating) {\n        throw new Error(\"nested interpolations are invalid\");\n      }\n\n      interpolating = true;\n    }\n    else if (part === \"}\") {\n      if (!interpolating) {\n        throw new Error(\"errant interpolation closure\");\n      }\n      interpolating = false;\n    }\n    else if (interpolating) {\n      const [name, transform] = part.split(\":\", 1);\n\n      if (transform === undefined) {\n        patterns.push(new Interpolation(name));\n      }\n      else {\n        if (transform[0] === \"s\") {\n          const paramList = transform.slice(1);\n          if (paramList[0] !== \"(\" || paramList[paramList.length - 1] !== \")\") {\n            throw new Error(\"transform parameters must be in parentheses\");\n          }\n\n          // We slice to drop the parentheses.\n          let params = paramList.slice(1, -1).split(\",\").map((x) => x.trim());\n          if (params.length !== 2) {\n            throw new Error(\"an s transform takes 2 parameters\");\n          }\n\n          for (const param of params) {\n            if (param[0] !== \"\\\"\" || param[param.length - 1] !== \"\\\"\") {\n              throw new Error(`parameter must be a string wrapped in double \\\nquotes: ${param}`);\n            }\n          }\n\n          // Drop the wrapping quotes.\n          params = params.map((x) => x.slice(1, -1));\n          patterns.push(new Substitution(params[0], params[1],\n                                         new Interpolation(name)));\n        }\n        else {\n          throw new Error(`unknown transform ${transform}`);\n        }\n      }\n    }\n    else {\n      patterns.push(new Literal(part));\n    }\n  }\n\n  if (interpolating) {\n    throw new Error(\"an interpolation was not closed\");\n  }\n\n  return new Concat(patterns);\n}\n\n//  LocalWords:  dochtml MPL unresolvable param\n"]}