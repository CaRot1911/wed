{"version":3,"file":"metadata-json-reader.js","sourceRoot":"","sources":["../../../../../../lib/wed/modes/generic/metadata-json-reader.ts"],"names":[],"mappings":";;;;;;;IAWA;;OAEG;IACH;QAIE;;WAEG;QACH,4BAA6B,MAAU;YAAV,WAAM,GAAN,MAAM,CAAI;QAAG,CAAC;QAK3C,sBAAc,yCAAS;YAHvB;;eAEG;iBACH;gBACE,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE;oBACjC,IAAM,GAAG,GAAG,IAAI,aAAG,EAAE,CAAC;oBACtB,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBAC5C;gBAED,OAAO,IAAI,CAAC,UAAU,CAAC;YACzB,CAAC;;;WAAA;QAED,iCAAI,GAAJ,UAAK,MAAc;YACjB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACtB,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC9B,CAAC;QAED;;;;WAIG;QACK,qCAAQ,GAAhB,UAAiB,MAAc;YAC7B,IAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YACjC,IAAM,KAAK,GAAG,SAAS,CAAC,MAAM,CAAY,CAAC;YAC3C,IAAI,CAAC,KAAK,EAAE;gBACV,IAAI,SAAS,CAAC,MAAM,KAAK,SAAS,EAAE;oBAClC,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;iBACzD;gBACD,IAAM,KAAK,GAAG,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;gBAC9C,kEAAkE;gBAClE,aAAa;gBACb,kCAAkC;gBACjC,KAAa,CAAC,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC;gBAC7C,MAAM,KAAK,CAAC;aACb;QACH,CAAC;QAUH,yBAAC;IAAD,CAAC,AAvDD,IAuDC;IAvDqB,gDAAkB;;AAyDxC,oBAAoB","sourcesContent":["/**\n * Facilities for reading metadata stored as JSON.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport Ajv from \"ajv\";\n\nimport { Metadata } from \"./metadata\";\nimport { MetadataReader } from \"./metadata-reader\";\n\n/**\n * Base class for all JSON readers.\n */\nexport abstract class MetadataJSONReader implements MetadataReader {\n  /** The cached validator. */\n  private _validator: Ajv.ValidateFunction | undefined;\n\n  /**\n   * @param schema The JSON schema with which to validate the metadata.\n   */\n  constructor(private readonly schema: {}) {}\n\n  /**\n   * A validator that uses the schema set for this reader.\n   */\n  protected get validator(): Ajv.ValidateFunction {\n    if (this._validator === undefined) {\n      const ajv = new Ajv();\n      this._validator = ajv.compile(this.schema);\n    }\n\n    return this._validator;\n  }\n\n  read(object: Object): Metadata {\n    this.validate(object);\n    return this.convert(object);\n  }\n\n  /**\n   * Validate the object against the schema that was set for this reader.\n   *\n   * @param object The object to validate.\n   */\n  private validate(object: Object): void {\n    const validator = this.validator;\n    const valid = validator(object) as boolean;\n    if (!valid) {\n      if (validator.errors === undefined) {\n        throw new Error(\"metadata JSON invalid but no errors!\");\n      }\n      const error = new Error(\"failed to validate\");\n      // Yes, we cheat. This is not meant to be a full-fledged diagnosis\n      // mechanism.\n      // tslint:disable-next-line:no-any\n      (error as any).jsonErrors = validator.errors;\n      throw error;\n    }\n  }\n\n  /**\n   * Convert the object to a metadata instance.\n   *\n   * @param object The object to convert.\n   *\n   * @returns A new metadata instance.\n   */\n  protected abstract convert(object: Object): Metadata;\n}\n\n//  LocalWords:  MPL\n"]}